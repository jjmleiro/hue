From 22fbfe990c65126dbe3ab09a9f98afc62f4e9e78 Mon Sep 17 00:00:00 2001
From: Erick Tryzelaar <erickt@cloudera.com>
Date: Tue, 25 Nov 2014 15:31:06 -0800
Subject: [PATCH 0614/1173] [spark] Reorganize the code

---
 .../java/com/cloudera/hue/sparker/server/Cell.java |   63 ----
 .../hue/sparker/server/ClosedSessionException.java |    4 -
 .../com/cloudera/hue/sparker/server/Session.java   |   42 ---
 .../hue/sparker/server/SessionManager.java         |  124 -------
 .../hue/sparker/server/SessionResource.java        |   97 ------
 .../cloudera/hue/sparker/server/SparkSession.java  |  348 --------------------
 .../cloudera/hue/sparker/server/SparkerApp.java    |    2 +
 .../sparker/server/resources/SessionResource.java  |  111 +++++++
 .../cloudera/hue/sparker/server/sessions/Cell.java |   63 ++++
 .../server/sessions/ClosedSessionException.java    |    4 +
 .../hue/sparker/server/sessions/Session.java       |   42 +++
 .../sparker/server/sessions/SessionManager.java    |  124 +++++++
 .../hue/sparker/server/sessions/SparkSession.java  |  348 ++++++++++++++++++++
 13 files changed, 694 insertions(+), 678 deletions(-)
 delete mode 100644 apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/Cell.java
 delete mode 100644 apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/ClosedSessionException.java
 delete mode 100644 apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/Session.java
 delete mode 100644 apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/SessionManager.java
 delete mode 100644 apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/SessionResource.java
 delete mode 100644 apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/SparkSession.java
 create mode 100644 apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/resources/SessionResource.java
 create mode 100644 apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/sessions/Cell.java
 create mode 100644 apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/sessions/ClosedSessionException.java
 create mode 100644 apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/sessions/Session.java
 create mode 100644 apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/sessions/SessionManager.java
 create mode 100644 apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/sessions/SparkSession.java

diff --git a/apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/Cell.java b/apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/Cell.java
deleted file mode 100644
index b6a3d8d..0000000
--- a/apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/Cell.java
+++ /dev/null
@@ -1,63 +0,0 @@
-package com.cloudera.hue.sparker.server;
-
-import com.fasterxml.jackson.annotation.JsonProperty;
-
-import java.util.ArrayList;
-import java.util.List;
-
-public class Cell {
-
-    public enum State {
-        NOT_READY,
-        READY,
-        INCOMPLETE,
-        RUNNING,
-        COMPLETE,
-    }
-
-    State state;
-    final List<String> input = new ArrayList<String>();
-    final List<String> output = new ArrayList<String>();
-
-    final List<String> error = new ArrayList<String>();
-
-    public Cell() {
-        this.state = State.NOT_READY;
-    }
-
-    @JsonProperty("type")
-    public State getState() {
-        return state;
-    }
-
-    public void setState(State state) {
-        this.state = state;
-    }
-
-    @JsonProperty("input")
-    public List<String> getInput() {
-        return input;
-    }
-
-    public void addInput(String input) {
-        this.input.add(input);
-    }
-
-    @JsonProperty("output")
-    public List<String> getOutput() {
-        return output;
-    }
-
-    public void addOutput(String output) {
-        this.output.add(output);
-    }
-
-    @JsonProperty("error")
-    public List<String> getError() {
-        return error;
-    }
-
-    public void addError(String error) {
-        this.error.add(error);
-    }
-}
diff --git a/apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/ClosedSessionException.java b/apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/ClosedSessionException.java
deleted file mode 100644
index 9a51d32..0000000
--- a/apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/ClosedSessionException.java
+++ /dev/null
@@ -1,4 +0,0 @@
-package com.cloudera.hue.sparker.server;
-
-public class ClosedSessionException extends Throwable {
-}
diff --git a/apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/Session.java b/apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/Session.java
deleted file mode 100644
index a65b876..0000000
--- a/apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/Session.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.cloudera.hue.sparker.server;
-
-import com.fasterxml.jackson.annotation.JsonProperty;
-
-import java.io.IOException;
-import java.util.List;
-import java.util.concurrent.TimeoutException;
-
-public interface Session {
-
-    @JsonProperty
-    String getId();
-
-    @JsonProperty
-    List<Cell> getCells();
-
-    @JsonProperty
-    public long getLastActivity();
-
-    public Cell executeStatement(String statement) throws Exception, ClosedSessionException;
-
-    public void close() throws IOException, InterruptedException, TimeoutException;
-}
-
diff --git a/apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/SessionManager.java b/apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/SessionManager.java
deleted file mode 100644
index 6d7b639..0000000
--- a/apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/SessionManager.java
+++ /dev/null
@@ -1,124 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.cloudera.hue.sparker.server;
-
-import java.io.IOException;
-import java.util.Enumeration;
-import java.util.UUID;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.TimeoutException;
-
-public class SessionManager {
-
-    public static final int UNKNOWN = 0;
-    public static final int SCALA = 1;
-    public static final int PYTHON = 2;
-
-    private ConcurrentHashMap<String, Session> sessions = new ConcurrentHashMap<String, Session>();
-
-    public SessionManager() {
-        SessionManagerGarbageCollector gc = new SessionManagerGarbageCollector(this);
-        gc.setDaemon(true);
-        gc.start();
-    }
-
-    public Session get(String id) throws SessionNotFound {
-        Session session = sessions.get(id);
-        if (session == null) {
-            throw new SessionNotFound(id);
-        }
-        return session;
-    }
-
-    public Session create(int language) throws IllegalArgumentException, IOException, InterruptedException {
-        String id = UUID.randomUUID().toString();
-        Session session;
-        switch (language) {
-            case SCALA:  session = new SparkSession(id); break;
-            //case PYTHON: session = new PySparkSession(id); break;
-            default: throw new IllegalArgumentException("Invalid language specified for shell session");
-        }
-        sessions.put(id, session);
-        return session;
-    }
-
-    public void close() throws InterruptedException, IOException, TimeoutException {
-        for (Session session : sessions.values()) {
-            sessions.remove(session.getId());
-            session.close();
-        }
-    }
-
-    public void close(String id) throws InterruptedException, TimeoutException, IOException, SessionNotFound {
-        Session session = this.get(id);
-        sessions.remove(id);
-        session.close();
-    }
-
-    public Enumeration<String> getSessionIds() {
-        return sessions.keys();
-    }
-
-    public void garbageCollect() throws InterruptedException, IOException, TimeoutException {
-        long timeout = 60000; // Time in milliseconds; TODO: make configurable
-        for (Session session : sessions.values()) {
-            long now = System.currentTimeMillis();
-            if ((now - session.getLastActivity()) > timeout) {
-                try {
-                    this.close(session.getId());
-                } catch (SessionNotFound sessionNotFound) {
-                    // Ignore
-                }
-            }
-        }
-    }
-
-    protected class SessionManagerGarbageCollector extends Thread {
-
-        protected SessionManager manager;
-
-        protected long period = 60000; // Time in milliseconds; TODO: make configurable
-
-        public SessionManagerGarbageCollector(SessionManager manager) {
-            super();
-            this.manager = manager;
-        }
-
-        public void run() {
-            try {
-                while(true) {
-                    manager.garbageCollect();
-                    sleep(period);
-                }
-            } catch (InterruptedException e) {
-                e.printStackTrace();
-            } catch (TimeoutException e) {
-                e.printStackTrace();
-            } catch (IOException e) {
-                e.printStackTrace();
-            }
-        }
-    }
-
-    public class SessionNotFound extends Throwable {
-        public SessionNotFound(String id) {
-            super(id);
-        }
-    }
-}
diff --git a/apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/SessionResource.java b/apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/SessionResource.java
deleted file mode 100644
index 39bdec2..0000000
--- a/apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/SessionResource.java
+++ /dev/null
@@ -1,97 +0,0 @@
-package com.cloudera.hue.sparker.server;
-
-import com.codahale.metrics.annotation.Timed;
-import com.sun.jersey.core.spi.factory.ResponseBuilderImpl;
-
-import javax.validation.Valid;
-import javax.ws.rs.*;
-import javax.ws.rs.core.MediaType;
-import javax.ws.rs.core.Response;
-import java.io.IOException;
-import java.util.Collections;
-import java.util.List;
-import java.util.concurrent.TimeoutException;
-
-@Path("/sessions")
-@Produces(MediaType.APPLICATION_JSON)
-public class SessionResource {
-
-    private static final String SCALA = "scala";
-    private static final String PYTHON = "python";
-
-    private final SessionManager sessionManager;
-
-    public SessionResource(SessionManager sessionManager) {
-        this.sessionManager = sessionManager;
-    }
-
-    @GET
-    @Timed
-    public List<String> getSessions() {
-        return Collections.list(sessionManager.getSessionIds());
-    }
-
-    @POST
-    @Timed
-    public String createSession(@QueryParam("lang") String language) throws IOException, InterruptedException {
-        int sessionType;
-
-        if (language == null) {
-            Response resp = new ResponseBuilderImpl().status(400).entity("missing language").build();
-            throw new WebApplicationException(resp);
-        }
-
-        if (language.equals(SCALA)) {
-            sessionType = SessionManager.SCALA;
-        } else if (language.equals(PYTHON)) {
-            sessionType = SessionManager.PYTHON;
-        } else {
-            Response resp = new ResponseBuilderImpl().status(400).entity("invalid language").build();
-            throw new WebApplicationException(resp);
-        }
-
-        Session session = sessionManager.create(sessionType);
-
-        return session.getId();
-    }
-
-    @Path("/{id}")
-    @GET
-    @Timed
-    public List<Cell> getSession(@PathParam("id") String id,
-                                 @QueryParam("from") Integer fromCell,
-                                 @QueryParam("limit") Integer limit) throws SessionManager.SessionNotFound {
-        Session session = sessionManager.get(id);
-        List<Cell> cells = session.getCells();
-
-        if (fromCell != null || limit != null) {
-            if (fromCell == null) {
-                fromCell = 0;
-            }
-
-            if (limit == null) {
-                limit = cells.size();
-            }
-
-            cells = cells.subList(fromCell, fromCell + limit);
-        }
-
-        return cells;
-    }
-
-    @Path("/{id}")
-    @POST
-    @Timed
-    public Cell executeStatement(@PathParam("id") String id, @Valid ExecuteStatementRequest request) throws Exception, ClosedSessionException, SessionManager.SessionNotFound {
-        Session session = sessionManager.get(id);
-        return session.executeStatement(request.getStatement());
-    }
-
-    @Path("/{id}")
-    @DELETE
-    @Timed
-    public Response closeSession(@PathParam("id") String id) throws InterruptedException, TimeoutException, IOException, SessionManager.SessionNotFound {
-        sessionManager.close(id);
-        return Response.noContent().build();
-    }
-}
diff --git a/apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/SparkSession.java b/apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/SparkSession.java
deleted file mode 100644
index 7c8c451..0000000
--- a/apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/SparkSession.java
+++ /dev/null
@@ -1,348 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.cloudera.hue.sparker.server;
-
-import com.fasterxml.jackson.databind.JsonNode;
-import com.fasterxml.jackson.databind.ObjectMapper;
-import com.fasterxml.jackson.databind.node.ObjectNode;
-import com.google.common.collect.Lists;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.io.*;
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * The SparkSession works by spawning off a worker process and communicating with it over a simple IPC json protocol.
- *
- * The request is a json dictionary with the following fields:
- *
- * - id: the cell id.
- * - type: the kind of command.
- * - stdin: the command to execute.
- *
- * The response is a json dictionary with the following fields:
- *
- * - id: the cell this message corresponds to.
- * - state: what state the interpreter is in. One of [ready, incomplete, running, complete]
- * - stdout: the STDOUT lines.
- * - stderr: the STDERR lines.
- *
- * The way it works is that we spawn a worker thread th
- */
-public class SparkSession implements Session {
-
-    private static final Logger LOG = LoggerFactory.getLogger(SparkSession.class);
-
-    private static final String SPARKER_HOME = System.getenv("SPARKER_HOME");
-    private static final String SPARKER_SHELL = SPARKER_HOME + "/sparker-shell";
-
-    private final String id;
-    private final Process process;
-    private final Writer writer;
-    private final BufferedReader reader;
-    private final List<Cell> cells = new ArrayList<Cell>();
-    private final ObjectMapper objectMapper = new ObjectMapper();
-    /*
-    private final StdoutWorkerThread stdoutWorkerThread = new StdoutWorkerThread();
-    private final Queue<JsonNode> requests = new ConcurrentLinkedDeque<JsonNode>();
-    private final Queue<JsonNode> responses = new ConcurrentLinkedDeque<JsonNode>();
-    */
-
-    private boolean isClosed = false;
-
-    protected long lastActivity = Long.MAX_VALUE;
-
-    public SparkSession(final String id) throws IOException, InterruptedException {
-        LOG.info("[" + id + "]: creating spark session");
-
-        touchLastActivity();
-
-        this.id = id;
-
-        ProcessBuilder pb = new ProcessBuilder(Lists.newArrayList(SPARKER_SHELL))
-                .redirectInput(ProcessBuilder.Redirect.PIPE)
-                .redirectOutput(ProcessBuilder.Redirect.PIPE);
-
-        this.process = pb.start();
-
-        writer = new BufferedWriter(new OutputStreamWriter(process.getOutputStream()));
-        reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
-
-        /*
-        stdoutWorkerThread.setDaemon(true);
-        stdoutWorkerThread.start();
-        */
-    }
-
-    @Override
-    public String getId() {
-        return id;
-    }
-
-    @Override
-    public long getLastActivity() {
-        return this.lastActivity;
-    }
-
-    @Override
-    public List<Cell> getCells() {
-        return cells;
-    }
-
-    @Override
-    public Cell executeStatement(String statement) throws IOException, ClosedSessionException, InterruptedException {
-        if (isClosed) {
-            throw new ClosedSessionException();
-        }
-
-        touchLastActivity();
-
-        Cell cell = new Cell();
-        cells.add(cell);
-
-        cell.addInput(statement);
-
-        ObjectNode request = objectMapper.createObjectNode();
-        request.put("type", "stdin");
-        request.put("statement", statement);
-
-        writer.write(request.toString());
-        writer.write("\n");
-        writer.flush();
-
-        String line = reader.readLine();
-
-        if (line == null) {
-            // The process must have shutdown on us!
-            process.waitFor();
-            throw new ClosedSessionException();
-        }
-
-        LOG.info("[" + id + "] spark stdout: " + line);
-
-        JsonNode response = objectMapper.readTree(line);
-
-        if (response.has("stdout")) {
-            cell.addOutput(response.get("stdout").asText());
-        }
-
-        if (response.has("stderr")) {
-            cell.addOutput(response.get("stderr").asText());
-        }
-
-        return cell;
-    }
-
-    @Override
-    public void close() {
-        isClosed = true;
-        process.destroy();
-
-        /*
-        if (process.isAlive()) {
-            process.destroy();
-        }
-        */
-    }
-
-    private void touchLastActivity() {
-        this.lastActivity = System.currentTimeMillis();
-    }
-
-
-    /*
-
-        this.stdoutThread = new Thread(new Runnable() {
-            @Override
-            public void run() {
-                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
-
-                try {
-                    String line;
-
-                    ObjectMapper mapper = new ObjectMapper();
-
-                    while ((line = reader.readLine()) != null) {
-                        LOG.info("[" + id + "] spark stdout: " + line);
-
-                        JsonNode node = mapper.readTree(line);
-
-                        String state = node.get("state").asText();
-
-                        lock.lock();
-                        try {
-                            Cell cell = cells.get(cells.size() - 1);
-
-                            if (state.equals("ready")) {
-                                cell.setState(Cell.State.READY);
-                            } else  if (state.equals("incomplete")) {
-                                cell.setState(Cell.State.INCOMPLETE);
-                            } else if (state.equals("running")) {
-                                cell.setState(Cell.State.RUNNING);
-                            } else if (state.equals("complete")) {
-                                cell.setState(Cell.State.COMPLETE);
-
-                                // Start a new cell.
-                                cells.add(new Cell());
-                            }
-
-                            if (node.has("stdout")) {
-                                cell.addOutput(node.get("stdout").asText());
-                            }
-
-                            if (node.has("stderr")) {
-                                cell.addOutput(node.get("stderr").asText());
-                            }
-
-                        } finally {
-                            lock.unlock();
-                        }
-                    }
-
-                    int exitCode = process.waitFor();
-                    LOG.info("[" + id + "]: process exited with " + exitCode);
-                } catch (IOException e) {
-                    e.printStackTrace();
-                } catch (InterruptedException e) {
-                    e.printStackTrace();
-                }
-            }
-        });
-
-        stdoutThread.start();
-
-        /*
-        this.stderrThread = new Thread(new Runnable() {
-            @Override
-            public void run() {
-                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()));
-
-                try {
-                    String line;
-
-                    ObjectMapper mapper = new ObjectMapper();
-
-                    while ((line = reader.readLine()) != null) {
-                        LOG.info("[" + id + "] stderr: " + line);
-
-
-
-                        ObjectNode node = mapper.createObjectNode();
-                        node.put("type", "stderr");
-                        node.put("msg", line);
-
-                        outputLines.add(node);
-                    }
-
-                    process.waitFor();
-                } catch (IOException e) {
-                    e.printStackTrace();
-                } catch (InterruptedException e) {
-                    e.printStackTrace();
-                }
-            }
-        });
-
-        stderrThread.start();
-        * /
-    }
-
-    @Override
-    public String getKey() {
-        return id;
-    }
-
-    public void execute(String command) throws IOException {
-        LOG.info("[" + id + "]: execute: " + command);
-
-        this.touchLastActivity();
-        if (!command.endsWith("\n")) {
-            command += "\n";
-        }
-
-        inputLines.add(command);
-        process.getOutputStream().write(command.getBytes("UTF-8"));
-        process.getOutputStream().flush();
-    }
-
-    /*
-    @Override
-    public List<String> getInputLines() {
-        this.touchLastActivity();
-        return Lists.newArrayList(inputLines);
-    }
-    * /
-
-    /*
-    @Override
-    public List<JsonNode> getOutputLines() {
-        this.touchLastActivity();
-        return Lists.newArrayList(outputLines);
-    }
-    * /
-
-    public List<Cell> getCells() {
-        lock.lock();
-        try {
-            return Lists.newArrayList(cells);
-        } finally {
-            lock.unlock();
-        }
-    }
-
-    public void close() throws IOException, InterruptedException, TimeoutException {
-        LOG.info("[" + id + "]: closing shell");
-        process.getOutputStream().close();
-
-        stdoutThread.join(1000);
-        //stderrThread.join(1000);
-
-        if (stdoutThread.isAlive()) { // || stderrThread.isAlive()) {
-            stdoutThread.interrupt();
-            //stderrThread.interrupt();
-            process.destroy();
-            throw new TimeoutException();
-        }
-
-        LOG.info("[" + id + "]: shell closed with " + process.exitValue());
-    }
-
-    */
-
-    /*
-    private class StdoutWorkerThread extends Thread {
-        @Override
-        public void run() {
-            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
-            String line;
-
-            try {
-                while ((line = reader.readLine()) != null) {
-                    JsonNode response = objectMapper.readTree(line);
-                    responses.add(response);
-                }
-            } catch (IOException e) {
-                e.printStackTrace();
-            }
-        }
-    }
-    */
-}
diff --git a/apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/SparkerApp.java b/apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/SparkerApp.java
index ff0a73a..d3e5a79 100644
--- a/apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/SparkerApp.java
+++ b/apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/SparkerApp.java
@@ -1,5 +1,7 @@
 package com.cloudera.hue.sparker.server;
 
+import com.cloudera.hue.sparker.server.resources.SessionResource;
+import com.cloudera.hue.sparker.server.sessions.SessionManager;
 import com.sun.jersey.core.spi.factory.ResponseBuilderImpl;
 import io.dropwizard.Application;
 import io.dropwizard.setup.Bootstrap;
diff --git a/apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/resources/SessionResource.java b/apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/resources/SessionResource.java
new file mode 100644
index 0000000..174d578
--- /dev/null
+++ b/apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/resources/SessionResource.java
@@ -0,0 +1,111 @@
+package com.cloudera.hue.sparker.server.resources;
+
+import com.cloudera.hue.sparker.server.sessions.Cell;
+import com.cloudera.hue.sparker.server.sessions.ClosedSessionException;
+import com.cloudera.hue.sparker.server.sessions.Session;
+import com.cloudera.hue.sparker.server.sessions.SessionManager;
+import com.codahale.metrics.annotation.Timed;
+import com.sun.jersey.core.spi.factory.ResponseBuilderImpl;
+import org.hibernate.validator.constraints.NotEmpty;
+
+import javax.validation.Valid;
+import javax.ws.rs.*;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.Response;
+import java.io.IOException;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.TimeoutException;
+
+@Path("/sessions")
+@Produces(MediaType.APPLICATION_JSON)
+public class SessionResource {
+
+    private static final String SCALA = "scala";
+    private static final String PYTHON = "python";
+
+    private final SessionManager sessionManager;
+
+    public SessionResource(SessionManager sessionManager) {
+        this.sessionManager = sessionManager;
+    }
+
+    @GET
+    @Timed
+    public List<String> getSessions() {
+        return Collections.list(sessionManager.getSessionIds());
+    }
+
+    @POST
+    @Timed
+    public String createSession(@QueryParam("lang") String language) throws IOException, InterruptedException {
+        int sessionType;
+
+        if (language == null) {
+            Response resp = new ResponseBuilderImpl().status(400).entity("missing language").build();
+            throw new WebApplicationException(resp);
+        }
+
+        if (language.equals(SCALA)) {
+            sessionType = SessionManager.SCALA;
+        } else if (language.equals(PYTHON)) {
+            sessionType = SessionManager.PYTHON;
+        } else {
+            Response resp = new ResponseBuilderImpl().status(400).entity("invalid language").build();
+            throw new WebApplicationException(resp);
+        }
+
+        Session session = sessionManager.create(sessionType);
+
+        return session.getId();
+    }
+
+    @Path("/{id}")
+    @GET
+    @Timed
+    public List<Cell> getSession(@PathParam("id") String id,
+                                 @QueryParam("from") Integer fromCell,
+                                 @QueryParam("limit") Integer limit) throws SessionManager.SessionNotFound {
+        Session session = sessionManager.get(id);
+        List<Cell> cells = session.getCells();
+
+        if (fromCell != null || limit != null) {
+            if (fromCell == null) {
+                fromCell = 0;
+            }
+
+            if (limit == null) {
+                limit = cells.size();
+            }
+
+            cells = cells.subList(fromCell, fromCell + limit);
+        }
+
+        return cells;
+    }
+
+    @Path("/{id}")
+    @POST
+    @Timed
+    public Cell executeStatement(@PathParam("id") String id, @Valid ExecuteStatementRequest request) throws Exception, ClosedSessionException, SessionManager.SessionNotFound {
+        Session session = sessionManager.get(id);
+        return session.executeStatement(request.getStatement());
+    }
+
+    @Path("/{id}")
+    @DELETE
+    @Timed
+    public Response closeSession(@PathParam("id") String id) throws InterruptedException, TimeoutException, IOException, SessionManager.SessionNotFound {
+        sessionManager.close(id);
+        return Response.noContent().build();
+    }
+
+    private class ExecuteStatementRequest {
+        @NotEmpty
+        private String statement;
+
+        public String getStatement() {
+            return statement;
+        }
+    }
+}
diff --git a/apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/sessions/Cell.java b/apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/sessions/Cell.java
new file mode 100644
index 0000000..0b6f3fa
--- /dev/null
+++ b/apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/sessions/Cell.java
@@ -0,0 +1,63 @@
+package com.cloudera.hue.sparker.server.sessions;
+
+import com.fasterxml.jackson.annotation.JsonProperty;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class Cell {
+
+    public enum State {
+        NOT_READY,
+        READY,
+        INCOMPLETE,
+        RUNNING,
+        COMPLETE,
+    }
+
+    State state;
+    final List<String> input = new ArrayList<String>();
+    final List<String> output = new ArrayList<String>();
+
+    final List<String> error = new ArrayList<String>();
+
+    public Cell() {
+        this.state = State.NOT_READY;
+    }
+
+    @JsonProperty("type")
+    public State getState() {
+        return state;
+    }
+
+    public void setState(State state) {
+        this.state = state;
+    }
+
+    @JsonProperty("input")
+    public List<String> getInput() {
+        return input;
+    }
+
+    public void addInput(String input) {
+        this.input.add(input);
+    }
+
+    @JsonProperty("output")
+    public List<String> getOutput() {
+        return output;
+    }
+
+    public void addOutput(String output) {
+        this.output.add(output);
+    }
+
+    @JsonProperty("error")
+    public List<String> getError() {
+        return error;
+    }
+
+    public void addError(String error) {
+        this.error.add(error);
+    }
+}
diff --git a/apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/sessions/ClosedSessionException.java b/apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/sessions/ClosedSessionException.java
new file mode 100644
index 0000000..961776a
--- /dev/null
+++ b/apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/sessions/ClosedSessionException.java
@@ -0,0 +1,4 @@
+package com.cloudera.hue.sparker.server.sessions;
+
+public class ClosedSessionException extends Throwable {
+}
diff --git a/apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/sessions/Session.java b/apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/sessions/Session.java
new file mode 100644
index 0000000..861a1f6
--- /dev/null
+++ b/apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/sessions/Session.java
@@ -0,0 +1,42 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.cloudera.hue.sparker.server.sessions;
+
+import com.fasterxml.jackson.annotation.JsonProperty;
+
+import java.io.IOException;
+import java.util.List;
+import java.util.concurrent.TimeoutException;
+
+public interface Session {
+
+    @JsonProperty
+    String getId();
+
+    @JsonProperty
+    List<Cell> getCells();
+
+    @JsonProperty
+    public long getLastActivity();
+
+    public Cell executeStatement(String statement) throws Exception, ClosedSessionException;
+
+    public void close() throws IOException, InterruptedException, TimeoutException;
+}
+
diff --git a/apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/sessions/SessionManager.java b/apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/sessions/SessionManager.java
new file mode 100644
index 0000000..2ebca2a
--- /dev/null
+++ b/apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/sessions/SessionManager.java
@@ -0,0 +1,124 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.cloudera.hue.sparker.server.sessions;
+
+import java.io.IOException;
+import java.util.Enumeration;
+import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.TimeoutException;
+
+public class SessionManager {
+
+    public static final int UNKNOWN = 0;
+    public static final int SCALA = 1;
+    public static final int PYTHON = 2;
+
+    private ConcurrentHashMap<String, Session> sessions = new ConcurrentHashMap<String, Session>();
+
+    public SessionManager() {
+        SessionManagerGarbageCollector gc = new SessionManagerGarbageCollector(this);
+        gc.setDaemon(true);
+        gc.start();
+    }
+
+    public Session get(String id) throws SessionNotFound {
+        Session session = sessions.get(id);
+        if (session == null) {
+            throw new SessionNotFound(id);
+        }
+        return session;
+    }
+
+    public Session create(int language) throws IllegalArgumentException, IOException, InterruptedException {
+        String id = UUID.randomUUID().toString();
+        Session session;
+        switch (language) {
+            case SCALA:  session = new SparkSession(id); break;
+            //case PYTHON: session = new PySparkSession(id); break;
+            default: throw new IllegalArgumentException("Invalid language specified for shell session");
+        }
+        sessions.put(id, session);
+        return session;
+    }
+
+    public void close() throws InterruptedException, IOException, TimeoutException {
+        for (Session session : sessions.values()) {
+            sessions.remove(session.getId());
+            session.close();
+        }
+    }
+
+    public void close(String id) throws InterruptedException, TimeoutException, IOException, SessionNotFound {
+        Session session = this.get(id);
+        sessions.remove(id);
+        session.close();
+    }
+
+    public Enumeration<String> getSessionIds() {
+        return sessions.keys();
+    }
+
+    public void garbageCollect() throws InterruptedException, IOException, TimeoutException {
+        long timeout = 60000; // Time in milliseconds; TODO: make configurable
+        for (Session session : sessions.values()) {
+            long now = System.currentTimeMillis();
+            if ((now - session.getLastActivity()) > timeout) {
+                try {
+                    this.close(session.getId());
+                } catch (SessionNotFound sessionNotFound) {
+                    // Ignore
+                }
+            }
+        }
+    }
+
+    protected class SessionManagerGarbageCollector extends Thread {
+
+        protected SessionManager manager;
+
+        protected long period = 60000; // Time in milliseconds; TODO: make configurable
+
+        public SessionManagerGarbageCollector(SessionManager manager) {
+            super();
+            this.manager = manager;
+        }
+
+        public void run() {
+            try {
+                while(true) {
+                    manager.garbageCollect();
+                    sleep(period);
+                }
+            } catch (InterruptedException e) {
+                e.printStackTrace();
+            } catch (TimeoutException e) {
+                e.printStackTrace();
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    public class SessionNotFound extends Throwable {
+        public SessionNotFound(String id) {
+            super(id);
+        }
+    }
+}
diff --git a/apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/sessions/SparkSession.java b/apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/sessions/SparkSession.java
new file mode 100644
index 0000000..4f948cc
--- /dev/null
+++ b/apps/spark/java/sparker-server/src/main/java/com/cloudera/hue/sparker/server/sessions/SparkSession.java
@@ -0,0 +1,348 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.cloudera.hue.sparker.server.sessions;
+
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.node.ObjectNode;
+import com.google.common.collect.Lists;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.*;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * The SparkSession works by spawning off a worker process and communicating with it over a simple IPC json protocol.
+ *
+ * The request is a json dictionary with the following fields:
+ *
+ * - id: the cell id.
+ * - type: the kind of command.
+ * - stdin: the command to execute.
+ *
+ * The response is a json dictionary with the following fields:
+ *
+ * - id: the cell this message corresponds to.
+ * - state: what state the interpreter is in. One of [ready, incomplete, running, complete]
+ * - stdout: the STDOUT lines.
+ * - stderr: the STDERR lines.
+ *
+ * The way it works is that we spawn a worker thread th
+ */
+public class SparkSession implements Session {
+
+    private static final Logger LOG = LoggerFactory.getLogger(SparkSession.class);
+
+    private static final String SPARKER_HOME = System.getenv("SPARKER_HOME");
+    private static final String SPARKER_SHELL = SPARKER_HOME + "/sparker-shell";
+
+    private final String id;
+    private final Process process;
+    private final Writer writer;
+    private final BufferedReader reader;
+    private final List<Cell> cells = new ArrayList<Cell>();
+    private final ObjectMapper objectMapper = new ObjectMapper();
+    /*
+    private final StdoutWorkerThread stdoutWorkerThread = new StdoutWorkerThread();
+    private final Queue<JsonNode> requests = new ConcurrentLinkedDeque<JsonNode>();
+    private final Queue<JsonNode> responses = new ConcurrentLinkedDeque<JsonNode>();
+    */
+
+    private boolean isClosed = false;
+
+    protected long lastActivity = Long.MAX_VALUE;
+
+    public SparkSession(final String id) throws IOException, InterruptedException {
+        LOG.info("[" + id + "]: creating spark session");
+
+        touchLastActivity();
+
+        this.id = id;
+
+        ProcessBuilder pb = new ProcessBuilder(Lists.newArrayList(SPARKER_SHELL))
+                .redirectInput(ProcessBuilder.Redirect.PIPE)
+                .redirectOutput(ProcessBuilder.Redirect.PIPE);
+
+        this.process = pb.start();
+
+        writer = new BufferedWriter(new OutputStreamWriter(process.getOutputStream()));
+        reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
+
+        /*
+        stdoutWorkerThread.setDaemon(true);
+        stdoutWorkerThread.start();
+        */
+    }
+
+    @Override
+    public String getId() {
+        return id;
+    }
+
+    @Override
+    public long getLastActivity() {
+        return this.lastActivity;
+    }
+
+    @Override
+    public List<Cell> getCells() {
+        return cells;
+    }
+
+    @Override
+    public Cell executeStatement(String statement) throws IOException, ClosedSessionException, InterruptedException {
+        if (isClosed) {
+            throw new ClosedSessionException();
+        }
+
+        touchLastActivity();
+
+        Cell cell = new Cell();
+        cells.add(cell);
+
+        cell.addInput(statement);
+
+        ObjectNode request = objectMapper.createObjectNode();
+        request.put("type", "stdin");
+        request.put("statement", statement);
+
+        writer.write(request.toString());
+        writer.write("\n");
+        writer.flush();
+
+        String line = reader.readLine();
+
+        if (line == null) {
+            // The process must have shutdown on us!
+            process.waitFor();
+            throw new ClosedSessionException();
+        }
+
+        LOG.info("[" + id + "] spark stdout: " + line);
+
+        JsonNode response = objectMapper.readTree(line);
+
+        if (response.has("stdout")) {
+            cell.addOutput(response.get("stdout").asText());
+        }
+
+        if (response.has("stderr")) {
+            cell.addOutput(response.get("stderr").asText());
+        }
+
+        return cell;
+    }
+
+    @Override
+    public void close() {
+        isClosed = true;
+        process.destroy();
+
+        /*
+        if (process.isAlive()) {
+            process.destroy();
+        }
+        */
+    }
+
+    private void touchLastActivity() {
+        this.lastActivity = System.currentTimeMillis();
+    }
+
+
+    /*
+
+        this.stdoutThread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
+
+                try {
+                    String line;
+
+                    ObjectMapper mapper = new ObjectMapper();
+
+                    while ((line = reader.readLine()) != null) {
+                        LOG.info("[" + id + "] spark stdout: " + line);
+
+                        JsonNode node = mapper.readTree(line);
+
+                        String state = node.get("state").asText();
+
+                        lock.lock();
+                        try {
+                            Cell cell = cells.get(cells.size() - 1);
+
+                            if (state.equals("ready")) {
+                                cell.setState(Cell.State.READY);
+                            } else  if (state.equals("incomplete")) {
+                                cell.setState(Cell.State.INCOMPLETE);
+                            } else if (state.equals("running")) {
+                                cell.setState(Cell.State.RUNNING);
+                            } else if (state.equals("complete")) {
+                                cell.setState(Cell.State.COMPLETE);
+
+                                // Start a new cell.
+                                cells.add(new Cell());
+                            }
+
+                            if (node.has("stdout")) {
+                                cell.addOutput(node.get("stdout").asText());
+                            }
+
+                            if (node.has("stderr")) {
+                                cell.addOutput(node.get("stderr").asText());
+                            }
+
+                        } finally {
+                            lock.unlock();
+                        }
+                    }
+
+                    int exitCode = process.waitFor();
+                    LOG.info("[" + id + "]: process exited with " + exitCode);
+                } catch (IOException e) {
+                    e.printStackTrace();
+                } catch (InterruptedException e) {
+                    e.printStackTrace();
+                }
+            }
+        });
+
+        stdoutThread.start();
+
+        /*
+        this.stderrThread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()));
+
+                try {
+                    String line;
+
+                    ObjectMapper mapper = new ObjectMapper();
+
+                    while ((line = reader.readLine()) != null) {
+                        LOG.info("[" + id + "] stderr: " + line);
+
+
+
+                        ObjectNode node = mapper.createObjectNode();
+                        node.put("type", "stderr");
+                        node.put("msg", line);
+
+                        outputLines.add(node);
+                    }
+
+                    process.waitFor();
+                } catch (IOException e) {
+                    e.printStackTrace();
+                } catch (InterruptedException e) {
+                    e.printStackTrace();
+                }
+            }
+        });
+
+        stderrThread.start();
+        * /
+    }
+
+    @Override
+    public String getKey() {
+        return id;
+    }
+
+    public void execute(String command) throws IOException {
+        LOG.info("[" + id + "]: execute: " + command);
+
+        this.touchLastActivity();
+        if (!command.endsWith("\n")) {
+            command += "\n";
+        }
+
+        inputLines.add(command);
+        process.getOutputStream().write(command.getBytes("UTF-8"));
+        process.getOutputStream().flush();
+    }
+
+    /*
+    @Override
+    public List<String> getInputLines() {
+        this.touchLastActivity();
+        return Lists.newArrayList(inputLines);
+    }
+    * /
+
+    /*
+    @Override
+    public List<JsonNode> getOutputLines() {
+        this.touchLastActivity();
+        return Lists.newArrayList(outputLines);
+    }
+    * /
+
+    public List<Cell> getCells() {
+        lock.lock();
+        try {
+            return Lists.newArrayList(cells);
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    public void close() throws IOException, InterruptedException, TimeoutException {
+        LOG.info("[" + id + "]: closing shell");
+        process.getOutputStream().close();
+
+        stdoutThread.join(1000);
+        //stderrThread.join(1000);
+
+        if (stdoutThread.isAlive()) { // || stderrThread.isAlive()) {
+            stdoutThread.interrupt();
+            //stderrThread.interrupt();
+            process.destroy();
+            throw new TimeoutException();
+        }
+
+        LOG.info("[" + id + "]: shell closed with " + process.exitValue());
+    }
+
+    */
+
+    /*
+    private class StdoutWorkerThread extends Thread {
+        @Override
+        public void run() {
+            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
+            String line;
+
+            try {
+                while ((line = reader.readLine()) != null) {
+                    JsonNode response = objectMapper.readTree(line);
+                    responses.add(response);
+                }
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+    */
+}
-- 
1.7.9.5

