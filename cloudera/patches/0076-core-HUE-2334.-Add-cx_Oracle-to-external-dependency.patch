From c30fafb4189081d2ebe35f2347e265dd32c0ac84 Mon Sep 17 00:00:00 2001
From: bc Wong <bcwalrus@cloudera.com>
Date: Tue, 16 Sep 2014 12:06:41 -0700
Subject: [PATCH 0076/1173] [core] HUE-2334. Add cx_Oracle to external
 dependency

(cherry picked from commit c6f0ffad2bbfbee9dd11728bdf650eeda34f083c)
---
 desktop/core/ext-py/cx_Oracle-5.1.2/BUILD.txt      |  109 +
 desktop/core/ext-py/cx_Oracle-5.1.2/Buffer.c       |   89 +
 desktop/core/ext-py/cx_Oracle-5.1.2/Callback.c     |  309 +++
 desktop/core/ext-py/cx_Oracle-5.1.2/Connection.c   | 1735 +++++++++++++++
 desktop/core/ext-py/cx_Oracle-5.1.2/Cursor.c       | 2272 ++++++++++++++++++++
 desktop/core/ext-py/cx_Oracle-5.1.2/CursorVar.c    |  172 ++
 desktop/core/ext-py/cx_Oracle-5.1.2/DateTimeVar.c  |  142 ++
 desktop/core/ext-py/cx_Oracle-5.1.2/Environment.c  |  404 ++++
 desktop/core/ext-py/cx_Oracle-5.1.2/Error.c        |  153 ++
 .../core/ext-py/cx_Oracle-5.1.2/ExternalLobVar.c   |  653 ++++++
 .../ext-py/cx_Oracle-5.1.2/ExternalObjectVar.c     |  305 +++
 desktop/core/ext-py/cx_Oracle-5.1.2/HISTORY.txt    |  715 ++++++
 desktop/core/ext-py/cx_Oracle-5.1.2/IntervalVar.c  |  160 ++
 desktop/core/ext-py/cx_Oracle-5.1.2/LICENSE.txt    |   36 +
 desktop/core/ext-py/cx_Oracle-5.1.2/LobVar.c       |  428 ++++
 desktop/core/ext-py/cx_Oracle-5.1.2/LongVar.c      |  237 ++
 desktop/core/ext-py/cx_Oracle-5.1.2/MANIFEST.in    |    7 +
 desktop/core/ext-py/cx_Oracle-5.1.2/NumberVar.c    |  608 ++++++
 desktop/core/ext-py/cx_Oracle-5.1.2/ObjectType.c   |  609 ++++++
 desktop/core/ext-py/cx_Oracle-5.1.2/ObjectVar.c    |  226 ++
 desktop/core/ext-py/cx_Oracle-5.1.2/PKG-INFO       |   22 +
 desktop/core/ext-py/cx_Oracle-5.1.2/README.txt     |   71 +
 desktop/core/ext-py/cx_Oracle-5.1.2/SessionPool.c  |  533 +++++
 desktop/core/ext-py/cx_Oracle-5.1.2/StringVar.c    |  436 ++++
 desktop/core/ext-py/cx_Oracle-5.1.2/Subscription.c |  873 ++++++++
 desktop/core/ext-py/cx_Oracle-5.1.2/TimestampVar.c |  171 ++
 desktop/core/ext-py/cx_Oracle-5.1.2/Transforms.c   |   98 +
 desktop/core/ext-py/cx_Oracle-5.1.2/Variable.c     | 1524 +++++++++++++
 desktop/core/ext-py/cx_Oracle-5.1.2/cx_Oracle.c    |  576 +++++
 .../ext-py/cx_Oracle-5.1.2/html/_static/basic.css  |  540 +++++
 .../html/_static/comment-bright.png                |  Bin 0 -> 3500 bytes
 .../cx_Oracle-5.1.2/html/_static/comment-close.png |  Bin 0 -> 3578 bytes
 .../cx_Oracle-5.1.2/html/_static/comment.png       |  Bin 0 -> 3445 bytes
 .../cx_Oracle-5.1.2/html/_static/default.css       |  256 +++
 .../cx_Oracle-5.1.2/html/_static/doctools.js       |  247 +++
 .../cx_Oracle-5.1.2/html/_static/down-pressed.png  |  Bin 0 -> 368 bytes
 .../ext-py/cx_Oracle-5.1.2/html/_static/down.png   |  Bin 0 -> 363 bytes
 .../ext-py/cx_Oracle-5.1.2/html/_static/file.png   |  Bin 0 -> 392 bytes
 .../ext-py/cx_Oracle-5.1.2/html/_static/jquery.js  |  154 ++
 .../ext-py/cx_Oracle-5.1.2/html/_static/minus.png  |  Bin 0 -> 199 bytes
 .../ext-py/cx_Oracle-5.1.2/html/_static/plus.png   |  Bin 0 -> 199 bytes
 .../cx_Oracle-5.1.2/html/_static/pygments.css      |   62 +
 .../cx_Oracle-5.1.2/html/_static/searchtools.js    |  560 +++++
 .../ext-py/cx_Oracle-5.1.2/html/_static/sidebar.js |  151 ++
 .../cx_Oracle-5.1.2/html/_static/underscore.js     |   23 +
 .../cx_Oracle-5.1.2/html/_static/up-pressed.png    |  Bin 0 -> 372 bytes
 .../ext-py/cx_Oracle-5.1.2/html/_static/up.png     |  Bin 0 -> 363 bytes
 .../cx_Oracle-5.1.2/html/_static/websupport.js     |  808 +++++++
 .../ext-py/cx_Oracle-5.1.2/html/connection.html    |  516 +++++
 .../core/ext-py/cx_Oracle-5.1.2/html/cursor.html   |  533 +++++
 .../core/ext-py/cx_Oracle-5.1.2/html/genindex.html | 1157 ++++++++++
 .../core/ext-py/cx_Oracle-5.1.2/html/index.html    |  162 ++
 .../core/ext-py/cx_Oracle-5.1.2/html/license.html  |  131 ++
 desktop/core/ext-py/cx_Oracle-5.1.2/html/lob.html  |  202 ++
 .../core/ext-py/cx_Oracle-5.1.2/html/module.html   | 1044 +++++++++
 .../core/ext-py/cx_Oracle-5.1.2/html/objects.inv   |  Bin 0 -> 2229 bytes
 .../ext-py/cx_Oracle-5.1.2/html/py-modindex.html   |  115 +
 .../core/ext-py/cx_Oracle-5.1.2/html/search.html   |  106 +
 .../ext-py/cx_Oracle-5.1.2/html/searchindex.js     |    1 +
 .../ext-py/cx_Oracle-5.1.2/html/session_pool.html  |  225 ++
 .../ext-py/cx_Oracle-5.1.2/html/subscription.html  |  276 +++
 .../core/ext-py/cx_Oracle-5.1.2/html/variable.html |  192 ++
 .../samples/DatabaseChangeNotification.py          |   42 +
 .../cx_Oracle-5.1.2/samples/DatabaseShutdown.py    |   24 +
 .../cx_Oracle-5.1.2/samples/DatabaseStartup.py     |   20 +
 .../ext-py/cx_Oracle-5.1.2/samples/ReturnLongs.py  |   41 +
 .../cx_Oracle-5.1.2/samples/ReturnUnicode.py       |   19 +
 .../cx_Oracle-5.1.2/samples/RowsAsInstance.py      |   39 +
 desktop/core/ext-py/cx_Oracle-5.1.2/setup.py       |  351 +++
 .../ext-py/cx_Oracle-5.1.2/test/3kNumberVar.py     |  254 +++
 .../ext-py/cx_Oracle-5.1.2/test/3kStringVar.py     |  286 +++
 .../core/ext-py/cx_Oracle-5.1.2/test/Connection.py |  116 +
 desktop/core/ext-py/cx_Oracle-5.1.2/test/Cursor.py |  253 +++
 .../core/ext-py/cx_Oracle-5.1.2/test/CursorVar.py  |   48 +
 .../ext-py/cx_Oracle-5.1.2/test/DateTimeVar.py     |  228 ++
 .../ext-py/cx_Oracle-5.1.2/test/IntervalVar.py     |  121 ++
 desktop/core/ext-py/cx_Oracle-5.1.2/test/LobVar.py |  156 ++
 .../core/ext-py/cx_Oracle-5.1.2/test/LongVar.py    |  101 +
 .../core/ext-py/cx_Oracle-5.1.2/test/NumberVar.py  |  271 +++
 .../core/ext-py/cx_Oracle-5.1.2/test/ObjectVar.py  |   53 +
 .../ext-py/cx_Oracle-5.1.2/test/SessionPool.py     |  117 +
 .../core/ext-py/cx_Oracle-5.1.2/test/SetupTest.sql |  560 +++++
 .../core/ext-py/cx_Oracle-5.1.2/test/StringVar.py  |  286 +++
 .../core/ext-py/cx_Oracle-5.1.2/test/TestEnv.py    |   20 +
 .../ext-py/cx_Oracle-5.1.2/test/TimestampVar.py    |  130 ++
 .../core/ext-py/cx_Oracle-5.1.2/test/UnicodeVar.py |  237 ++
 desktop/core/ext-py/cx_Oracle-5.1.2/test/test.py   |   87 +
 desktop/core/ext-py/cx_Oracle-5.1.2/test/test3k.py |   75 +
 .../ext-py/cx_Oracle-5.1.2/test/test_dbapi20.py    |   39 +
 .../ext-py/cx_Oracle-5.1.2/test/uConnection.py     |  116 +
 .../core/ext-py/cx_Oracle-5.1.2/test/uCursor.py    |  226 ++
 .../core/ext-py/cx_Oracle-5.1.2/test/uCursorVar.py |   48 +
 .../ext-py/cx_Oracle-5.1.2/test/uDateTimeVar.py    |  228 ++
 .../ext-py/cx_Oracle-5.1.2/test/uIntervalVar.py    |  121 ++
 .../core/ext-py/cx_Oracle-5.1.2/test/uLobVar.py    |  152 ++
 .../core/ext-py/cx_Oracle-5.1.2/test/uLongVar.py   |   88 +
 .../core/ext-py/cx_Oracle-5.1.2/test/uNumberVar.py |  271 +++
 .../core/ext-py/cx_Oracle-5.1.2/test/uObjectVar.py |   53 +
 .../ext-py/cx_Oracle-5.1.2/test/uSessionPool.py    |   98 +
 .../core/ext-py/cx_Oracle-5.1.2/test/uStringVar.py |  266 +++
 .../ext-py/cx_Oracle-5.1.2/test/uTimestampVar.py   |  130 ++
 ext/thirdparty/README.md                           |    1 +
 102 files changed, 26906 insertions(+)
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/BUILD.txt
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/Buffer.c
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/Callback.c
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/Connection.c
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/Cursor.c
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/CursorVar.c
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/DateTimeVar.c
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/Environment.c
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/Error.c
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/ExternalLobVar.c
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/ExternalObjectVar.c
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/HISTORY.txt
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/IntervalVar.c
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/LICENSE.txt
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/LobVar.c
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/LongVar.c
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/MANIFEST.in
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/NumberVar.c
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/ObjectType.c
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/ObjectVar.c
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/PKG-INFO
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/README.txt
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/SessionPool.c
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/StringVar.c
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/Subscription.c
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/TimestampVar.c
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/Transforms.c
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/Variable.c
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/cx_Oracle.c
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/basic.css
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/comment-bright.png
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/comment-close.png
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/comment.png
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/default.css
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/doctools.js
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/down-pressed.png
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/down.png
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/file.png
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/jquery.js
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/minus.png
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/plus.png
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/pygments.css
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/searchtools.js
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/sidebar.js
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/underscore.js
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/up-pressed.png
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/up.png
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/websupport.js
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/html/connection.html
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/html/cursor.html
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/html/genindex.html
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/html/index.html
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/html/license.html
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/html/lob.html
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/html/module.html
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/html/objects.inv
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/html/py-modindex.html
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/html/search.html
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/html/searchindex.js
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/html/session_pool.html
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/html/subscription.html
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/html/variable.html
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/samples/DatabaseChangeNotification.py
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/samples/DatabaseShutdown.py
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/samples/DatabaseStartup.py
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/samples/ReturnLongs.py
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/samples/ReturnUnicode.py
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/samples/RowsAsInstance.py
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/setup.py
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/test/3kNumberVar.py
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/test/3kStringVar.py
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/test/Connection.py
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/test/Cursor.py
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/test/CursorVar.py
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/test/DateTimeVar.py
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/test/IntervalVar.py
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/test/LobVar.py
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/test/LongVar.py
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/test/NumberVar.py
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/test/ObjectVar.py
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/test/SessionPool.py
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/test/SetupTest.sql
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/test/StringVar.py
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/test/TestEnv.py
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/test/TimestampVar.py
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/test/UnicodeVar.py
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/test/test.py
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/test/test3k.py
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/test/test_dbapi20.py
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/test/uConnection.py
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/test/uCursor.py
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/test/uCursorVar.py
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/test/uDateTimeVar.py
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/test/uIntervalVar.py
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/test/uLobVar.py
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/test/uLongVar.py
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/test/uNumberVar.py
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/test/uObjectVar.py
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/test/uSessionPool.py
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/test/uStringVar.py
 create mode 100644 desktop/core/ext-py/cx_Oracle-5.1.2/test/uTimestampVar.py

diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/BUILD.txt b/desktop/core/ext-py/cx_Oracle-5.1.2/BUILD.txt
new file mode 100644
index 0000000..cf7c6a3
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/BUILD.txt
@@ -0,0 +1,109 @@
+Linux Build Hints
+-----------------
+(Tested on RedHat 4.x, Gentoo 2008.0, Ubuntu 8.x, and Debian 4.x)
+These hints are based on using Oracle's instantclient_11_1.  It is necessary
+to download both 'instantclient-linux-basic' and 'instantclient-sdk-linux' from
+oracle.com in order to successfully compile.  
+
+http://www.oracle.com/technology/software/tech/oci/instantclient/index.html
+
+Each compressed tarball needs to be extracted to the exact same location.
+Uncompress and untar each file from the same location in order to achieve this
+result. If placing into a system area such as /opt or /usr/local, make sure to
+have the correct permissions for writing to these filesystems and/or
+directories. It is advisable to use the same account from start to finish while
+installing cx_Oracle in order not to clobber the pre-set environment variables
+set below.
+
+It is necessary to set environment variables ORACLE_HOME and LD_LIBRARY_PATH
+inside $HOME/.profile in order for cx_Oracle to import properly after
+installation and in order to build correctly. Using a text editor add the
+settings below to $HOME/.profile making sure to change the location of your 
+actual installation path.
+
+   Example ($HOME/.profile):
+   -------------------------
+   export ORACLE_HOME=[your installation path]/instantclient_11_1
+   export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ORACLE_HOME
+
+To put these variables into the working shell env, either source .profile
+(. $HOME/.profile) or execute each export statement above from a shell
+individually to set these variables. If these are not added to $HOME/.profile
+they will need to be manually set each time cx_Oracle is loaded into Python.
+
+After both packages are untarred to there installation location a link needs
+to be made inside the instantclient_11_1 directory. If you are using a
+different version of the instant client simply adjust the link per the version
+of libclntsh.so.
+
+   Steps:
+   ------
+   cd $ORACLE_HOME
+   ln -s libclntsh.so.x.x libclntsh.so
+
+Continue to step: Building and Compilation.
+
+
+OS X Build Hints
+----------------
+(Tested on Leopard 10.5.x)
+The procedures for OS X are almost idential to Linux except for the package
+names and a few environmental caveats. For OS X it is necessary to download
+both 'instantclient-basic-macosx' and 'instantclient-sdk-macosx'. Download and
+extract each file per the build hints for Linux.
+
+For OS X it is necessary to set environment variables ORACLE_HOME,
+LD_LIBRARY_PATH and DYLD_LIBRARY_PATH inside $HOME/.profile and start a new
+shell before testing cx_Oracle. If .profile does not exist, simply create one
+with a text editor and add the necessary path info to these variables.
+
+   Example ($HOME/.profile):
+   -------------------------
+   export ORACLE_HOME=[your installation path]/instantclient_11_1
+   export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ORACLE_HOME
+   export DYLD_LIBRARY_PATH=$ORACLE_HOME
+
+The variables placed inside $HOME/.profile need to be set prior to building.
+Therefore, source .profile (. $HOME/.profile) or execute each export statement
+above from a shell individually to set these variables.  Not having
+DYLD_LIBRARY_PATH set inside $HOME/.profile prior to building will cause a
+compilation error regardless of being set in the current shell's env.
+
+After both packages are untarred a link needs to be made inside the
+instantclient_11_1 directory.  If you are using a different version of the
+instant client simply adjust the link per the version of libclntsh.dylib.
+
+   Steps:
+   ------
+   cd $ORACLE_HOME
+   ln -s libclntsh.dylib.x.x libclntsh.dylib
+
+Continue to step: Building and Compilation.
+
+
+Building and Compilation
+------------------------
+Use the provided setup.py to build and install the module which makes use of 
+the distutils module. Note that on Windows, I have used mingw32 
+(http://www.mingw.org) and the module will not build with MSVC without 
+modification. The commands required to build and install the module are as 
+follows:
+
+	python setup.py build
+	python setup.py install
+
+
+Testing (Post Installation Quick Test)
+--------------------------------------
+A very quick installation test can be performed from the command line using
+the Python interpreter. Below is an example of how this done. After importing
+cx_Oracle there should be a line containing only '>>>' which indicates the
+library successfully loaded.
+
+    $ python
+    Python 2.5.2 (r252:60911, Oct 25 2008, 19:37:28)
+    [GCC 4.1.2 (Gentoo 4.1.2 p1.1)] on linux2
+    Type "help", "copyright", "credits" or "license" for more information.
+    >>> import cx_Oracle
+    >>>
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/Buffer.c b/desktop/core/ext-py/cx_Oracle-5.1.2/Buffer.c
new file mode 100644
index 0000000..7d68109
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/Buffer.c
@@ -0,0 +1,89 @@
+//-----------------------------------------------------------------------------
+// Buffer.c
+//   Defines buffer structure and routines for populating it. These are used
+// to translate Python objects into the buffers needed for Oracle, including
+// Unicode or buffer objects.
+//-----------------------------------------------------------------------------
+
+// define structure for abstracting string buffers
+typedef struct {
+    const void *ptr;
+    Py_ssize_t numCharacters;
+    Py_ssize_t size;
+    PyObject *obj;
+} udt_Buffer;
+
+
+//-----------------------------------------------------------------------------
+// cxBuffer_Init()
+//   Initialize the buffer with an empty string. Returns 0 as a convenience to
+// the caller.
+//-----------------------------------------------------------------------------
+static int cxBuffer_Init(
+    udt_Buffer *buf)                    // buffer to initialize
+{
+    buf->ptr = NULL;
+    buf->size = 0;
+    buf->numCharacters = 0;
+    buf->obj = NULL;
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// cxBuffer_Copy()
+//   Copy the contents of the buffer.
+//-----------------------------------------------------------------------------
+static int cxBuffer_Copy(
+    udt_Buffer *buf,                    // buffer to copy into
+    udt_Buffer *copyFromBuf)            // buffer to copy from
+{
+    buf->ptr = copyFromBuf->ptr;
+    buf->size = copyFromBuf->size;
+    buf->numCharacters = copyFromBuf->numCharacters;
+    Py_XINCREF(copyFromBuf->obj);
+    buf->obj = copyFromBuf->obj;
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// cxBuffer_FromObject()
+//   Populate the string buffer from a unicode object.
+//-----------------------------------------------------------------------------
+static int cxBuffer_FromObject(
+    udt_Buffer *buf,                    // buffer to fill
+    PyObject *obj,                      // object (string or Unicode object)
+    const char *encoding)               // encoding to use, if applicable
+{
+    if (!obj)
+        return cxBuffer_Init(buf);
+    if (encoding && PyUnicode_Check(obj)) {
+        buf->obj = PyUnicode_AsEncodedString(obj, encoding, NULL);
+        if (!buf->obj)
+            return -1;
+        buf->ptr = PyBytes_AS_STRING(buf->obj);
+        buf->size = PyBytes_GET_SIZE(buf->obj);
+        buf->numCharacters = PyUnicode_GET_SIZE(obj);
+    } else if (PyBytes_Check(obj)) {
+        Py_INCREF(obj);
+        buf->obj = obj;
+        buf->ptr = PyBytes_AS_STRING(buf->obj);
+        buf->size = buf->numCharacters = PyBytes_GET_SIZE(buf->obj);
+#if PY_MAJOR_VERSION < 3
+    } else if (PyBuffer_Check(obj)) {
+        if (PyObject_AsReadBuffer(obj, &buf->ptr, &buf->size) < 0)
+            return -1;
+        Py_INCREF(obj);
+        buf->obj = obj;
+        buf->numCharacters = buf->size;
+#endif
+    } else {
+        PyErr_SetString(PyExc_TypeError, CXORA_TYPE_ERROR);
+        return -1;
+    }
+    return 0;
+}
+
+#define cxBuffer_Clear(buf)             Py_XDECREF((buf)->obj)
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/Callback.c b/desktop/core/ext-py/cx_Oracle-5.1.2/Callback.c
new file mode 100644
index 0000000..aa6be1a
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/Callback.c
@@ -0,0 +1,309 @@
+//-----------------------------------------------------------------------------
+// Callback.c
+//   Definition of OCI callback functions.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// Callback_NewVariable()
+//   Return a new variable from a callback.
+//-----------------------------------------------------------------------------
+static udt_Variable *Callback_NewVariable(
+    udt_Connection *connection,         // connection to use
+    ub2 oracleType,                     // Oracle type of data
+    ub4 bufferSize,                     // maximum length of elements
+    void *data,                         // data pointer
+    void *indicator,                    // indicator pointer
+    ub2 *returnCode,                    // return code pointer
+    ub2 *actualLength)                  // actual length pointer
+{
+    udt_VariableType *type;
+    udt_Variable *var;
+
+    // determine the type to use
+    type = Variable_TypeByOracleDataType(oracleType, SQLCS_IMPLICIT);
+    if (!type)
+        return NULL;
+
+    // attempt to allocate the object
+    var = (udt_Variable*) type->pythonType->tp_alloc(type->pythonType, 0);
+    if (!var)
+        return NULL;
+
+    // perform basic initialization
+    // note that the number of allocated elements is set arbitrarily high
+    // because the OCI doesn't give information about how many elements are
+    // actually allocated; that has to be implied by the number of rows
+    // passed to OCIStmtFetch and OCIStmtExecute
+    Py_INCREF(connection->environment);
+    var->environment = connection->environment;
+    var->boundCursorHandle = NULL;
+    var->bindHandle = NULL;
+    var->defineHandle = NULL;
+    var->boundName = NULL;
+    var->allocatedElements = 2147483647;
+    var->actualElements = 0;
+    var->isArray = 0;
+    var->isAllocatedInternally = 0;
+    var->type = type;
+    var->indicator = indicator;
+    var->data = data;
+    var->actualLength = actualLength;
+    var->returnCode = returnCode;
+    var->size = type->size;
+    var->bufferSize = type->size;
+    if (type->isVariableLength)
+        var->bufferSize = bufferSize;
+
+    return var;
+}
+
+
+//-----------------------------------------------------------------------------
+// Callback_BindByNameArgs()
+//   Return the arguments to be passed when OCIBindByName is called.
+//-----------------------------------------------------------------------------
+static PyObject *Callback_BindByNameArgs(
+    udt_Connection *connection,         // connection to use
+    va_list args)                       // arguments to OCI function
+{
+    ub4 nameLength, allocatedElements, *actualElements;
+    ub2 dataType, *actualLength, *returnCode;
+    dvoid *indicator, *value;
+    OCIBind **bindHandlePtr;
+    OCIError *errorHandle;
+    udt_Variable *var;
+    PyObject *result;
+    sb4 valueLength;
+    OCIStmt *handle;
+    text *name;
+
+    handle = va_arg(args, OCIStmt*);
+    bindHandlePtr = va_arg(args, OCIBind**);
+    errorHandle = va_arg(args, OCIError*);
+    name = va_arg(args, text*);
+    nameLength = va_arg(args, ub4);
+    value = va_arg(args, dvoid*);
+    valueLength = va_arg(args, sb4);
+    dataType = va_arg(args, int);
+    indicator = va_arg(args, dvoid*);
+    actualLength = va_arg(args, ub2*);
+    returnCode = va_arg(args, ub2*);
+    allocatedElements = va_arg(args, ub4);
+    actualElements = va_arg(args, ub4*);
+
+    var = Callback_NewVariable(connection, dataType, valueLength, value,
+            indicator, returnCode, actualLength);
+    if (!var)
+        return NULL;
+    if (allocatedElements > 0) {
+        var->isArray = 1;
+        var->actualElements = *actualElements;
+    }
+
+    result = Py_BuildValue("ls#O", handle, name, nameLength, var);
+    Py_DECREF(var);
+    return result;
+}
+
+
+//-----------------------------------------------------------------------------
+// Callback_DefineByPosArgs()
+//   Return the arguments to be passed when OCIDefineByPos is called.
+//-----------------------------------------------------------------------------
+static PyObject *Callback_DefineByPosArgs(
+    udt_Connection *connection,         // connection to use
+    va_list args)                       // arguments to OCI function
+{
+    ub2 dataType, *actualLength, *returnCode;
+    OCIDefine **defineHandle;
+    dvoid *indicator, *value;
+    OCIError *errorHandle;
+    udt_Variable *var;
+    PyObject *result;
+    OCIStmt *handle;
+    sb4 valueLength;
+    ub4 position;
+
+    handle = va_arg(args, OCIStmt*);
+    defineHandle = va_arg(args, OCIDefine**);
+    errorHandle = va_arg(args, OCIError*);
+    position = va_arg(args, ub4);
+    value = va_arg(args, dvoid*);
+    valueLength = va_arg(args, sb4);
+    dataType = va_arg(args, int);
+    indicator = va_arg(args, dvoid*);
+    actualLength = va_arg(args, ub2*);
+    returnCode = va_arg(args, ub2*);
+
+    // create a variable
+    var = Callback_NewVariable(connection, dataType, valueLength, value,
+            indicator, returnCode, actualLength);
+    if (!var)
+        return NULL;
+
+    result = Py_BuildValue("liO", handle, position, var);
+    Py_DECREF(var);
+    return result;
+}
+
+
+//-----------------------------------------------------------------------------
+// Callback_ExecuteArgs()
+//   Return the arguments to be passed when OCIStmtExecute is called.
+//-----------------------------------------------------------------------------
+static PyObject *Callback_ExecuteArgs(
+    va_list args)                       // arguments to OCI function
+{
+    OCISvcCtx* serviceContextHandle;
+    OCIError *errorHandle;
+    ub4 iters, rowoff;
+    OCIStmt *handle;
+
+    serviceContextHandle = va_arg(args, OCISvcCtx*);
+    handle = va_arg(args, OCIStmt*);
+    errorHandle = va_arg(args, OCIError*);
+    iters = va_arg(args, ub4);
+    rowoff = va_arg(args, ub4);
+
+    return Py_BuildValue("lii", handle, iters, rowoff);
+}
+
+
+//-----------------------------------------------------------------------------
+// Callback_FetchArgs()
+//   Return the arguments to be passed when OCIStmtFetch is called.
+//-----------------------------------------------------------------------------
+static PyObject *Callback_FetchArgs(
+    udt_Connection *connection,         // connection to use
+    va_list args)                       // arguments to OCI function
+{
+    ub4 numRows, rowCount;
+    OCIError *errorHandle;
+    OCIStmt *handle;
+    sword status;
+
+    handle = va_arg(args, OCIStmt*);
+    errorHandle = va_arg(args, OCIError*);
+    numRows = va_arg(args, ub4);
+
+    status = OCIAttrGet(handle, OCI_HTYPE_STMT, &rowCount, 0,
+            OCI_ATTR_ROW_COUNT, connection->environment->errorHandle);
+    if (Environment_CheckForError(connection->environment, status,
+            "Callback_FetchArgs()") < 0)
+        return NULL;
+
+    return Py_BuildValue("lii", handle, numRows, rowCount);
+}
+
+
+//-----------------------------------------------------------------------------
+// Callback_PrepareArgs()
+//   Return the arguments to be passed when OCIStmtPrepare is called.
+//-----------------------------------------------------------------------------
+static PyObject *Callback_PrepareArgs(
+    va_list args)                       // arguments to OCI function
+{
+    OCIError *errorHandle;
+    ub4 statementLength;
+    OCIStmt *handle;
+    text *statement;
+
+    handle = va_arg(args, OCIStmt*);
+    errorHandle = va_arg(args, OCIError*);
+    statement = va_arg(args, text *);
+    statementLength = va_arg(args, ub4);
+
+    return Py_BuildValue("ls#", handle, statement, statementLength);
+}
+
+
+//-----------------------------------------------------------------------------
+// Callback_GetArgs()
+//   Return the arguments to be passed to the Python callback method.
+//-----------------------------------------------------------------------------
+static PyObject *Callback_GetArgs(
+    udt_Connection *connection,         // connection to use
+    ub4 functionCode,                   // function code
+    va_list args)                       // OCI function arguments
+{
+    switch (functionCode) {
+        case OCI_FNCODE_BINDBYNAME:
+            return Callback_BindByNameArgs(connection, args);
+        case OCI_FNCODE_DEFINEBYPOS:
+            return Callback_DefineByPosArgs(connection, args);
+        case OCI_FNCODE_STMTEXECUTE:
+            return Callback_ExecuteArgs(args);
+        case OCI_FNCODE_STMTFETCH:
+            return Callback_FetchArgs(connection, args);
+        case OCI_FNCODE_STMTPREPARE:
+            return Callback_PrepareArgs(args);
+    }
+
+    return PyTuple_New(0);
+}
+
+
+//-----------------------------------------------------------------------------
+// Callback_Call()
+//   Actually make the call to the Python function.
+//-----------------------------------------------------------------------------
+static sword Callback_Call(
+    PyObject *tuple,                    // tuple containing connection/callback
+    ub4 functionCode,                   // function code
+    va_list args)                       // arguments
+{
+    PyObject *callback, *callbackArgs, *result;
+    udt_Connection *connection;
+
+    // determine the connection and callback
+    connection = (udt_Connection*) PyTuple_GET_ITEM(tuple, 0);
+    callback = PyTuple_GET_ITEM(tuple, 1);
+
+    // determine the arguments to pass to the function
+    callbackArgs = Callback_GetArgs(connection, functionCode, args);
+    if (!callbackArgs)
+        return OCI_ERROR;
+
+    // actually make the call to the method
+    result = PyEval_CallObject(callback, callbackArgs);
+    Py_DECREF(callbackArgs);
+    if (!result)
+        return OCI_ERROR;
+
+    Py_DECREF(result);
+    return OCI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// Callback_Handler()
+//   Callback handler for calling Python code within an OCI callback.
+//-----------------------------------------------------------------------------
+static sword Callback_Handler(
+    PyObject *tuple,                    // tuple containing connection/callback
+    dvoid *handle,                      // pointer to handle
+    ub4 handleType,                     // handle type
+    ub4 functionCode,                   // function code
+    ub1 when,                           // when being called
+    sword returnCode,                   // return code
+    ub4 *errorCode,                     // error code (IN/OUT)
+    va_list args)                       // arguments
+{
+#ifdef WITH_THREAD
+    PyGILState_STATE gstate = PyGILState_Ensure();
+#endif
+    sword result;
+
+    // perform the call
+    result = Callback_Call(tuple, functionCode, args);
+    if (result != OCI_CONTINUE)
+        PyErr_Print();
+
+    // restore thread state, if necessary
+#ifdef WITH_THREAD
+    PyGILState_Release(gstate);
+#endif
+
+    return result;
+}
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/Connection.c b/desktop/core/ext-py/cx_Oracle-5.1.2/Connection.c
new file mode 100644
index 0000000..407d9c3
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/Connection.c
@@ -0,0 +1,1735 @@
+//-----------------------------------------------------------------------------
+// Connection.c
+//   Definition of the Python type OracleConnection.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// structure for the Python type "Connection"
+//-----------------------------------------------------------------------------
+typedef struct {
+    PyObject_HEAD
+    OCISvcCtx *handle;
+    OCIServer *serverHandle;
+    OCISession *sessionHandle;
+    udt_Environment *environment;
+    udt_SessionPool *sessionPool;
+    PyObject *inputTypeHandler;
+    PyObject *outputTypeHandler;
+    PyObject *username;
+    PyObject *password;
+    PyObject *dsn;
+    PyObject *version;
+    ub4 commitMode;
+    int autocommit;
+    int release;
+    int attached;
+} udt_Connection;
+
+
+//-----------------------------------------------------------------------------
+// constants for the OCI attributes
+//-----------------------------------------------------------------------------
+static ub4 gc_ClientIdentifierAttribute = OCI_ATTR_CLIENT_IDENTIFIER;
+#ifdef ORACLE_10G
+static ub4 gc_ModuleAttribute = OCI_ATTR_MODULE;
+static ub4 gc_ActionAttribute = OCI_ATTR_ACTION;
+static ub4 gc_ClientInfoAttribute = OCI_ATTR_CLIENT_INFO;
+#endif
+
+#ifdef ORACLE_10GR2
+static ub4 gc_CurrentSchemaAttribute = OCI_ATTR_CURRENT_SCHEMA;
+#endif
+
+
+//-----------------------------------------------------------------------------
+// functions for the Python type "Connection"
+//-----------------------------------------------------------------------------
+static void Connection_Free(udt_Connection*);
+static PyObject *Connection_New(PyTypeObject*, PyObject*, PyObject*);
+static int Connection_Init(udt_Connection*, PyObject*, PyObject*);
+static PyObject *Connection_Repr(udt_Connection*);
+static PyObject *Connection_Close(udt_Connection*, PyObject*);
+static PyObject *Connection_Commit(udt_Connection*, PyObject*);
+static PyObject *Connection_Begin(udt_Connection*, PyObject*);
+static PyObject *Connection_Prepare(udt_Connection*, PyObject*);
+static PyObject *Connection_Rollback(udt_Connection*, PyObject*);
+static PyObject *Connection_NewCursor(udt_Connection*, PyObject*);
+static PyObject *Connection_Cancel(udt_Connection*, PyObject*);
+static PyObject *Connection_RegisterCallback(udt_Connection*, PyObject*);
+static PyObject *Connection_UnregisterCallback(udt_Connection*, PyObject*);
+static PyObject *Connection_GetVersion(udt_Connection*, void*);
+static PyObject *Connection_GetEncoding(udt_Connection*, void*);
+static PyObject *Connection_GetNationalEncoding(udt_Connection*, void*);
+static PyObject *Connection_GetMaxBytesPerCharacter(udt_Connection*, void*);
+static PyObject *Connection_ContextManagerEnter(udt_Connection*, PyObject*);
+static PyObject *Connection_ContextManagerExit(udt_Connection*, PyObject*);
+static PyObject *Connection_ChangePasswordExternal(udt_Connection*, PyObject*);
+static PyObject *Connection_GetStmtCacheSize(udt_Connection*, void*);
+static int Connection_SetStmtCacheSize(udt_Connection*, PyObject*, void*);
+#ifdef ORACLE_10G
+static PyObject *Connection_GetOCIAttr(udt_Connection*, ub4*);
+#endif
+static int Connection_SetOCIAttr(udt_Connection*, PyObject*, ub4*);
+#ifdef ORACLE_10GR2
+#if !defined(AIX5) || defined(ORACLE_11g)
+static PyObject *Connection_Ping(udt_Connection*, PyObject*);
+#endif
+static PyObject *Connection_Shutdown(udt_Connection*, PyObject*, PyObject*);
+static PyObject *Connection_Startup(udt_Connection*, PyObject*, PyObject*);
+static PyObject *Connection_Subscribe(udt_Connection*, PyObject*, PyObject*);
+#endif
+
+
+//-----------------------------------------------------------------------------
+// declaration of methods for Python type "Connection"
+//-----------------------------------------------------------------------------
+static PyMethodDef g_ConnectionMethods[] = {
+    { "cursor", (PyCFunction) Connection_NewCursor, METH_NOARGS },
+    { "commit", (PyCFunction) Connection_Commit, METH_NOARGS },
+    { "rollback", (PyCFunction) Connection_Rollback, METH_NOARGS },
+    { "begin", (PyCFunction) Connection_Begin, METH_VARARGS },
+    { "prepare", (PyCFunction) Connection_Prepare, METH_NOARGS },
+    { "close", (PyCFunction) Connection_Close, METH_NOARGS },
+    { "cancel", (PyCFunction) Connection_Cancel, METH_NOARGS },
+    { "register", (PyCFunction) Connection_RegisterCallback, METH_VARARGS },
+    { "unregister", (PyCFunction) Connection_UnregisterCallback, METH_VARARGS },
+    { "__enter__", (PyCFunction) Connection_ContextManagerEnter, METH_NOARGS },
+    { "__exit__", (PyCFunction) Connection_ContextManagerExit, METH_VARARGS },
+#ifdef ORACLE_10GR2
+#if !defined(AIX5) || defined(ORACLE_11g)
+    { "ping", (PyCFunction) Connection_Ping, METH_NOARGS },
+#endif
+    { "shutdown", (PyCFunction) Connection_Shutdown,
+            METH_VARARGS | METH_KEYWORDS},
+    { "startup", (PyCFunction) Connection_Startup,
+            METH_VARARGS | METH_KEYWORDS},
+    { "subscribe", (PyCFunction) Connection_Subscribe,
+            METH_VARARGS | METH_KEYWORDS},
+#endif
+    { "changepassword", (PyCFunction) Connection_ChangePasswordExternal,
+            METH_VARARGS },
+    { NULL }
+};
+
+
+//-----------------------------------------------------------------------------
+// declaration of members for Python type "Connection"
+//-----------------------------------------------------------------------------
+static PyMemberDef g_ConnectionMembers[] = {
+    { "username", T_OBJECT, offsetof(udt_Connection, username), READONLY },
+    { "password", T_OBJECT, offsetof(udt_Connection, password), 0 },
+    { "dsn", T_OBJECT, offsetof(udt_Connection, dsn), READONLY },
+    { "tnsentry", T_OBJECT, offsetof(udt_Connection, dsn), READONLY },
+    { "autocommit", T_INT, offsetof(udt_Connection, autocommit), 0 },
+    { "inputtypehandler", T_OBJECT,
+            offsetof(udt_Connection, inputTypeHandler), 0 },
+    { "outputtypehandler", T_OBJECT,
+            offsetof(udt_Connection, outputTypeHandler), 0 },
+    { NULL }
+};
+
+
+//-----------------------------------------------------------------------------
+// declaration of calculated members for Python type "Connection"
+//-----------------------------------------------------------------------------
+static PyGetSetDef g_ConnectionCalcMembers[] = {
+    { "version", (getter) Connection_GetVersion, 0, 0, 0 },
+    { "encoding", (getter) Connection_GetEncoding, 0, 0, 0 },
+    { "nencoding", (getter) Connection_GetNationalEncoding, 0, 0, 0 },
+    { "maxBytesPerCharacter", (getter) Connection_GetMaxBytesPerCharacter,
+            0, 0, 0 },
+    { "stmtcachesize", (getter) Connection_GetStmtCacheSize,
+            (setter) Connection_SetStmtCacheSize, 0, 0 },
+#ifdef ORACLE_10G
+    { "module", 0, (setter) Connection_SetOCIAttr, 0, &gc_ModuleAttribute },
+    { "action", 0, (setter) Connection_SetOCIAttr, 0, &gc_ActionAttribute },
+    { "clientinfo", 0, (setter) Connection_SetOCIAttr, 0,
+            &gc_ClientInfoAttribute },
+#endif
+    { "client_identifier", 0, (setter) Connection_SetOCIAttr, 0,
+            &gc_ClientIdentifierAttribute },
+#ifdef ORACLE_10GR2
+    { "current_schema", (getter) Connection_GetOCIAttr,
+            (setter) Connection_SetOCIAttr, 0, &gc_CurrentSchemaAttribute },
+#endif
+    { NULL }
+};
+
+
+//-----------------------------------------------------------------------------
+// declaration of Python type "Connection"
+//-----------------------------------------------------------------------------
+static PyTypeObject g_ConnectionType = {
+    PyVarObject_HEAD_INIT(NULL, 0)
+    "cx_Oracle.Connection",             // tp_name
+    sizeof(udt_Connection),             // tp_basicsize
+    0,                                  // tp_itemsize
+    (destructor) Connection_Free,       // tp_dealloc
+    0,                                  // tp_print
+    0,                                  // tp_getattr
+    0,                                  // tp_setattr
+    0,                                  // tp_compare
+    (reprfunc) Connection_Repr,         // tp_repr
+    0,                                  // tp_as_number
+    0,                                  // tp_as_sequence
+    0,                                  // tp_as_mapping
+    0,                                  // tp_hash
+    0,                                  // tp_call
+    0,                                  // tp_str
+    0,                                  // tp_getattro
+    0,                                  // tp_setattro
+    0,                                  // tp_as_buffer
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
+                                        // tp_flags
+    0,                                  // tp_doc
+    0,                                  // tp_traverse
+    0,                                  // tp_clear
+    0,                                  // tp_richcompare
+    0,                                  // tp_weaklistoffset
+    0,                                  // tp_iter
+    0,                                  // tp_iternext
+    g_ConnectionMethods,                // tp_methods
+    g_ConnectionMembers,                // tp_members
+    g_ConnectionCalcMembers,            // tp_getset
+    0,                                  // tp_base
+    0,                                  // tp_dict
+    0,                                  // tp_descr_get
+    0,                                  // tp_descr_set
+    0,                                  // tp_dictoffset
+    (initproc) Connection_Init,         // tp_init
+    0,                                  // tp_alloc
+    (newfunc) Connection_New,           // tp_new
+    0,                                  // tp_free
+    0,                                  // tp_is_gc
+    0                                   // tp_bases
+};
+
+
+//-----------------------------------------------------------------------------
+// Connection_IsConnected()
+//   Determines if the connection object is connected to the database. If not,
+// a Python exception is raised.
+//-----------------------------------------------------------------------------
+static int Connection_IsConnected(
+    udt_Connection *self)               // connection to check
+{
+    if (!self->handle) {
+        PyErr_SetString(g_InterfaceErrorException, "not connected");
+        return -1;
+    }
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// Connection_GetConnection()
+//   Get a connection using the OCISessionGet() interface rather than using
+// the low level interface for connecting.
+//-----------------------------------------------------------------------------
+static int Connection_GetConnection(
+    udt_Connection *self,               // connection
+    udt_SessionPool *pool,              // pool to acquire connection from
+    PyObject *cclassObj,                // connection class (DRCP)
+    ub4 purity)                         // purity (DRCP)
+{
+    int externalCredentials, proxyCredentials;
+    udt_Environment *environment;
+    udt_Buffer buffer;
+    OCIAuthInfo *authInfo;
+    PyObject *dbNameObj;
+    boolean found;
+    sword status;
+    ub4 mode;
+
+    // set things up for the call to acquire a session
+    authInfo = NULL;
+    proxyCredentials = 0;
+    if (pool) {
+        environment = pool->environment;
+        dbNameObj = pool->name;
+        mode = OCI_SESSGET_SPOOL;
+        if (!pool->homogeneous && pool->username && self->username) {
+            proxyCredentials = PyObject_RichCompareBool(self->username,
+                    pool->username, Py_NE);
+            if (proxyCredentials < 0)
+                return -1;
+            mode = mode | OCI_SESSGET_CREDPROXY;
+        }
+    } else {
+        environment = self->environment;
+        dbNameObj = self->dsn;
+        mode = OCI_SESSGET_STMTCACHE;
+    }
+
+    // set up authorization handle, if needed
+    if (!pool || cclassObj || proxyCredentials) {
+
+        // create authorization handle
+        status = OCIHandleAlloc(environment->handle, (dvoid*) &authInfo,
+                OCI_HTYPE_AUTHINFO, 0, NULL);
+        if (Environment_CheckForError(environment, status,
+                "Connection_GetConnection(): allocate handle") < 0)
+            return -1;
+
+        // set the user name, if applicable
+        externalCredentials = 1;
+        if (cxBuffer_FromObject(&buffer, self->username,
+                self->environment->encoding) < 0)
+            return -1;
+        if (buffer.size > 0) {
+            externalCredentials = 0;
+            status = OCIAttrSet(authInfo, OCI_HTYPE_AUTHINFO,
+                    (text*) buffer.ptr, buffer.size, OCI_ATTR_USERNAME,
+                    environment->errorHandle);
+            if (Environment_CheckForError(environment, status,
+                    "Connection_GetConnection(): set user name") < 0) {
+                cxBuffer_Clear(&buffer);
+                return -1;
+            }
+        }
+        cxBuffer_Clear(&buffer);
+
+        // set the password, if applicable
+        if (cxBuffer_FromObject(&buffer, self->password,
+                self->environment->encoding) < 0)
+            return -1;
+        if (buffer.size > 0) {
+            externalCredentials = 0;
+            status = OCIAttrSet(authInfo, OCI_HTYPE_AUTHINFO,
+                    (text*) buffer.ptr, buffer.size, OCI_ATTR_PASSWORD,
+                    environment->errorHandle);
+            if (Environment_CheckForError(environment, status,
+                    "Connection_GetConnection(): set password") < 0) {
+                cxBuffer_Clear(&buffer);
+                return -1;
+            }
+        }
+        cxBuffer_Clear(&buffer);
+
+        // if no user name or password are set, using external credentials
+        if (!pool && externalCredentials)
+            mode |= OCI_SESSGET_CREDEXT;
+
+#ifdef ORACLE_11G
+        // set the connection class, if applicable
+        if (cxBuffer_FromObject(&buffer, cclassObj,
+                self->environment->encoding) < 0)
+            return -1;
+        if (buffer.size > 0) {
+            status = OCIAttrSet(authInfo, OCI_HTYPE_AUTHINFO,
+                    (text*) buffer.ptr, buffer.size, OCI_ATTR_CONNECTION_CLASS,
+                    environment->errorHandle);
+            if (Environment_CheckForError(environment, status,
+                    "Connection_GetConnection(): set connection class") < 0) {
+                cxBuffer_Clear(&buffer);
+                return -1;
+            }
+        }
+        cxBuffer_Clear(&buffer);
+
+        // set the purity, if applicable
+        if (purity != OCI_ATTR_PURITY_DEFAULT) {
+            status = OCIAttrSet(authInfo, OCI_HTYPE_AUTHINFO, &purity,
+                    sizeof(purity), OCI_ATTR_PURITY,
+                    environment->errorHandle);
+            if (Environment_CheckForError(environment, status,
+                    "Connection_GetConnection(): set purity") < 0)
+                return -1;
+        }
+#endif
+    }
+
+    // acquire the new session
+    if (cxBuffer_FromObject(&buffer, dbNameObj,
+            self->environment->encoding) < 0)
+        return -1;
+    Py_BEGIN_ALLOW_THREADS
+    status = OCISessionGet(environment->handle, environment->errorHandle,
+            &self->handle, authInfo, (text*) buffer.ptr, buffer.size, NULL, 0,
+            NULL, NULL, &found, mode);
+    Py_END_ALLOW_THREADS
+    cxBuffer_Clear(&buffer);
+    if (Environment_CheckForError(environment, status,
+            "Connection_GetConnection(): get connection") < 0)
+        return -1;
+
+    // eliminate the authorization handle immediately, if applicable
+    if (authInfo)
+        OCIHandleFree(authInfo, OCI_HTYPE_AUTHINFO);
+
+    // copy members in the case where a pool is being used
+    if (pool) {
+        if (!proxyCredentials) {
+            Py_INCREF(pool->username);
+            self->username = pool->username;
+            Py_INCREF(pool->password);
+            self->password = pool->password;
+        }
+        Py_INCREF(pool->dsn);
+        self->dsn = pool->dsn;
+        Py_INCREF(pool);
+        self->sessionPool = pool;
+    }
+
+    self->release = 1;
+    return 0;
+}
+
+
+#ifdef ORACLE_10G
+//-----------------------------------------------------------------------------
+// Connection_GetOCIAttr()
+//   Get the value of the OCI attribute.
+//-----------------------------------------------------------------------------
+static PyObject *Connection_GetOCIAttr(
+    udt_Connection *self,               // connection to set
+    ub4 *attribute)                     // OCI attribute type
+{
+    OCISession *sessionHandle;
+    udt_Buffer buffer;
+    sword status;
+
+    // make sure connection is connected
+    if (Connection_IsConnected(self) < 0)
+        return NULL;
+
+    // acquire the session handle
+    status = OCIAttrGet(self->handle, OCI_HTYPE_SVCCTX,
+            (dvoid**) &sessionHandle, 0, OCI_ATTR_SESSION,
+            self->environment->errorHandle);
+    if (Environment_CheckForError(self->environment, status,
+            "Connection_GetOCIAttr(): determine session handle") < 0)
+        return NULL;
+
+    // get the value from the OCI
+    status = OCIAttrGet(sessionHandle, OCI_HTYPE_SESSION,
+            (text**) &buffer.ptr, (ub4*) &buffer.size, *attribute,
+            self->environment->errorHandle);
+    if (Environment_CheckForError(self->environment, status,
+            "Connection_GetOCIAttr()") < 0)
+        return NULL;
+
+    return cxString_FromEncodedString(buffer.ptr, buffer.size,
+            self->environment->encoding);
+}
+#endif
+
+
+//-----------------------------------------------------------------------------
+// Connection_SetOCIAttr()
+//   Set the value of the OCI attribute.
+//-----------------------------------------------------------------------------
+static int Connection_SetOCIAttr(
+    udt_Connection *self,               // connection to set
+    PyObject *value,                    // value to set
+    ub4 *attribute)                     // OCI attribute type
+{
+    OCISession *sessionHandle;
+    udt_Buffer buffer;
+    sword status;
+
+    // verify arguments
+    if (!cxString_Check(value)) {
+        PyErr_SetString(PyExc_TypeError, "value must be a string");
+        return -1;
+    }
+
+    // make sure connection is connected
+    if (Connection_IsConnected(self) < 0)
+        return -1;
+
+    // acquire the session handle
+    status = OCIAttrGet(self->handle, OCI_HTYPE_SVCCTX,
+            (dvoid**) &sessionHandle, 0, OCI_ATTR_SESSION,
+            self->environment->errorHandle);
+    if (Environment_CheckForError(self->environment, status,
+            "Connection_SetOCIAttr(): determine session handle") < 0)
+        return -1;
+
+    // set the value in the OCI
+    if (cxBuffer_FromObject(&buffer, value, self->environment->encoding))
+        return -1;
+    status = OCIAttrSet(sessionHandle, OCI_HTYPE_SESSION, (text*) buffer.ptr,
+            buffer.size, *attribute, self->environment->errorHandle);
+    cxBuffer_Clear(&buffer);
+    if (Environment_CheckForError(self->environment, status,
+            "Connection_SetOCIAttr(): set value") < 0)
+        return -1;
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// Connection_Attach()
+//   Attach to an existing connection.
+//-----------------------------------------------------------------------------
+static int Connection_Attach(
+    udt_Connection *self,               // connection
+    OCISvcCtx *handle)                  // handle of connection to attach to
+{
+    OCISession *sessionHandle;
+    OCIServer *serverHandle;
+    sword status;
+
+    // acquire the server handle
+    status = OCIAttrGet(handle, OCI_HTYPE_SVCCTX, (dvoid**) &serverHandle, 0,
+            OCI_ATTR_SERVER, self->environment->errorHandle);
+    if (Environment_CheckForError(self->environment, status,
+            "Connection_Attach(): determine server handle") < 0)
+        return -1;
+
+    // acquire the session handle
+    status = OCIAttrGet(handle, OCI_HTYPE_SVCCTX, (dvoid**) &sessionHandle, 0,
+            OCI_ATTR_SESSION, self->environment->errorHandle);
+    if (Environment_CheckForError(self->environment, status,
+            "Connection_Attach(): determine session handle") < 0)
+        return -1;
+
+    // allocate the service context handle
+    status = OCIHandleAlloc(self->environment->handle,
+            (dvoid*) &self->handle, OCI_HTYPE_SVCCTX, 0, 0);
+    if (Environment_CheckForError(self->environment, status,
+            "Connection_Attach(): allocate service context handle") < 0)
+        return -1;
+
+    // set attribute for server handle
+    status = OCIAttrSet(self->handle, OCI_HTYPE_SVCCTX, serverHandle, 0,
+            OCI_ATTR_SERVER, self->environment->errorHandle);
+    if (Environment_CheckForError(self->environment, status,
+            "Connection_Attach(): set server handle") < 0)
+        return -1;
+
+    // set attribute for session handle
+    status = OCIAttrSet(self->handle, OCI_HTYPE_SVCCTX, sessionHandle, 0,
+            OCI_ATTR_SESSION, self->environment->errorHandle);
+    if (Environment_CheckForError(self->environment, status,
+            "Connection_Attach(): set session handle") < 0)
+        return -1;
+
+    self->attached = 1;
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// Connection_ChangePassword()
+//   Change the password for the given connection.
+//-----------------------------------------------------------------------------
+static int Connection_ChangePassword(
+    udt_Connection *self,               // connection
+    PyObject *oldPasswordObj,           // old password
+    PyObject *newPasswordObj)           // new password
+{
+    udt_Buffer usernameBuffer, oldPasswordBuffer, newPasswordBuffer;
+    sword status;
+
+    if (cxBuffer_FromObject(&usernameBuffer, self->username,
+            self->environment->encoding) < 0)
+        return -1;
+    if (cxBuffer_FromObject(&oldPasswordBuffer, oldPasswordObj,
+            self->environment->encoding) < 0) {
+        cxBuffer_Clear(&usernameBuffer);
+        return -1;
+    }
+    if (cxBuffer_FromObject(&newPasswordBuffer, newPasswordObj,
+            self->environment->encoding) < 0) {
+        cxBuffer_Clear(&usernameBuffer);
+        cxBuffer_Clear(&oldPasswordBuffer);
+        return -1;
+    }
+
+    // begin the session
+    Py_BEGIN_ALLOW_THREADS
+    status = OCIPasswordChange(self->handle, self->environment->errorHandle,
+            (text*) usernameBuffer.ptr, usernameBuffer.size,
+            (text*) oldPasswordBuffer.ptr, oldPasswordBuffer.size,
+            (text*) newPasswordBuffer.ptr, newPasswordBuffer.size,
+            OCI_AUTH);
+    Py_END_ALLOW_THREADS
+    cxBuffer_Clear(&usernameBuffer);
+    cxBuffer_Clear(&oldPasswordBuffer);
+    cxBuffer_Clear(&newPasswordBuffer);
+    if (Environment_CheckForError(self->environment, status,
+            "Connection_ChangePassword(): change password") < 0)
+        return -1;
+
+    Py_XDECREF(self->password);
+    Py_INCREF(newPasswordObj);
+    self->password = newPasswordObj;
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// Connection_ChangePasswordExternal()
+//   Change the password for the given connection.
+//-----------------------------------------------------------------------------
+static PyObject *Connection_ChangePasswordExternal(
+    udt_Connection *self,               // connection
+    PyObject *args)                     // arguments
+{
+    PyObject *oldPasswordObj, *newPasswordObj;
+
+    // parse the arguments
+    if (!PyArg_ParseTuple(args, "O!O!", cxString_Type, &oldPasswordObj,
+            cxString_Type, &newPasswordObj))
+        return NULL;
+
+    if (Connection_ChangePassword(self, oldPasswordObj, newPasswordObj) < 0)
+        return NULL;
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+
+//-----------------------------------------------------------------------------
+// Connection_Connect()
+//   Create a new connection object by connecting to the database.
+//-----------------------------------------------------------------------------
+static int Connection_Connect(
+    udt_Connection *self,               // connection
+    ub4 mode,                           // mode to connect as
+    int twophase,                       // allow two phase commit?
+    PyObject *newPasswordObj,           // new password (if desired)
+    PyObject *moduleObj,                // session "module" value
+    PyObject *actionObj,                // session "action" value
+    PyObject *clientinfoObj)            // session "clientinfo" value
+{
+    ub4 credentialType = OCI_CRED_EXT;
+    udt_Buffer buffer;
+    sword status;
+
+    // allocate the server handle
+    status = OCIHandleAlloc(self->environment->handle,
+            (dvoid**) &self->serverHandle, OCI_HTYPE_SERVER, 0, 0);
+    if (Environment_CheckForError(self->environment, status,
+            "Connection_Connect(): allocate server handle") < 0)
+        return -1;
+
+    // attach to the server
+    if (cxBuffer_FromObject(&buffer, self->dsn,
+            self->environment->encoding) < 0)
+        return -1;
+    Py_BEGIN_ALLOW_THREADS
+    status = OCIServerAttach(self->serverHandle,
+            self->environment->errorHandle, (text*) buffer.ptr, buffer.size,
+            OCI_DEFAULT);
+    Py_END_ALLOW_THREADS
+    cxBuffer_Clear(&buffer);
+    if (Environment_CheckForError(self->environment, status,
+            "Connection_Connect(): server attach") < 0)
+        return -1;
+
+    // allocate the service context handle
+    status = OCIHandleAlloc(self->environment->handle,
+            (dvoid**) &self->handle, OCI_HTYPE_SVCCTX, 0, 0);
+    if (Environment_CheckForError(self->environment, status,
+            "Connection_Connect(): allocate service context handle") < 0)
+        return -1;
+
+    // set attribute for server handle
+    status = OCIAttrSet(self->handle, OCI_HTYPE_SVCCTX, self->serverHandle, 0,
+            OCI_ATTR_SERVER, self->environment->errorHandle);
+    if (Environment_CheckForError(self->environment, status,
+            "Connection_Connect(): set server handle") < 0)
+        return -1;
+
+    // set the internal and external names; these are needed for global
+    // transactions but are limited in terms of the lengths of the strings
+    if (twophase) {
+        status = OCIAttrSet(self->serverHandle, OCI_HTYPE_SERVER,
+                (dvoid*) "cx_Oracle", 0, OCI_ATTR_INTERNAL_NAME,
+                self->environment->errorHandle);
+        if (Environment_CheckForError(self->environment, status,
+                "Connection_Connect(): set internal name") < 0)
+            return -1;
+        status = OCIAttrSet(self->serverHandle, OCI_HTYPE_SERVER,
+                (dvoid*) "cx_Oracle", 0, OCI_ATTR_EXTERNAL_NAME,
+                self->environment->errorHandle);
+        if (Environment_CheckForError(self->environment, status,
+                "Connection_Connect(): set external name") < 0)
+            return -1;
+    }
+
+    // allocate the session handle
+    status = OCIHandleAlloc(self->environment->handle,
+            (dvoid**) &self->sessionHandle, OCI_HTYPE_SESSION, 0, 0);
+    if (Environment_CheckForError(self->environment, status,
+            "Connection_Connect(): allocate session handle") < 0)
+        return -1;
+
+    // set user name in session handle
+    if (cxBuffer_FromObject(&buffer, self->username,
+            self->environment->encoding) < 0)
+        return -1;
+    if (buffer.size > 0) {
+        credentialType = OCI_CRED_RDBMS;
+        status = OCIAttrSet(self->sessionHandle, OCI_HTYPE_SESSION,
+                (text*) buffer.ptr, buffer.size, OCI_ATTR_USERNAME,
+                self->environment->errorHandle);
+        if (Environment_CheckForError(self->environment, status,
+                "Connection_Connect(): set user name") < 0) {
+            cxBuffer_Clear(&buffer);
+            return -1;
+        }
+    }
+    cxBuffer_Clear(&buffer);
+
+    // set password in session handle
+    if (cxBuffer_FromObject(&buffer, self->password,
+            self->environment->encoding) < 0)
+        return -1;
+    if (buffer.size > 0) {
+        credentialType = OCI_CRED_RDBMS;
+        status = OCIAttrSet(self->sessionHandle, OCI_HTYPE_SESSION,
+                (text*) buffer.ptr, buffer.size, OCI_ATTR_PASSWORD,
+                self->environment->errorHandle);
+        if (Environment_CheckForError(self->environment, status,
+                "Connection_Connect(): set password") < 0) {
+            cxBuffer_Clear(&buffer);
+            return -1;
+        }
+    }
+    cxBuffer_Clear(&buffer);
+
+#ifdef OCI_ATTR_DRIVER_NAME
+    status = OCIAttrSet(self->sessionHandle, OCI_HTYPE_SESSION,
+            (text*) DRIVER_NAME, strlen(DRIVER_NAME), OCI_ATTR_DRIVER_NAME,
+            self->environment->errorHandle);
+    if (Environment_CheckForError(self->environment, status,
+            "Connection_Connect(): set driver name") < 0)
+        return -1;
+
+#endif
+
+    // set the session handle on the service context handle
+    status = OCIAttrSet(self->handle, OCI_HTYPE_SVCCTX,
+            self->sessionHandle, 0, OCI_ATTR_SESSION,
+            self->environment->errorHandle);
+    if (Environment_CheckForError(self->environment, status,
+            "Connection_Connect(): set session handle") < 0)
+        return -1;
+
+#ifdef ORACLE_10G
+    if (moduleObj) {
+        if (cxBuffer_FromObject(&buffer, moduleObj,
+                self->environment->encoding))
+            return -1;
+        status = OCIAttrSet(self->sessionHandle, OCI_HTYPE_SESSION,
+                (text*) buffer.ptr, buffer.size, OCI_ATTR_MODULE,
+                self->environment->errorHandle);
+        cxBuffer_Clear(&buffer);
+        if (Environment_CheckForError(self->environment, status,
+                "Connection_Connect(): set module") < 0)
+            return -1;
+    }
+
+    if (actionObj) {
+        if (cxBuffer_FromObject(&buffer, actionObj,
+                self->environment->encoding))
+            return -1;
+        status = OCIAttrSet(self->sessionHandle, OCI_HTYPE_SESSION,
+                (text*) buffer.ptr, buffer.size, OCI_ATTR_ACTION,
+                self->environment->errorHandle);
+        cxBuffer_Clear(&buffer);
+        if (Environment_CheckForError(self->environment, status,
+                "Connection_Connect(): set action") < 0)
+            return -1;
+    }
+
+    if (clientinfoObj) {
+        if (cxBuffer_FromObject(&buffer, clientinfoObj,
+                self->environment->encoding))
+            return -1;
+        status = OCIAttrSet(self->sessionHandle, OCI_HTYPE_SESSION,
+                (text*) buffer.ptr, buffer.size, OCI_ATTR_CLIENT_INFO,
+                self->environment->errorHandle);
+        cxBuffer_Clear(&buffer);
+        if (Environment_CheckForError(self->environment, status,
+                "Connection_Connect(): set clientinfo") < 0)
+            return -1;
+    }
+#endif
+
+    // if a new password has been specified, change it which will also
+    // establish the session
+    if (newPasswordObj)
+        return Connection_ChangePassword(self, self->password, newPasswordObj);
+
+    // begin the session
+    Py_BEGIN_ALLOW_THREADS
+    status = OCISessionBegin(self->handle, self->environment->errorHandle,
+            self->sessionHandle, credentialType, mode);
+    Py_END_ALLOW_THREADS
+    if (Environment_CheckForError(self->environment, status,
+            "Connection_Connect(): begin session") < 0) {
+        self->sessionHandle = NULL;
+        return -1;
+    }
+
+    return 0;
+}
+
+
+#include "Cursor.c"
+#include "Callback.c"
+#ifdef ORACLE_10GR2
+#include "Subscription.c"
+#endif
+
+
+//-----------------------------------------------------------------------------
+// Connection_New()
+//   Create a new connection object and return it.
+//-----------------------------------------------------------------------------
+static PyObject* Connection_New(
+    PyTypeObject *type,                 // type object
+    PyObject *args,                     // arguments
+    PyObject *keywordArgs)              // keyword arguments
+{
+    udt_Connection *self;
+
+    // create the object
+    self = (udt_Connection*) type->tp_alloc(type, 0);
+    if (!self)
+        return NULL;
+    self->commitMode = OCI_DEFAULT;
+    self->environment = NULL;
+
+    return (PyObject*) self;
+}
+
+
+//-----------------------------------------------------------------------------
+// Connection_SplitComponent()
+//   Split the component out of the source and replace the source with the
+// characters up to the split string and put the characters after the split
+// string in to the target.
+//-----------------------------------------------------------------------------
+static int Connection_SplitComponent(
+    PyObject **sourceObj,               // source object to split
+    PyObject **targetObj,               // target object (for component)
+    const char *splitString)            // split string (assume one character)
+{
+    PyObject *temp, *posObj;
+    Py_ssize_t size, pos;
+
+    if (!*sourceObj || *targetObj)
+        return 0;
+    posObj = PyObject_CallMethod(*sourceObj, "find", "s", splitString);
+    if (!posObj)
+        return -1;
+    pos = PyInt_AsLong(posObj);
+    Py_DECREF(posObj);
+    if (PyErr_Occurred())
+        return -1;
+    if (pos >= 0) {
+        size = PySequence_Size(*sourceObj);
+        if (PyErr_Occurred())
+            return -1;
+        *targetObj = PySequence_GetSlice(*sourceObj, pos + 1, size);
+        if (!*targetObj)
+            return -1;
+        temp = PySequence_GetSlice(*sourceObj, 0, pos);
+        if (!temp)
+            return -1;
+        *sourceObj = temp;
+    }
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// Connection_Init()
+//   Initialize the connection members.
+//-----------------------------------------------------------------------------
+static int Connection_Init(
+    udt_Connection *self,               // connection
+    PyObject *args,                     // arguments
+    PyObject *keywordArgs)              // keyword arguments
+{
+    PyObject *threadedObj, *twophaseObj, *eventsObj, *newPasswordObj;
+    PyObject *usernameObj, *passwordObj, *dsnObj, *cclassObj;
+    PyObject *moduleObj, *actionObj, *clientinfoObj;
+    int threaded, twophase, events;
+    char *encoding, *nencoding;
+    ub4 connectMode, purity;
+    udt_SessionPool *pool;
+    OCISvcCtx *handle;
+
+    // define keyword arguments
+    static char *keywordList[] = { "user", "password", "dsn", "mode",
+            "handle", "pool", "threaded", "twophase", "events", "cclass",
+            "purity", "newpassword", "encoding", "nencoding", "module",
+            "action", "clientinfo", NULL };
+
+    // parse arguments
+    pool = NULL;
+    handle = NULL;
+    connectMode = OCI_DEFAULT;
+    usernameObj = passwordObj = dsnObj = cclassObj = NULL;
+    threadedObj = twophaseObj = eventsObj = newPasswordObj = NULL;
+    moduleObj = actionObj = clientinfoObj = NULL;
+    threaded = twophase = events = purity = 0;
+    encoding = nencoding = NULL;
+#ifdef ORACLE_11G
+    purity = OCI_ATTR_PURITY_DEFAULT;
+#endif
+    if (!PyArg_ParseTupleAndKeywords(args, keywordArgs,
+            "|OOOiiO!OOOOiOssOOO", keywordList, &usernameObj, &passwordObj,
+            &dsnObj, &connectMode, &handle, &g_SessionPoolType, &pool,
+            &threadedObj, &twophaseObj, &eventsObj, &cclassObj, &purity,
+            &newPasswordObj, &encoding, &nencoding, &moduleObj, &actionObj,
+            &clientinfoObj))
+        return -1;
+    if (threadedObj) {
+        threaded = PyObject_IsTrue(threadedObj);
+        if (threaded < 0)
+            return -1;
+    }
+    if (twophaseObj) {
+        twophase = PyObject_IsTrue(twophaseObj);
+        if (twophase < 0)
+            return -1;
+    }
+    if (eventsObj) {
+        events = PyObject_IsTrue(eventsObj);
+        if (events < 0)
+            return -1;
+    }
+
+    // set up the environment
+    if (pool)
+        self->environment = Environment_Clone(pool->environment);
+    else self->environment = Environment_NewFromScratch(threaded, events,
+            encoding, nencoding);
+    if (!self->environment)
+        return -1;
+
+    // keep a copy of the credentials
+    Py_XINCREF(usernameObj);
+    self->username = usernameObj;
+    Py_XINCREF(passwordObj);
+    self->password = passwordObj;
+    Py_XINCREF(dsnObj);
+    self->dsn = dsnObj;
+
+    // perform some parsing, if necessary
+    if (Connection_SplitComponent(&self->username, &self->password, "/") < 0)
+        return -1;
+    if (Connection_SplitComponent(&self->password, &self->dsn, "@") < 0)
+        return -1;
+
+    // handle the different ways of initializing the connection
+    if (handle)
+        return Connection_Attach(self, handle);
+    if (pool || cclassObj)
+        return Connection_GetConnection(self, pool, cclassObj, purity);
+    return Connection_Connect(self, connectMode, twophase, newPasswordObj,
+            moduleObj, actionObj, clientinfoObj);
+}
+
+
+//-----------------------------------------------------------------------------
+// Connection_Free()
+//   Deallocate the connection, disconnecting from the database if necessary.
+//-----------------------------------------------------------------------------
+static void Connection_Free(
+    udt_Connection *self)               // connection object
+{
+    if (self->release) {
+        Py_BEGIN_ALLOW_THREADS
+        OCITransRollback(self->handle, self->environment->errorHandle,
+                OCI_DEFAULT);
+        OCISessionRelease(self->handle, self->environment->errorHandle, NULL,
+                0, OCI_DEFAULT);
+        Py_END_ALLOW_THREADS
+    } else if (!self->attached) {
+        if (self->sessionHandle) {
+            Py_BEGIN_ALLOW_THREADS
+            OCITransRollback(self->handle, self->environment->errorHandle,
+                    OCI_DEFAULT);
+            OCISessionEnd(self->handle, self->environment->errorHandle,
+                    self->sessionHandle, OCI_DEFAULT);
+            Py_END_ALLOW_THREADS
+        }
+        if (self->serverHandle)
+            OCIServerDetach(self->serverHandle,
+                    self->environment->errorHandle, OCI_DEFAULT);
+    }
+    Py_CLEAR(self->environment);
+    Py_CLEAR(self->sessionPool);
+    Py_CLEAR(self->username);
+    Py_CLEAR(self->password);
+    Py_CLEAR(self->dsn);
+    Py_CLEAR(self->version);
+    Py_CLEAR(self->inputTypeHandler);
+    Py_CLEAR(self->outputTypeHandler);
+    Py_TYPE(self)->tp_free((PyObject*) self);
+}
+
+
+//-----------------------------------------------------------------------------
+// Connection_Repr()
+//   Return a string representation of the connection.
+//-----------------------------------------------------------------------------
+static PyObject *Connection_Repr(
+    udt_Connection *connection)         // connection to return the string for
+{
+    PyObject *module, *name, *result, *format, *formatArgs = NULL;
+
+    if (GetModuleAndName(Py_TYPE(connection), &module, &name) < 0)
+        return NULL;
+    if (connection->username && connection->username != Py_None &&
+            connection->dsn && connection->dsn != Py_None) {
+        format = cxString_FromAscii("<%s.%s to %s@%s>");
+        if (format)
+            formatArgs = PyTuple_Pack(4, module, name, connection->username,
+                    connection->dsn);
+    } else if (connection->username && connection->username != Py_None) {
+        format = cxString_FromAscii("<%s.%s to user %s@local>");
+        if (format)
+            formatArgs = PyTuple_Pack(3, module, name, connection->username);
+    } else {
+        format = cxString_FromAscii("<%s.%s to externally identified user>");
+        if (format)
+            formatArgs = PyTuple_Pack(2, module, name);
+    }
+    Py_DECREF(module);
+    Py_DECREF(name);
+    if (!format)
+        return NULL;
+    if (!formatArgs) {
+        Py_DECREF(format);
+        return NULL;
+    }
+    result = cxString_Format(format, formatArgs);
+    Py_DECREF(format);
+    Py_DECREF(formatArgs);
+    return result;
+}
+
+
+//-----------------------------------------------------------------------------
+// Connection_GetStmtCacheSize()
+//   Return the Oracle statement cache size.
+//-----------------------------------------------------------------------------
+static PyObject *Connection_GetStmtCacheSize(
+    udt_Connection* self,               // connection object
+    void* arg)                          // optional argument (ignored)
+{
+    ub4 cacheSize;
+    sword status;
+
+    if (Connection_IsConnected(self) < 0)
+        return NULL;
+    status = OCIAttrGet(self->handle, OCI_HTYPE_SVCCTX,
+            (dvoid**) &cacheSize, 0, OCI_ATTR_STMTCACHESIZE,
+            self->environment->errorHandle);
+    if (Environment_CheckForError(self->environment, status,
+            "Connection_GetStmtCacheSize()") < 0)
+        return NULL;
+    return PyInt_FromLong(cacheSize);
+}
+
+
+//-----------------------------------------------------------------------------
+// Connection_SetStmtCacheSize()
+//   Set the Oracle statement cache size.
+//-----------------------------------------------------------------------------
+static int Connection_SetStmtCacheSize(
+    udt_Connection* self,               // connection object
+    PyObject *value,                    // value to set it to
+    void* arg)                          // optional argument (ignored)
+{
+    ub4 valueToSet;
+    sword status;
+
+    if (Connection_IsConnected(self) < 0)
+        return -1;
+    if (!PyInt_Check(value)) {
+        PyErr_SetString(PyExc_TypeError, "value must be an integer");
+        return -1;
+    }
+    valueToSet = (ub4) PyInt_AsLong(value);
+    if (PyErr_Occurred())
+        return -1;
+    status = OCIAttrSet(self->handle, OCI_HTYPE_SVCCTX, (dvoid*) &valueToSet,
+            0, OCI_ATTR_STMTCACHESIZE, self->environment->errorHandle);
+    if (Environment_CheckForError(self->environment, status,
+            "Connection_SetStmtCacheSize()") < 0)
+        return -1;
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// Connection_GetVersion()
+//   Retrieve the version of the database and return it. Note that this
+// function also places the result in the associated dictionary so it is only
+// calculated once.
+//-----------------------------------------------------------------------------
+static PyObject *Connection_GetVersion(
+    udt_Connection *self,               // connection object
+    void *arg)                          // optional argument (ignored)
+{
+    PyObject *procName, *listOfArguments;
+    udt_Variable *versionVar, *compatVar;
+    udt_Cursor *cursor;
+
+    // if version has already been determined, no need to determine again
+    if (self->version) {
+        Py_INCREF(self->version);
+        return self->version;
+    }
+
+    // allocate a cursor to retrieve the version
+    cursor = (udt_Cursor*) Connection_NewCursor(self, NULL);
+    if (!cursor)
+        return NULL;
+
+    // allocate version variable
+    versionVar = Variable_New(cursor, cursor->arraySize, &vt_String,
+            vt_String.size);
+    if (!versionVar) {
+        Py_DECREF(cursor);
+        return NULL;
+    }
+
+    // allocate compatibility variable
+    compatVar = Variable_New(cursor, cursor->arraySize, &vt_String,
+            vt_String.size);
+    if (!compatVar) {
+        Py_DECREF(versionVar);
+        Py_DECREF(cursor);
+        return NULL;
+    }
+
+    // create the list of arguments
+    listOfArguments = PyList_New(2);
+    if (!listOfArguments) {
+        Py_DECREF(versionVar);
+        Py_DECREF(compatVar);
+        Py_DECREF(cursor);
+        return NULL;
+    }
+    PyList_SET_ITEM(listOfArguments, 0, (PyObject*) versionVar);
+    PyList_SET_ITEM(listOfArguments, 1, (PyObject*) compatVar);
+
+    // create the string variable
+    procName = cxString_FromAscii("dbms_utility.db_version");
+    if (!procName) {
+        Py_DECREF(listOfArguments);
+        Py_DECREF(cursor);
+        return NULL;
+    }
+
+    // call stored procedure
+    if (Cursor_Call(cursor, NULL, procName, listOfArguments, NULL) < 0) {
+        Py_DECREF(procName);
+        Py_DECREF(listOfArguments);
+        Py_DECREF(cursor);
+        return NULL;
+    }
+    Py_DECREF(procName);
+
+    // retrieve value
+    self->version = Variable_GetValue(versionVar, 0);
+    Py_DECREF(listOfArguments);
+    Py_DECREF(cursor);
+    Py_XINCREF(self->version);
+    return self->version;
+}
+
+
+//-----------------------------------------------------------------------------
+// Connection_GetEncoding()
+//   Return the encoding associated with the environment of the connection.
+//-----------------------------------------------------------------------------
+static PyObject *Connection_GetEncoding(
+    udt_Connection *self,               // connection object
+    void *arg)                          // optional argument (ignored)
+{
+    return cxString_FromAscii(self->environment->encoding);
+}
+
+
+//-----------------------------------------------------------------------------
+// Connection_GetNationalEncoding()
+//   Return the national encoding associated with the environment of the
+// connection.
+//-----------------------------------------------------------------------------
+static PyObject *Connection_GetNationalEncoding(
+    udt_Connection *self,               // connection object
+    void *arg)                          // optional argument (ignored)
+{
+    return cxString_FromAscii(self->environment->nencoding);
+}
+
+
+//-----------------------------------------------------------------------------
+// Connection_GetMaxBytesPerCharacter()
+//   Return the maximum number of bytes per character.
+//-----------------------------------------------------------------------------
+static PyObject *Connection_GetMaxBytesPerCharacter(
+    udt_Connection *self,               // connection object
+    void *arg)                          // optional argument (ignored)
+{
+    return PyInt_FromLong(self->environment->maxBytesPerCharacter);
+}
+
+
+//-----------------------------------------------------------------------------
+// Connection_Close()
+//   Close the connection, disconnecting from the database.
+//-----------------------------------------------------------------------------
+static PyObject *Connection_Close(
+    udt_Connection *self,               // connection to close
+    PyObject *args)                     // arguments
+{
+    sword status;
+
+    // make sure we are actually connected
+    if (Connection_IsConnected(self) < 0)
+        return NULL;
+
+    // perform a rollback
+    Py_BEGIN_ALLOW_THREADS
+    status = OCITransRollback(self->handle, self->environment->errorHandle,
+            OCI_DEFAULT);
+    Py_END_ALLOW_THREADS
+    if (Environment_CheckForError(self->environment, status,
+            "Connection_Close(): rollback") < 0)
+        return NULL;
+
+    // logoff of the server
+    if (self->sessionHandle) {
+        Py_BEGIN_ALLOW_THREADS
+        status = OCISessionEnd(self->handle, self->environment->errorHandle,
+                self->sessionHandle, OCI_DEFAULT);
+        Py_END_ALLOW_THREADS
+        if (Environment_CheckForError(self->environment, status,
+                "Connection_Close(): end session") < 0)
+            return NULL;
+        OCIHandleFree(self->handle, OCI_HTYPE_SVCCTX);
+    }
+    self->handle = NULL;
+    if (self->serverHandle) {
+        status = OCIServerDetach(self->serverHandle,
+                self->environment->errorHandle, OCI_DEFAULT);
+        if (Environment_CheckForError(self->environment, status,
+                "Connection_Close(): server detach") < 0)
+            return NULL;
+        self->serverHandle = NULL;
+    }
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+
+//-----------------------------------------------------------------------------
+// Connection_Commit()
+//   Commit the transaction on the connection.
+//-----------------------------------------------------------------------------
+static PyObject *Connection_Commit(
+    udt_Connection *self,               // connection to commit
+    PyObject *args)                     // arguments
+{
+    sword status;
+
+    // make sure we are actually connected
+    if (Connection_IsConnected(self) < 0)
+        return NULL;
+
+    // perform the commit
+    Py_BEGIN_ALLOW_THREADS
+    status = OCITransCommit(self->handle, self->environment->errorHandle,
+            self->commitMode);
+    Py_END_ALLOW_THREADS
+    if (Environment_CheckForError(self->environment, status,
+            "Connection_Commit()") < 0)
+        return NULL;
+    self->commitMode = OCI_DEFAULT;
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+
+//-----------------------------------------------------------------------------
+// Connection_Begin()
+//   Begin a new transaction on the connection.
+//-----------------------------------------------------------------------------
+static PyObject *Connection_Begin(
+    udt_Connection *self,               // connection to commit
+    PyObject *args)                     // arguments
+{
+    unsigned transactionIdLength, branchIdLength;
+    const char *transactionId, *branchId;
+    OCITrans *transactionHandle;
+    int formatId;
+    sword status;
+    XID xid;
+
+    // parse the arguments
+    formatId = -1;
+    transactionIdLength = branchIdLength = 0;
+    if (!PyArg_ParseTuple(args, "|is#s#", &formatId, &transactionId,
+            &transactionIdLength,  &branchId, &branchIdLength))
+        return NULL;
+    if (transactionIdLength > MAXGTRIDSIZE) {
+        PyErr_SetString(PyExc_ValueError, "transaction id too large");
+        return NULL;
+    }
+    if (branchIdLength > MAXBQUALSIZE) {
+        PyErr_SetString(PyExc_ValueError, "branch id too large");
+        return NULL;
+    }
+
+    // make sure we are actually connected
+    if (Connection_IsConnected(self) < 0)
+        return NULL;
+
+    // determine if a transaction handle was previously allocated
+    status = OCIAttrGet(self->handle, OCI_HTYPE_SVCCTX,
+            (dvoid**) &transactionHandle, 0, OCI_ATTR_TRANS,
+            self->environment->errorHandle);
+    if (Environment_CheckForError(self->environment, status,
+            "Connection_Begin(): find existing transaction handle") < 0)
+        return NULL;
+
+    // create a new transaction handle, if necessary
+    if (!transactionHandle) {
+        status = OCIHandleAlloc(self->environment->handle,
+                (dvoid**) &transactionHandle, OCI_HTYPE_TRANS, 0, 0);
+        if (Environment_CheckForError(self->environment, status,
+                "Connection_Begin(): allocate transaction handle") < 0)
+            return NULL;
+    }
+
+    // set the XID for the transaction, if applicable
+    if (formatId != -1) {
+        xid.formatID = formatId;
+        xid.gtrid_length = transactionIdLength;
+        xid.bqual_length = branchIdLength;
+        if (transactionIdLength > 0)
+            strncpy(xid.data, transactionId, transactionIdLength);
+        if (branchIdLength > 0)
+            strncpy(&xid.data[transactionIdLength], branchId, branchIdLength);
+        OCIAttrSet(transactionHandle, OCI_HTYPE_TRANS, &xid, sizeof(XID),
+                OCI_ATTR_XID, self->environment->errorHandle);
+        if (Environment_CheckForError(self->environment, status,
+                "Connection_Begin(): set XID") < 0)
+            return NULL;
+    }
+
+    // associate the transaction with the connection
+    OCIAttrSet(self->handle, OCI_HTYPE_SVCCTX, transactionHandle, 0,
+            OCI_ATTR_TRANS, self->environment->errorHandle);
+    if (Environment_CheckForError(self->environment, status,
+            "Connection_Begin(): associate transaction") < 0)
+        return NULL;
+
+    // start the transaction
+    Py_BEGIN_ALLOW_THREADS
+    status = OCITransStart(self->handle, self->environment->errorHandle, 0,
+            OCI_TRANS_NEW);
+    Py_END_ALLOW_THREADS
+    if (Environment_CheckForError(self->environment, status,
+            "Connection_Begin(): start transaction") < 0)
+        return NULL;
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+
+//-----------------------------------------------------------------------------
+// Connection_Prepare()
+//   Commit the transaction on the connection.
+//-----------------------------------------------------------------------------
+static PyObject *Connection_Prepare(
+    udt_Connection *self,               // connection to commit
+    PyObject *args)                     // arguments
+{
+    sword status;
+
+    // make sure we are actually connected
+    if (Connection_IsConnected(self) < 0)
+        return NULL;
+
+    // perform the prepare
+    Py_BEGIN_ALLOW_THREADS
+    status = OCITransPrepare(self->handle, self->environment->errorHandle,
+            OCI_DEFAULT);
+    Py_END_ALLOW_THREADS
+    if (Environment_CheckForError(self->environment, status,
+            "Connection_Prepare()") < 0)
+        return NULL;
+
+    // if nothing available to prepare, return False in order to allow for
+    // avoiding the call to commit() which will fail with ORA-24756
+    // (transaction does not exist)
+    if (status == OCI_SUCCESS_WITH_INFO) {
+        Py_INCREF(Py_False);
+        return Py_False;
+    }
+    self->commitMode = OCI_TRANS_TWOPHASE;
+    Py_INCREF(Py_True);
+    return Py_True;
+}
+
+
+//-----------------------------------------------------------------------------
+// Connection_Rollback()
+//   Rollback the transaction on the connection.
+//-----------------------------------------------------------------------------
+static PyObject *Connection_Rollback(
+    udt_Connection *self,               // connection to rollback
+    PyObject *args)                     // arguments
+{
+    sword status;
+
+    // make sure we are actually connected
+    if (Connection_IsConnected(self) < 0)
+        return NULL;
+
+    // perform the rollback
+    Py_BEGIN_ALLOW_THREADS
+    status = OCITransRollback(self->handle, self->environment->errorHandle,
+            OCI_DEFAULT);
+    Py_END_ALLOW_THREADS
+    if (Environment_CheckForError(self->environment, status,
+            "Connection_Rollback()") < 0)
+        return NULL;
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+
+//-----------------------------------------------------------------------------
+// Connection_NewCursor()
+//   Create a new cursor (statement) referencing the connection.
+//-----------------------------------------------------------------------------
+static PyObject *Connection_NewCursor(
+    udt_Connection *self,               // connection to create cursor on
+    PyObject *args)                     // arguments
+{
+    PyObject *createArgs, *result;
+
+    createArgs = PyTuple_New(1);
+    if (!createArgs)
+        return NULL;
+    Py_INCREF(self);
+    PyTuple_SET_ITEM(createArgs, 0, (PyObject*) self);
+    result = PyObject_Call( (PyObject*) &g_CursorType, createArgs, NULL);
+    Py_DECREF(createArgs);
+    return result;
+}
+
+
+//-----------------------------------------------------------------------------
+// Connection_Cancel()
+//   Execute an OCIBreak() to cause an immediate (asynchronous) abort of any
+// currently executing OCI function.
+//-----------------------------------------------------------------------------
+static PyObject *Connection_Cancel(
+    udt_Connection *self,               // connection to cancel
+    PyObject *args)                     // arguments
+{
+    sword status;
+
+    // make sure we are actually connected
+    if (Connection_IsConnected(self) < 0)
+        return NULL;
+
+    // perform the break
+    status = OCIBreak(self->handle, self->environment->errorHandle);
+    if (Environment_CheckForError(self->environment, status,
+            "Connection_Cancel()") < 0)
+        return NULL;
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+
+//-----------------------------------------------------------------------------
+// Connection_RegisterCallback()
+//   Register a callback for the OCI function.
+//-----------------------------------------------------------------------------
+static PyObject *Connection_RegisterCallback(
+    udt_Connection *self,               // connection to register callback on
+    PyObject *args)                     // arguments
+{
+    PyObject *callback, *tuple;
+    int functionCode, when;
+    sword status;
+
+    // parse the arguments
+    if (!PyArg_ParseTuple(args, "iiO", &functionCode, &when, &callback))
+        return NULL;
+
+    // create a tuple for passing through to the callback handler
+    tuple = Py_BuildValue("OO", self, callback);
+    if (!tuple)
+        return NULL;
+
+    // make sure we are actually connected
+    if (Connection_IsConnected(self) < 0)
+        return NULL;
+
+    // register the callback with the OCI
+    status = OCIUserCallbackRegister(self->environment->handle, OCI_HTYPE_ENV,
+            self->environment->errorHandle, (OCIUserCallback) Callback_Handler,
+            tuple, functionCode, when, NULL);
+    if (Environment_CheckForError(self->environment, status,
+            "Connection_RegisterCallback()") < 0)
+        return NULL;
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+//-----------------------------------------------------------------------------
+// Connection_UnregisterCallback()
+//   Unregister a callback for the OCI function, if one has been registered.
+// No error is raised if a callback has not been registered.
+//-----------------------------------------------------------------------------
+static PyObject *Connection_UnregisterCallback(
+    udt_Connection *self,               // connection to unregister callback on
+    PyObject *args)                     // arguments
+{
+    OCIUserCallback callback;
+    int functionCode, when;
+    PyObject *tuple;
+    sword status;
+
+    // parse the arguments
+    if (!PyArg_ParseTuple(args, "ii", &functionCode, &when))
+        return NULL;
+
+    // make sure we are actually connected
+    if (Connection_IsConnected(self) < 0)
+        return NULL;
+
+    // find out if a callback has been registered
+    status = OCIUserCallbackGet(self->environment->handle, OCI_HTYPE_ENV,
+            self->environment->errorHandle, functionCode, when, &callback,
+            (dvoid**) &tuple, NULL);
+    if (Environment_CheckForError(self->environment, status,
+            "Connection_UnregisterCallback(): get") < 0)
+        return NULL;
+
+    // if a callback was registered, clear it
+    if (callback) {
+        Py_DECREF(tuple);
+        status = OCIUserCallbackRegister(self->environment->handle,
+                OCI_HTYPE_ENV, self->environment->errorHandle, NULL,
+                NULL, functionCode, when, NULL);
+        if (Environment_CheckForError(self->environment, status,
+                "Connection_UnregisterCallback(): clear") < 0)
+            return NULL;
+    }
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+
+//-----------------------------------------------------------------------------
+// Connection_ContextManagerEnter()
+//   Called when the connection is used as a context manager and simply returns
+// itself as a convenience to the caller.
+//-----------------------------------------------------------------------------
+static PyObject *Connection_ContextManagerEnter(
+    udt_Connection *self,               // connection
+    PyObject* args)                     // arguments
+{
+    Py_INCREF(self);
+    return (PyObject*) self;
+}
+
+
+//-----------------------------------------------------------------------------
+// Connection_ContextManagerExit()
+//   Called when the connection is used as a context manager and if any
+// exception a rollback takes place; otherwise, a commit takes place.
+//-----------------------------------------------------------------------------
+static PyObject *Connection_ContextManagerExit(
+    udt_Connection *self,               // connection
+    PyObject* args)                     // arguments
+{
+    PyObject *excType, *excValue, *excTraceback, *result;
+    char *methodName;
+
+    if (!PyArg_ParseTuple(args, "OOO", &excType, &excValue, &excTraceback))
+        return NULL;
+    if (excType == Py_None && excValue == Py_None && excTraceback == Py_None)
+        methodName = "commit";
+    else methodName = "rollback";
+    result = PyObject_CallMethod((PyObject*) self, methodName, "");
+    if (!result)
+        return NULL;
+    Py_DECREF(result);
+
+    Py_INCREF(Py_False);
+    return Py_False;
+}
+
+
+#ifdef ORACLE_10GR2
+#if !defined(AIX5) || defined(ORACLE_11g)
+//-----------------------------------------------------------------------------
+// Connection_Ping()
+//   Makes a round trip call to the server to confirm that the connection and
+// server are active.
+//-----------------------------------------------------------------------------
+static PyObject *Connection_Ping(
+    udt_Connection *self,               // connection
+    PyObject* args)                     // arguments
+{
+    sword status;
+
+    if (Connection_IsConnected(self) < 0)
+        return NULL;
+    status = OCIPing(self->handle, self->environment->errorHandle,
+            OCI_DEFAULT);
+    if (Environment_CheckForError(self->environment, status,
+            "Connection_Ping()") < 0)
+        return NULL;
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+#endif
+
+
+//-----------------------------------------------------------------------------
+// Connection_Shutdown()
+//   Shuts down the database. Note that this must be done in two phases except
+// in the situation where the instance is aborted.
+//-----------------------------------------------------------------------------
+static PyObject *Connection_Shutdown(
+    udt_Connection *self,               // connection
+    PyObject* args,                     // arguments
+    PyObject* keywordArgs)              // keyword arguments
+{
+    static char *keywordList[] = { "mode", NULL };
+    sword status;
+    ub4 mode;
+
+    // parse arguments
+    mode = OCI_DEFAULT;
+    if (!PyArg_ParseTupleAndKeywords(args, keywordArgs, "|i", keywordList,
+            &mode))
+        return NULL;
+
+    // perform the work
+    if (Connection_IsConnected(self) < 0)
+        return NULL;
+    status = OCIDBShutdown(self->handle, self->environment->errorHandle, NULL,
+            mode);
+    if (Environment_CheckForError(self->environment, status,
+            "Connection_Shutdown()") < 0)
+        return NULL;
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+
+//-----------------------------------------------------------------------------
+// Connection_Startup()
+//   Starts up the database, equivalent to "startup nomount" in SQL*Plus.
+//-----------------------------------------------------------------------------
+static PyObject *Connection_Startup(
+    udt_Connection *self,               // connection
+    PyObject* args,                     // arguments
+    PyObject* keywordArgs)              // keyword arguments
+{
+    static char *keywordList[] = { "force", "restrict", NULL };
+    PyObject *forceObj, *restrictObj;
+    int flagTemp;
+    sword status;
+    ub4 flags;
+
+    // parse arguments
+    forceObj = restrictObj = NULL;
+    if (!PyArg_ParseTupleAndKeywords(args, keywordArgs, "|OO", keywordList,
+            &forceObj, &restrictObj))
+        return NULL;
+
+    // set the flags to use during startup
+    flags = 0;
+    if (forceObj) {
+        flagTemp = PyObject_IsTrue(forceObj);
+        if (flagTemp < 0)
+            return NULL;
+        if (flagTemp)
+            flags |= OCI_DBSTARTUPFLAG_FORCE;
+    }
+    if (restrictObj) {
+        flagTemp = PyObject_IsTrue(restrictObj);
+        if (flagTemp < 0)
+            return NULL;
+        if (flagTemp)
+            flags |= OCI_DBSTARTUPFLAG_RESTRICT;
+    }
+
+    // perform the work
+    if (Connection_IsConnected(self) < 0)
+        return NULL;
+    status = OCIDBStartup(self->handle, self->environment->errorHandle, NULL,
+            OCI_DEFAULT, flags);
+    if (Environment_CheckForError(self->environment, status,
+            "Connection_Startup()") < 0)
+        return NULL;
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+
+//-----------------------------------------------------------------------------
+// Connection_Subscribe()
+//   Create a subscription to events that take place in the database.
+//-----------------------------------------------------------------------------
+static PyObject *Connection_Subscribe(
+    udt_Connection *self,               // connection
+    PyObject* args,                     // arguments
+    PyObject* keywordArgs)              // keyword arguments
+{
+    static char *keywordList[] = { "namespace", "protocol", "callback",
+            "timeout", "operations", "rowids", "port", NULL };
+    ub4 namespace, protocol, port, timeout, rowids, operations;
+    PyObject *rowidsObj, *callback;
+    int temp;
+
+    // parse arguments
+    timeout = rowids = port = 0;
+    rowidsObj = callback = NULL;
+    namespace = OCI_SUBSCR_NAMESPACE_DBCHANGE;
+    protocol = OCI_SUBSCR_PROTO_OCI;
+    operations = OCI_OPCODE_ALLOPS;
+    if (!PyArg_ParseTupleAndKeywords(args, keywordArgs, "|iiOiiOi", keywordList,
+            &namespace, &protocol, &callback, &timeout, &operations,
+            &rowidsObj, &port))
+        return NULL;
+
+    // set the value for rowids
+    if (rowidsObj) {
+        temp = PyObject_IsTrue(rowidsObj);
+        if (temp < 0)
+            return NULL;
+        if (temp)
+            rowids = 1;
+    }
+
+    return (PyObject*) Subscription_New(self, namespace, protocol, port,
+            callback, timeout, operations, rowids);
+}
+#endif
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/Cursor.c b/desktop/core/ext-py/cx_Oracle-5.1.2/Cursor.c
new file mode 100644
index 0000000..481e293
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/Cursor.c
@@ -0,0 +1,2272 @@
+//-----------------------------------------------------------------------------
+// Cursor.c
+//   Definition of the Python type OracleCursor.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// structure for the Python type "Cursor"
+//-----------------------------------------------------------------------------
+typedef struct {
+    PyObject_HEAD
+    OCIStmt *handle;
+    udt_Connection *connection;
+    udt_Environment *environment;
+    PyObject *statement;
+    PyObject *statementTag;
+    PyObject *bindVariables;
+    PyObject *fetchVariables;
+    PyObject *rowFactory;
+    PyObject *inputTypeHandler;
+    PyObject *outputTypeHandler;
+    int arraySize;
+    int bindArraySize;
+    int fetchArraySize;
+    int numbersAsStrings;
+    int setInputSizes;
+    int outputSize;
+    int outputSizeColumn;
+    int rowCount;
+    int actualRows;
+    int rowNum;
+    int statementType;
+    int isDML;
+    int isOpen;
+    int isOwned;
+} udt_Cursor;
+
+
+//-----------------------------------------------------------------------------
+// dependent function defintions
+//-----------------------------------------------------------------------------
+static void Cursor_Free(udt_Cursor*);
+
+
+//-----------------------------------------------------------------------------
+// functions for the Python type "Cursor"
+//-----------------------------------------------------------------------------
+static PyObject *Cursor_GetIter(udt_Cursor*);
+static PyObject *Cursor_GetNext(udt_Cursor*);
+static PyObject *Cursor_Close(udt_Cursor*, PyObject*);
+static PyObject *Cursor_CallFunc(udt_Cursor*, PyObject*, PyObject*);
+static PyObject *Cursor_CallProc(udt_Cursor*, PyObject*, PyObject*);
+static PyObject *Cursor_Execute(udt_Cursor*, PyObject*, PyObject*);
+static PyObject *Cursor_ExecuteMany(udt_Cursor*, PyObject*);
+static PyObject *Cursor_ExecuteManyPrepared(udt_Cursor*, PyObject*);
+static PyObject *Cursor_FetchOne(udt_Cursor*, PyObject*);
+static PyObject *Cursor_FetchMany(udt_Cursor*, PyObject*, PyObject*);
+static PyObject *Cursor_FetchAll(udt_Cursor*, PyObject*);
+static PyObject *Cursor_FetchRaw(udt_Cursor*, PyObject*, PyObject*);
+static PyObject *Cursor_Parse(udt_Cursor*, PyObject*);
+static PyObject *Cursor_Prepare(udt_Cursor*, PyObject*);
+static PyObject *Cursor_SetInputSizes(udt_Cursor*, PyObject*, PyObject*);
+static PyObject *Cursor_SetOutputSize(udt_Cursor*, PyObject*);
+static PyObject *Cursor_Var(udt_Cursor*, PyObject*, PyObject*);
+static PyObject *Cursor_ArrayVar(udt_Cursor*, PyObject*);
+static PyObject *Cursor_BindNames(udt_Cursor*, PyObject*);
+static PyObject *Cursor_GetDescription(udt_Cursor*, void*);
+static PyObject *Cursor_New(PyTypeObject*, PyObject*, PyObject*);
+static int Cursor_Init(udt_Cursor*, PyObject*, PyObject*);
+static PyObject *Cursor_Repr(udt_Cursor*);
+
+
+//-----------------------------------------------------------------------------
+// declaration of methods for Python type "Cursor"
+//-----------------------------------------------------------------------------
+static PyMethodDef g_CursorMethods[] = {
+    { "execute", (PyCFunction) Cursor_Execute, METH_VARARGS | METH_KEYWORDS },
+    { "fetchall", (PyCFunction) Cursor_FetchAll, METH_NOARGS },
+    { "fetchone", (PyCFunction) Cursor_FetchOne, METH_NOARGS },
+    { "fetchmany", (PyCFunction) Cursor_FetchMany,
+              METH_VARARGS | METH_KEYWORDS },
+    { "fetchraw", (PyCFunction) Cursor_FetchRaw,
+              METH_VARARGS | METH_KEYWORDS },
+    { "prepare", (PyCFunction) Cursor_Prepare, METH_VARARGS },
+    { "parse", (PyCFunction) Cursor_Parse, METH_VARARGS },
+    { "setinputsizes", (PyCFunction) Cursor_SetInputSizes,
+              METH_VARARGS | METH_KEYWORDS },
+    { "executemany", (PyCFunction) Cursor_ExecuteMany, METH_VARARGS },
+    { "callproc", (PyCFunction) Cursor_CallProc,
+              METH_VARARGS  | METH_KEYWORDS },
+    { "callfunc", (PyCFunction) Cursor_CallFunc,
+              METH_VARARGS  | METH_KEYWORDS },
+    { "executemanyprepared", (PyCFunction) Cursor_ExecuteManyPrepared,
+              METH_VARARGS },
+    { "setoutputsize", (PyCFunction) Cursor_SetOutputSize, METH_VARARGS },
+    { "var", (PyCFunction) Cursor_Var, METH_VARARGS | METH_KEYWORDS },
+    { "arrayvar", (PyCFunction) Cursor_ArrayVar, METH_VARARGS },
+    { "bindnames", (PyCFunction) Cursor_BindNames, METH_NOARGS },
+    { "close", (PyCFunction) Cursor_Close, METH_NOARGS },
+    { NULL, NULL }
+};
+
+
+//-----------------------------------------------------------------------------
+// declaration of members for Python type "Cursor"
+//-----------------------------------------------------------------------------
+static PyMemberDef g_CursorMembers[] = {
+    { "arraysize", T_INT, offsetof(udt_Cursor, arraySize), 0 },
+    { "bindarraysize", T_INT, offsetof(udt_Cursor, bindArraySize), 0 },
+    { "rowcount", T_INT, offsetof(udt_Cursor, rowCount), READONLY },
+    { "statement", T_OBJECT, offsetof(udt_Cursor, statement), READONLY },
+    { "connection", T_OBJECT_EX, offsetof(udt_Cursor, connection), READONLY },
+    { "numbersAsStrings", T_INT, offsetof(udt_Cursor, numbersAsStrings), 0 },
+    { "rowfactory", T_OBJECT, offsetof(udt_Cursor, rowFactory), 0 },
+    { "bindvars", T_OBJECT, offsetof(udt_Cursor, bindVariables), READONLY },
+    { "fetchvars", T_OBJECT, offsetof(udt_Cursor, fetchVariables), READONLY },
+    { "inputtypehandler", T_OBJECT, offsetof(udt_Cursor, inputTypeHandler),
+            0 },
+    { "outputtypehandler", T_OBJECT, offsetof(udt_Cursor, outputTypeHandler),
+            0 },
+    { NULL }
+};
+
+
+//-----------------------------------------------------------------------------
+// declaration of calculated members for Python type "Connection"
+//-----------------------------------------------------------------------------
+static PyGetSetDef g_CursorCalcMembers[] = {
+    { "description", (getter) Cursor_GetDescription, 0, 0, 0 },
+    { NULL }
+};
+
+
+//-----------------------------------------------------------------------------
+// declaration of Python type "Cursor"
+//-----------------------------------------------------------------------------
+static PyTypeObject g_CursorType = {
+    PyVarObject_HEAD_INIT(NULL, 0)
+    "OracleCursor",                     // tp_name
+    sizeof(udt_Cursor),                 // tp_basicsize
+    0,                                  // tp_itemsize
+    (destructor) Cursor_Free,           // tp_dealloc
+    0,                                  // tp_print
+    0,                                  // tp_getattr
+    0,                                  // tp_setattr
+    0,                                  // tp_compare
+    (reprfunc) Cursor_Repr,             // tp_repr
+    0,                                  // tp_as_number
+    0,                                  // tp_as_sequence
+    0,                                  // tp_as_mapping
+    0,                                  // tp_hash
+    0,                                  // tp_call
+    0,                                  // tp_str
+    0,                                  // tp_getattro
+    0,                                  // tp_setattro
+    0,                                  // tp_as_buffer
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
+                                        // tp_flags
+    0,                                  // tp_doc
+    0,                                  // tp_traverse
+    0,                                  // tp_clear
+    0,                                  // tp_richcompare
+    0,                                  // tp_weaklistoffset
+    (getiterfunc) Cursor_GetIter,       // tp_iter
+    (iternextfunc) Cursor_GetNext,      // tp_iternext
+    g_CursorMethods,                    // tp_methods
+    g_CursorMembers,                    // tp_members
+    g_CursorCalcMembers,                // tp_getset
+    0,                                  // tp_base
+    0,                                  // tp_dict
+    0,                                  // tp_descr_get
+    0,                                  // tp_descr_set
+    0,                                  // tp_dictoffset
+    (initproc) Cursor_Init,             // tp_init
+    0,                                  // tp_alloc
+    Cursor_New,                         // tp_new
+    0,                                  // tp_free
+    0,                                  // tp_is_gc
+    0                                   // tp_bases
+};
+
+
+//-----------------------------------------------------------------------------
+// Cursor_AllocateHandle()
+//   Allocate a new handle.
+//-----------------------------------------------------------------------------
+static int Cursor_AllocateHandle(
+    udt_Cursor *self)                   // cursor object
+{
+    sword status;
+
+    self->isOwned = 1;
+    status = OCIHandleAlloc(self->environment->handle,
+            (dvoid**) &self->handle, OCI_HTYPE_STMT, 0, 0);
+    if (Environment_CheckForError(self->environment, status,
+            "Cursor_New()") < 0)
+        return -1;
+
+    return 0;
+}
+
+//-----------------------------------------------------------------------------
+// Cursor_FreeHandle()
+//   Free the handle which may be reallocated if necessary.
+//-----------------------------------------------------------------------------
+static int Cursor_FreeHandle(
+    udt_Cursor *self,                   // cursor object
+    int raiseException)                 // raise an exception, if necesary?
+{
+    udt_Buffer buffer;
+    sword status;
+
+    if (self->handle) {
+        if (self->isOwned) {
+            status = OCIHandleFree(self->handle, OCI_HTYPE_STMT);
+            if (raiseException && Environment_CheckForError(
+                    self->environment, status, "Cursor_FreeHandle()") < 0)
+                return -1;
+        } else if (self->connection->handle != 0) {
+            if (!cxBuffer_FromObject(&buffer, self->statementTag,
+                    self->environment->encoding) < 0)
+                return (raiseException) ? -1 : 0;
+            status = OCIStmtRelease(self->handle,
+                    self->environment->errorHandle, (text*) buffer.ptr,
+                    buffer.size, OCI_DEFAULT);
+            cxBuffer_Clear(&buffer);
+            if (raiseException && Environment_CheckForError(
+                    self->environment, status, "Cursor_FreeHandle()") < 0)
+                return -1;
+        }
+        self->handle = NULL;
+    }
+    return 0;
+}
+
+
+#include "Variable.c"
+
+
+//-----------------------------------------------------------------------------
+// Cursor_IsOpen()
+//   Determines if the cursor object is open and if so, if the connection is
+// also open.
+//-----------------------------------------------------------------------------
+static int Cursor_IsOpen(
+    udt_Cursor *self)                   // cursor to check
+{
+    if (!self->isOpen) {
+        PyErr_SetString(g_InterfaceErrorException, "not open");
+        return -1;
+    }
+    return Connection_IsConnected(self->connection);
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_New()
+//   Create a new cursor object.
+//-----------------------------------------------------------------------------
+static PyObject *Cursor_New(
+    PyTypeObject *type,                 // type object
+    PyObject *args,                     // arguments
+    PyObject *keywordArgs)              // keyword arguments
+{
+    return type->tp_alloc(type, 0);
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_Init()
+//   Create a new cursor object.
+//-----------------------------------------------------------------------------
+static int Cursor_Init(
+    udt_Cursor *self,                   // cursor object
+    PyObject *args,                     // arguments
+    PyObject *keywordArgs)              // keyword arguments
+{
+    udt_Connection *connection;
+
+    // parse arguments
+    if (!PyArg_ParseTuple(args, "O!", &g_ConnectionType, &connection))
+        return -1;
+
+    // initialize members
+    Py_INCREF(connection);
+    self->connection = connection;
+    self->environment = connection->environment;
+    self->arraySize = 50;
+    self->fetchArraySize = 50;
+    self->bindArraySize = 1;
+    self->statementType = -1;
+    self->outputSize = -1;
+    self->outputSizeColumn = -1;
+    self->isOpen = 1;
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_Repr()
+//   Return a string representation of the cursor.
+//-----------------------------------------------------------------------------
+static PyObject *Cursor_Repr(
+    udt_Cursor *cursor)                 // cursor to return the string for
+{
+    PyObject *connectionRepr, *module, *name, *result, *format, *formatArgs;
+
+    format = cxString_FromAscii("<%s.%s on %s>");
+    if (!format)
+        return NULL;
+    connectionRepr = PyObject_Repr((PyObject*) cursor->connection);
+    if (!connectionRepr) {
+        Py_DECREF(format);
+        return NULL;
+    }
+    if (GetModuleAndName(Py_TYPE(cursor), &module, &name) < 0) {
+        Py_DECREF(format);
+        Py_DECREF(connectionRepr);
+        return NULL;
+    }
+    formatArgs = PyTuple_Pack(3, module, name, connectionRepr);
+    Py_DECREF(module);
+    Py_DECREF(name);
+    Py_DECREF(connectionRepr);
+    if (!formatArgs) {
+        Py_DECREF(format);
+        return NULL;
+    }
+    result = cxString_Format(format, formatArgs);
+    Py_DECREF(format);
+    Py_DECREF(formatArgs);
+    return result;
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_Free()
+//   Deallocate the cursor.
+//-----------------------------------------------------------------------------
+static void Cursor_Free(
+    udt_Cursor *self)                   // cursor object
+{
+    Cursor_FreeHandle(self, 0);
+    Py_CLEAR(self->statement);
+    Py_CLEAR(self->statementTag);
+    Py_CLEAR(self->bindVariables);
+    Py_CLEAR(self->fetchVariables);
+    Py_CLEAR(self->connection);
+    Py_CLEAR(self->rowFactory);
+    Py_CLEAR(self->inputTypeHandler);
+    Py_CLEAR(self->outputTypeHandler);
+    Py_TYPE(self)->tp_free((PyObject*) self);
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_GetBindNames()
+//   Return a list of bind variable names. At this point the cursor must have
+// already been prepared.
+//-----------------------------------------------------------------------------
+static int Cursor_GetBindNames(
+    udt_Cursor *self,                   // cursor to get information from
+    int numElements,                    // number of elements (IN/OUT)
+    PyObject **names)                   // list of names (OUT)
+{
+    ub1 *bindNameLengths, *indicatorNameLengths, *duplicate;
+    char *buffer, **bindNames, **indicatorNames;
+    OCIBind **bindHandles;
+    int elementSize, i;
+    sb4 foundElements;
+    PyObject *temp;
+    sword status;
+
+    // ensure that a statement has already been prepared
+    if (!self->statement) {
+        PyErr_SetString(g_ProgrammingErrorException,
+                "statement must be prepared first");
+        return -1;
+    }
+
+    // avoid bus errors on 64-bit platforms
+    numElements = numElements + (sizeof(void*) - numElements % sizeof(void*));
+
+    // initialize the buffers
+    elementSize = sizeof(char*) + sizeof(ub1) + sizeof(char*) + sizeof(ub1) +
+            sizeof(ub1) + sizeof(OCIBind*);
+    buffer = (char*) PyMem_Malloc(numElements * elementSize);
+    if (!buffer) {
+        PyErr_NoMemory();
+        return -1;
+    }
+    bindNames = (char**) buffer;
+    bindNameLengths = (ub1*) (((char*) bindNames) +
+            sizeof(char*) * numElements);
+    indicatorNames = (char**) (((char*) bindNameLengths) +
+            sizeof(ub1) * numElements);
+    indicatorNameLengths = (ub1*) (((char*) indicatorNames) +
+            sizeof(char*) * numElements);
+    duplicate = (ub1*) (((char*) indicatorNameLengths) +
+            sizeof(ub1) * numElements);
+    bindHandles = (OCIBind**) (((char*) duplicate) +
+            sizeof(ub1) * numElements);
+
+    // get the bind information
+    status = OCIStmtGetBindInfo(self->handle,
+            self->environment->errorHandle, numElements, 1, &foundElements,
+            (text**) bindNames, bindNameLengths, (text**) indicatorNames,
+            indicatorNameLengths, duplicate, bindHandles);
+    if (status != OCI_NO_DATA &&
+            Environment_CheckForError(self->environment, status,
+            "Cursor_GetBindNames()") < 0) {
+        PyMem_Free(buffer);
+        return -1;
+    }
+    if (foundElements < 0) {
+        *names = NULL;
+        PyMem_Free(buffer);
+        return abs(foundElements);
+    }
+
+    // create the list which is to be returned
+    *names = PyList_New(0);
+    if (!*names) {
+        PyMem_Free(buffer);
+        return -1;
+    }
+
+    // process the bind information returned
+    for (i = 0; i < foundElements; i++) {
+        if (!duplicate[i]) {
+            temp = cxString_FromEncodedString(bindNames[i],
+                    bindNameLengths[i],
+                    self->connection->environment->encoding);
+            if (!temp) {
+                Py_DECREF(*names);
+                PyMem_Free(buffer);
+                return -1;
+            }
+            if (PyList_Append(*names, temp) < 0) {
+                Py_DECREF(*names);
+                Py_DECREF(temp);
+                PyMem_Free(buffer);
+                return -1;
+            }
+            Py_DECREF(temp);
+        }
+    }
+    PyMem_Free(buffer);
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_PerformDefine()
+//   Perform the defines for the cursor. At this point it is assumed that the
+// statement being executed is in fact a query.
+//-----------------------------------------------------------------------------
+static int Cursor_PerformDefine(
+    udt_Cursor *self)                   // cursor to perform define on
+{
+    int numParams, pos;
+    udt_Variable *var;
+    sword status;
+
+    // determine number of items in select-list
+    status = OCIAttrGet(self->handle, OCI_HTYPE_STMT, (dvoid*) &numParams, 0,
+            OCI_ATTR_PARAM_COUNT, self->environment->errorHandle);
+    if (Environment_CheckForError(self->environment, status,
+            "Cursor_PerformDefine()") < 0)
+        return -1;
+
+    // create a list corresponding to the number of items
+    self->fetchVariables = PyList_New(numParams);
+    if (!self->fetchVariables)
+        return -1;
+
+    // define a variable for each select-item
+    self->fetchArraySize = self->arraySize;
+    for (pos = 1; pos <= numParams; pos++) {
+        var = Variable_Define(self, self->fetchArraySize, pos);
+        if (!var)
+            return -1;
+        PyList_SET_ITEM(self->fetchVariables, pos - 1, (PyObject *) var);
+    }
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_SetRowCount()
+//   Set the rowcount variable.
+//-----------------------------------------------------------------------------
+static int Cursor_SetRowCount(
+    udt_Cursor *self)                   // cursor to set the rowcount on
+{
+    ub4 rowCount;
+    sword status;
+
+    if (self->statementType == OCI_STMT_SELECT) {
+        self->rowCount = 0;
+        self->actualRows = -1;
+        self->rowNum = 0;
+    } else if (self->statementType == OCI_STMT_INSERT ||
+               self->statementType == OCI_STMT_UPDATE ||
+               self->statementType == OCI_STMT_DELETE ||
+               self->statementType == OCI_STMT_BEGIN ||
+               self->statementType == OCI_STMT_DECLARE) {
+        status = OCIAttrGet(self->handle, OCI_HTYPE_STMT, &rowCount, 0,
+                OCI_ATTR_ROW_COUNT, self->environment->errorHandle);
+        if (Environment_CheckForError(self->environment, status,
+                "Cursor_SetRowCount()") < 0)
+            return -1;
+        self->rowCount = rowCount;
+    } else {
+        self->rowCount = -1;
+    }
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_SetErrorOffset()
+//   Set the error offset on the error object, if applicable.
+//-----------------------------------------------------------------------------
+static void Cursor_SetErrorOffset(
+    udt_Cursor *self)                   // cursor to get the error offset from
+{
+    PyObject *type, *value, *traceback;
+    udt_Error *error;
+
+    PyErr_Fetch(&type, &value, &traceback);
+    if (type == g_DatabaseErrorException) {
+        error = (udt_Error*) value;
+        OCIAttrGet(self->handle, OCI_HTYPE_STMT, &error->offset, 0,
+                OCI_ATTR_PARSE_ERROR_OFFSET, self->environment->errorHandle);
+    }
+    PyErr_Restore(type, value, traceback);
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_InternalExecute()
+//   Perform the work of executing a cursor and set the rowcount appropriately
+// regardless of whether an error takes place.
+//-----------------------------------------------------------------------------
+static int Cursor_InternalExecute(
+    udt_Cursor *self,                   // cursor to perform the execute on
+    ub4 numIters)                       // number of iterations to execute
+{
+    sword status;
+    ub4 mode;
+
+    if (self->connection->autocommit)
+        mode = OCI_COMMIT_ON_SUCCESS;
+    else mode = OCI_DEFAULT;
+
+    Py_BEGIN_ALLOW_THREADS
+    status = OCIStmtExecute(self->connection->handle, self->handle,
+            self->environment->errorHandle, numIters, 0, 0, 0, mode);
+    Py_END_ALLOW_THREADS
+    if (Environment_CheckForError(self->environment, status,
+            "Cursor_InternalExecute()") < 0) {
+        Cursor_SetErrorOffset(self);
+        if (Cursor_SetRowCount(self) < 0)
+            PyErr_Clear();
+        return -1;
+    }
+    return Cursor_SetRowCount(self);
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_GetStatementType()
+//   Determine if the cursor is executing a select statement.
+//-----------------------------------------------------------------------------
+static int Cursor_GetStatementType(
+    udt_Cursor *self)                   // cursor to perform binds on
+{
+    ub2 statementType;
+    sword status;
+
+    status = OCIAttrGet(self->handle, OCI_HTYPE_STMT,
+            (dvoid*) &statementType, 0, OCI_ATTR_STMT_TYPE,
+            self->environment->errorHandle);
+    if (Environment_CheckForError(self->environment, status,
+            "Cursor_GetStatementType()") < 0)
+        return -1;
+    self->statementType = statementType;
+    if (self->fetchVariables) {
+        Py_DECREF(self->fetchVariables);
+        self->fetchVariables = NULL;
+    }
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_FixupBoundCursor()
+//   Fixup a cursor so that fetching and returning cursor descriptions are
+// successful after binding a cursor to another cursor.
+//-----------------------------------------------------------------------------
+static int Cursor_FixupBoundCursor(
+    udt_Cursor *self)                   // cursor that may have been bound
+{
+    if (self->handle && self->statementType < 0) {
+        if (Cursor_GetStatementType(self) < 0)
+            return -1;
+        if (self->statementType == OCI_STMT_SELECT &&
+                Cursor_PerformDefine(self) < 0)
+            return -1;
+        if (Cursor_SetRowCount(self) < 0)
+            return -1;
+    }
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_ItemDescriptionHelper()
+//   Helper for Cursor_ItemDescription() used so that it is not necessary to
+// constantly free the descriptor when an error takes place.
+//-----------------------------------------------------------------------------
+static PyObject *Cursor_ItemDescriptionHelper(
+    udt_Cursor *self,                   // cursor object
+    unsigned pos,                       // position in description
+    OCIParam *param)                    // parameter to use for description
+{
+    ub2 internalSize, charSize;
+    udt_VariableType *varType;
+    int displaySize, index;
+    PyObject *tuple, *type;
+    ub4 nameLength;
+    sb2 precision;
+    sword status;
+    char *name;
+    ub1 nullOk;
+    sb1 scale;
+
+    // acquire usable type of item
+    varType = Variable_TypeByOracleDescriptor(param, self->environment);
+    if (!varType)
+        return NULL;
+
+    // acquire internal size of item
+    status = OCIAttrGet(param, OCI_HTYPE_DESCRIBE, (dvoid*) &internalSize, 0,
+            OCI_ATTR_DATA_SIZE, self->environment->errorHandle);
+    if (Environment_CheckForError(self->environment, status,
+            "Cursor_ItemDescription(): internal size") < 0)
+        return NULL;
+
+    // acquire character size of item
+    status = OCIAttrGet(param, OCI_HTYPE_DESCRIBE, (dvoid*) &charSize, 0,
+            OCI_ATTR_CHAR_SIZE, self->environment->errorHandle);
+    if (Environment_CheckForError(self->environment, status,
+            "Cursor_ItemDescription(): character size") < 0)
+        return NULL;
+
+    // aquire name of item
+    status = OCIAttrGet(param, OCI_HTYPE_DESCRIBE, (dvoid*) &name,
+            &nameLength, OCI_ATTR_NAME, self->environment->errorHandle);
+    if (Environment_CheckForError(self->environment, status,
+            "Cursor_ItemDescription(): name") < 0)
+        return NULL;
+
+    // lookup precision and scale
+    scale = 0;
+    precision = 0;
+    if (varType->pythonType == &g_NumberVarType) {
+        status = OCIAttrGet(param, OCI_HTYPE_DESCRIBE, (dvoid*) &scale, 0,
+                OCI_ATTR_SCALE, self->environment->errorHandle);
+        if (Environment_CheckForError(self->environment, status,
+                "Cursor_ItemDescription(): scale") < 0)
+            return NULL;
+        status = OCIAttrGet(param, OCI_HTYPE_DESCRIBE, (dvoid*) &precision, 0,
+                OCI_ATTR_PRECISION, self->environment->errorHandle);
+        if (Environment_CheckForError(self->environment, status,
+                "Cursor_ItemDescription(): precision") < 0)
+            return NULL;
+    }
+
+    // lookup whether null is permitted for the attribute
+    status = OCIAttrGet(param, OCI_HTYPE_DESCRIBE, (dvoid*) &nullOk, 0,
+            OCI_ATTR_IS_NULL, self->environment->errorHandle);
+    if (Environment_CheckForError(self->environment, status,
+            "Cursor_ItemDescription(): nullable") < 0)
+        return NULL;
+
+    // set display size based on data type
+    type = (PyObject*) varType->pythonType;
+    if (type == (PyObject*) &g_StringVarType)
+        displaySize = charSize;
+#if PY_MAJOR_VERSION < 3
+    else if (type == (PyObject*) &g_UnicodeVarType)
+        displaySize = charSize;
+#endif
+    else if (type == (PyObject*) &g_BinaryVarType)
+        displaySize = internalSize;
+    else if (type == (PyObject*) &g_FixedCharVarType)
+        displaySize = charSize;
+#if PY_MAJOR_VERSION < 3
+    else if (type == (PyObject*) &g_FixedUnicodeVarType)
+        displaySize = charSize;
+#endif
+    else if (type == (PyObject*) &g_NumberVarType) {
+        if (precision) {
+            displaySize = precision + 1;
+            if (scale > 0)
+                displaySize += scale + 1;
+        }
+        else displaySize = 127;
+    } else if (type == (PyObject*) &g_DateTimeVarType) {
+        displaySize = 23;
+    } else {
+        displaySize = -1;
+    }
+
+    // create the tuple and populate it
+    tuple = PyTuple_New(7);
+    if (!tuple)
+        return NULL;
+
+    // set each of the items in the tuple
+    PyTuple_SET_ITEM(tuple, 0, cxString_FromEncodedString(name, nameLength,
+            self->connection->environment->encoding));
+    Py_INCREF(type);
+    PyTuple_SET_ITEM(tuple, 1, type);
+    PyTuple_SET_ITEM(tuple, 2, PyInt_FromLong(displaySize));
+    PyTuple_SET_ITEM(tuple, 3, PyInt_FromLong(internalSize));
+    PyTuple_SET_ITEM(tuple, 4, PyInt_FromLong(precision));
+    PyTuple_SET_ITEM(tuple, 5, PyInt_FromLong(scale));
+    PyTuple_SET_ITEM(tuple, 6, PyInt_FromLong(nullOk != 0));
+
+    // make sure the tuple is ok
+    for (index = 0; index < 7; index++) {
+        if (!PyTuple_GET_ITEM(tuple, index)) {
+            Py_DECREF(tuple);
+            return NULL;
+        }
+    }
+
+    return tuple;
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_ItemDescription()
+//   Return a tuple describing the item at the given position.
+//-----------------------------------------------------------------------------
+static PyObject *Cursor_ItemDescription(
+    udt_Cursor *self,                   // cursor object
+    unsigned pos)                       // position
+{
+    PyObject *tuple;
+    OCIParam *param;
+    sword status;
+
+    // acquire parameter descriptor
+    status = OCIParamGet(self->handle, OCI_HTYPE_STMT,
+            self->environment->errorHandle, (void**) &param, pos);
+    if (Environment_CheckForError(self->environment, status,
+            "Cursor_ItemDescription(): parameter") < 0)
+        return NULL;
+
+    // use helper routine to get tuple
+    tuple = Cursor_ItemDescriptionHelper(self, pos, param);
+    OCIDescriptorFree(param, OCI_DTYPE_PARAM);
+    return tuple;
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_GetDescription()
+//   Return a list of 7-tuples consisting of the description of the define
+// variables.
+//-----------------------------------------------------------------------------
+static PyObject *Cursor_GetDescription(
+    udt_Cursor *self,                   // cursor object
+    void *arg)                          // optional argument (ignored)
+{
+    PyObject *results, *tuple;
+    int numItems, index;
+    sword status;
+
+    // make sure the cursor is open
+    if (Cursor_IsOpen(self) < 0)
+        return NULL;
+
+    // fixup bound cursor, if necessary
+    if (Cursor_FixupBoundCursor(self) < 0)
+        return NULL;
+
+    // if not a query, return None
+    if (self->statementType != OCI_STMT_SELECT) {
+        Py_INCREF(Py_None);
+        return Py_None;
+    }
+
+    // determine number of items in select-list
+    status = OCIAttrGet(self->handle, OCI_HTYPE_STMT, (dvoid*) &numItems, 0,
+            OCI_ATTR_PARAM_COUNT, self->environment->errorHandle);
+    if (Environment_CheckForError(self->environment, status,
+                "Cursor_GetDescription()") < 0)
+        return NULL;
+
+    // create a list of the required length
+    results = PyList_New(numItems);
+    if (!results)
+        return NULL;
+
+    // create tuples corresponding to the select-items
+    for (index = 0; index < numItems; index++) {
+        tuple = Cursor_ItemDescription(self, index + 1);
+        if (!tuple) {
+            Py_DECREF(results);
+            return NULL;
+        }
+        PyList_SET_ITEM(results, index, tuple);
+    }
+
+    return results;
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_Close()
+//   Close the cursor.
+//-----------------------------------------------------------------------------
+static PyObject *Cursor_Close(
+    udt_Cursor *self,                   // cursor to close
+    PyObject *args)                     // arguments
+{
+    // make sure we are actually open
+    if (Cursor_IsOpen(self) < 0)
+        return NULL;
+
+    // close the cursor
+    if (Cursor_FreeHandle(self, 1) < 0)
+        return NULL;
+
+    self->isOpen = 0;
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_SetBindVariableHelper()
+//   Helper for setting a bind variable.
+//-----------------------------------------------------------------------------
+static int Cursor_SetBindVariableHelper(
+    udt_Cursor *self,                   // cursor to perform bind on
+    unsigned numElements,               // number of elements to create
+    unsigned arrayPos,                  // array position to set
+    PyObject *value,                    // value to bind
+    udt_Variable *origVar,              // original variable bound
+    udt_Variable **newVar,              // new variable to be bound
+    int deferTypeAssignment)            // defer type assignment if null?
+{
+    int isValueVar;
+
+    // initialization
+    *newVar = NULL;
+    isValueVar = Variable_Check(value);
+
+    // handle case where variable is already bound
+    if (origVar) {
+
+        // if the value is a variable object, rebind it if necessary
+        if (isValueVar) {
+            if ( (PyObject*) origVar != value) {
+                Py_INCREF(value);
+                *newVar = (udt_Variable*) value;
+            }
+
+        // if the number of elements has changed, create a new variable
+        // this is only necessary for executemany() since execute() always
+        // passes a value of 1 for the number of elements
+        } else if (numElements > origVar->allocatedElements) {
+            *newVar = Variable_New(self, numElements, origVar->type,
+                    origVar->size);
+            if (!*newVar)
+                return -1;
+            if (Variable_SetValue(*newVar, arrayPos, value) < 0)
+                return -1;
+
+        // otherwise, attempt to set the value
+        } else if (Variable_SetValue(origVar, arrayPos, value) < 0) {
+
+            // executemany() should simply fail after the first element
+            if (arrayPos > 0)
+                return -1;
+
+            // anything other than index error or type error should fail
+            if (!PyErr_ExceptionMatches(PyExc_IndexError) &&
+                    !PyErr_ExceptionMatches(PyExc_TypeError))
+                return -1;
+
+            // clear the exception and try to create a new variable
+            PyErr_Clear();
+            origVar = NULL;
+        }
+
+    }
+
+    // if no original variable used, create a new one
+    if (!origVar) {
+
+        // if the value is a variable object, bind it directly
+        if (isValueVar) {
+            Py_INCREF(value);
+            *newVar = (udt_Variable*) value;
+            (*newVar)->boundPos = 0;
+            Py_XDECREF((*newVar)->boundName);
+            (*newVar)->boundName = NULL;
+
+        // otherwise, create a new variable, unless the value is None and
+        // we wish to defer type assignment
+        } else if (value != Py_None || !deferTypeAssignment) {
+            *newVar = Variable_NewByValue(self, value, numElements);
+            if (!*newVar)
+                return -1;
+            if (Variable_SetValue(*newVar, arrayPos, value) < 0)
+                return -1;
+        }
+
+    }
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_SetBindVariables()
+//   Create or set bind variables.
+//-----------------------------------------------------------------------------
+static int Cursor_SetBindVariables(
+    udt_Cursor *self,                   // cursor to perform binds on
+    PyObject *parameters,               // parameters to bind
+    unsigned numElements,               // number of elements to create
+    unsigned arrayPos,                  // array position to set
+    int deferTypeAssignment)            // defer type assignment if null?
+{
+    int i, origBoundByPos, origNumParams, boundByPos, numParams;
+    PyObject *key, *value, *origVar;
+    udt_Variable *newVar;
+    Py_ssize_t pos;
+
+    // make sure positional and named binds are not being intermixed
+    numParams = 0;
+    boundByPos = PySequence_Check(parameters);
+    if (boundByPos) {
+        numParams = PySequence_Size(parameters);
+        if (numParams < 0)
+            return -1;
+    }
+    if (self->bindVariables) {
+        origBoundByPos = PyList_Check(self->bindVariables);
+        if (boundByPos != origBoundByPos) {
+            PyErr_SetString(g_ProgrammingErrorException,
+                    "positional and named binds cannot be intermixed");
+            return -1;
+        }
+        origNumParams = PyList_GET_SIZE(self->bindVariables);
+
+    // otherwise, create the list or dictionary if needed
+    } else {
+        if (boundByPos)
+            self->bindVariables = PyList_New(numParams);
+        else self->bindVariables = PyDict_New();
+        if (!self->bindVariables)
+            return -1;
+        origNumParams = 0;
+    }
+
+    // handle positional binds
+    if (boundByPos) {
+        for (i = 0; i < numParams; i++) {
+            value = PySequence_GetItem(parameters, i);
+            if (!value)
+                return -1;
+            Py_DECREF(value);
+            if (i < origNumParams) {
+                origVar = PyList_GET_ITEM(self->bindVariables, i);
+                if (origVar == Py_None)
+                    origVar = NULL;
+            } else origVar = NULL;
+            if (Cursor_SetBindVariableHelper(self, numElements, arrayPos,
+                    value, (udt_Variable*) origVar, &newVar,
+                    deferTypeAssignment) < 0)
+                return -1;
+            if (newVar) {
+                if (i < PyList_GET_SIZE(self->bindVariables)) {
+                    if (PyList_SetItem(self->bindVariables, i,
+                            (PyObject*) newVar) < 0) {
+                        Py_DECREF(newVar);
+                        return -1;
+                    }
+                } else {
+                    if (PyList_Append(self->bindVariables,
+                            (PyObject*) newVar) < 0) {
+                        Py_DECREF(newVar);
+                        return -1;
+                    }
+                    Py_DECREF(newVar);
+                }
+            }
+        }
+
+    // handle named binds
+    } else {
+        pos = 0;
+        while (PyDict_Next(parameters, &pos, &key, &value)) {
+            origVar = PyDict_GetItem(self->bindVariables, key);
+            if (Cursor_SetBindVariableHelper(self, numElements, arrayPos,
+                    value, (udt_Variable*) origVar, &newVar,
+                    deferTypeAssignment) < 0)
+                return -1;
+            if (newVar) {
+                if (PyDict_SetItem(self->bindVariables, key,
+                        (PyObject*) newVar) < 0) {
+                    Py_DECREF(newVar);
+                    return -1;
+                }
+                Py_DECREF(newVar);
+            }
+        }
+    }
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_PerformBind()
+//   Perform the binds on the cursor.
+//-----------------------------------------------------------------------------
+static int Cursor_PerformBind(
+    udt_Cursor *self)                   // cursor to perform binds on
+{
+    PyObject *key, *var;
+    Py_ssize_t pos;
+    ub2 i;
+
+    // ensure that input sizes are reset
+    // this is done before binding is attempted so that if binding fails and
+    // a new statement is prepared, the bind variables will be reset and
+    // spurious errors will not occur
+    self->setInputSizes = 0;
+
+    // set values and perform binds for all bind variables
+    if (self->bindVariables) {
+        if (PyDict_Check(self->bindVariables)) {
+            pos = 0;
+            while (PyDict_Next(self->bindVariables, &pos, &key, &var)) {
+                if (Variable_Bind((udt_Variable*) var, self, key, 0) < 0)
+                    return -1;
+            }
+        } else {
+            for (i = 0; i < (ub2) PyList_GET_SIZE(self->bindVariables); i++) {
+                var = PyList_GET_ITEM(self->bindVariables, i);
+                if (var != Py_None) {
+                    if (Variable_Bind((udt_Variable*) var, self, NULL,
+                            i + 1) < 0)
+                        return -1;
+                }
+            }
+        }
+    }
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_CreateRow()
+//   Create an object for the row. The object created is a tuple unless a row
+// factory function has been defined in which case it is the result of the
+// row factory function called with the argument tuple that would otherwise be
+// returned.
+//-----------------------------------------------------------------------------
+static PyObject *Cursor_CreateRow(
+    udt_Cursor *self)                   // cursor object
+{
+    PyObject *tuple, *item, *result;
+    int numItems, pos;
+    udt_Variable *var;
+
+    // create a new tuple
+    numItems = PyList_GET_SIZE(self->fetchVariables);
+    tuple = PyTuple_New(numItems);
+    if (!tuple)
+        return NULL;
+
+    // acquire the value for each item
+    for (pos = 0; pos < numItems; pos++) {
+        var = (udt_Variable*) PyList_GET_ITEM(self->fetchVariables, pos);
+        item = Variable_GetValue(var, self->rowNum);
+        if (!item) {
+            Py_DECREF(tuple);
+            return NULL;
+        }
+        PyTuple_SET_ITEM(tuple, pos, item);
+    }
+
+    // increment row counters
+    self->rowNum++;
+    self->rowCount++;
+
+    // if a row factory is defined, call it
+    if (self->rowFactory && self->rowFactory != Py_None) {
+        result = PyObject_CallObject(self->rowFactory, tuple);
+        Py_DECREF(tuple);
+        return result;
+    }
+
+    return tuple;
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_InternalPrepare()
+//   Internal method for preparing a statement for execution.
+//-----------------------------------------------------------------------------
+static int Cursor_InternalPrepare(
+    udt_Cursor *self,                   // cursor to perform prepare on
+    PyObject *statement,                // statement to prepare
+    PyObject *statementTag)             // tag of statement to prepare
+{
+    udt_Buffer statementBuffer, tagBuffer;
+    sword status;
+
+    // make sure we don't get a situation where nothing is to be executed
+    if (statement == Py_None && !self->statement) {
+        PyErr_SetString(g_ProgrammingErrorException,
+                "no statement specified and no prior statement prepared");
+        return -1;
+    }
+
+    // nothing to do if the statement is identical to the one already stored
+    // but go ahead and prepare anyway for create, alter and drop statments
+    if (statement == Py_None || statement == self->statement) {
+        if (self->statementType != OCI_STMT_CREATE &&
+                self->statementType != OCI_STMT_DROP &&
+                self->statementType != OCI_STMT_ALTER)
+            return 0;
+        statement = self->statement;
+    }
+
+    // keep track of the statement
+    Py_XDECREF(self->statement);
+    Py_INCREF(statement);
+    self->statement = statement;
+
+    // release existing statement, if necessary
+    Py_XDECREF(self->statementTag);
+    Py_XINCREF(statementTag);
+    self->statementTag = statementTag;
+    if (Cursor_FreeHandle(self, 1) < 0)
+        return -1;
+
+    // prepare statement
+    self->isOwned = 0;
+    if (cxBuffer_FromObject(&statementBuffer, statement,
+            self->environment->encoding) < 0)
+        return -1;
+    if (cxBuffer_FromObject(&tagBuffer, statementTag,
+            self->environment->encoding) < 0) {
+        cxBuffer_Clear(&statementBuffer);
+        return -1;
+    }
+    Py_BEGIN_ALLOW_THREADS
+    status = OCIStmtPrepare2(self->connection->handle, &self->handle,
+            self->environment->errorHandle, (text*) statementBuffer.ptr,
+            statementBuffer.size, (text*) tagBuffer.ptr, tagBuffer.size,
+            OCI_NTV_SYNTAX, OCI_DEFAULT);
+    Py_END_ALLOW_THREADS
+    cxBuffer_Clear(&statementBuffer);
+    cxBuffer_Clear(&tagBuffer);
+    if (Environment_CheckForError(self->environment, status,
+            "Cursor_InternalPrepare(): prepare") < 0) {
+        // this is needed to avoid "invalid handle" errors since Oracle doesn't
+        // seem to leave the pointer alone when an error is raised but the
+        // resulting handle is still invalid
+        self->handle = NULL;
+        return -1;
+    }
+
+    // clear bind variables, if applicable
+    if (!self->setInputSizes) {
+        Py_XDECREF(self->bindVariables);
+        self->bindVariables = NULL;
+    }
+
+    // clear row factory, if spplicable
+    Py_XDECREF(self->rowFactory);
+    self->rowFactory = NULL;
+
+    // determine if statement is a query
+    if (Cursor_GetStatementType(self) < 0)
+        return -1;
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_Parse()
+//   Parse the statement without executing it. This also retrieves information
+// about the select list for select statements.
+//-----------------------------------------------------------------------------
+static PyObject *Cursor_Parse(
+    udt_Cursor *self,                   // cursor to perform parse on
+    PyObject *args)                     // arguments
+{
+    PyObject *statement;
+    sword status;
+    ub4 mode;
+
+    // statement text is expected
+    if (!PyArg_ParseTuple(args, "S", &statement))
+        return NULL;
+
+    // make sure the cursor is open
+    if (Cursor_IsOpen(self) < 0)
+        return NULL;
+
+    // prepare the statement
+    if (Cursor_InternalPrepare(self, statement, NULL) < 0)
+        return NULL;
+
+    // parse the statement
+    if (self->statementType == OCI_STMT_SELECT)
+        mode = OCI_DESCRIBE_ONLY;
+    else mode = OCI_PARSE_ONLY;
+    Py_BEGIN_ALLOW_THREADS
+    status = OCIStmtExecute(self->connection->handle, self->handle,
+            self->environment->errorHandle, 0, 0, 0, 0, mode);
+    Py_END_ALLOW_THREADS
+    if (Environment_CheckForError(self->environment, status,
+            "Cursor_Parse()") < 0)
+        return NULL;
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_Prepare()
+//   Prepare the statement for execution.
+//-----------------------------------------------------------------------------
+static PyObject *Cursor_Prepare(
+    udt_Cursor *self,                   // cursor to perform prepare on
+    PyObject *args)                     // arguments
+{
+    PyObject *statement, *statementTag;
+
+    // statement text and optional tag is expected
+    statementTag = NULL;
+    if (!PyArg_ParseTuple(args, "O|O", &statement, &statementTag))
+        return NULL;
+
+    // make sure the cursor is open
+    if (Cursor_IsOpen(self) < 0)
+        return NULL;
+
+    // prepare the statement
+    if (Cursor_InternalPrepare(self, statement, statementTag) < 0)
+        return NULL;
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_CallCalculateSize()
+//   Calculate the size of the statement that is to be executed.
+//-----------------------------------------------------------------------------
+static int Cursor_CallCalculateSize(
+    PyObject *name,                     // name of procedure/function to call
+    udt_Variable *returnValue,          // return value variable (optional)
+    PyObject *listOfArguments,          // list of positional arguments
+    PyObject *keywordArguments,         // dictionary of keyword arguments
+    int *size)                          // statement size (OUT)
+{
+    int numPositionalArgs, numKeywordArgs;
+
+    // set base size without any arguments
+    *size = 17;
+
+    // add any additional space required to handle the return value
+    if (returnValue)
+        *size += 6;
+
+    // assume up to 9 characters for each positional argument
+    // this allows up to four digits for the placeholder if the bind variale
+    // is a boolean value
+    if (listOfArguments) {
+        numPositionalArgs = PySequence_Size(listOfArguments);
+        if (numPositionalArgs < 0)
+            return -1;
+        *size += numPositionalArgs * 9;
+    }
+
+    // assume up to 15 characters for each keyword argument
+    // this allows up to four digits for the placeholder if the bind variable
+    // is a boolean value
+    if (keywordArguments) {
+        numKeywordArgs = PyDict_Size(keywordArguments);
+        if (numKeywordArgs < 0)
+            return -1;
+        *size += numKeywordArgs * 15;
+    }
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_CallBuildStatement()
+//   Determine the statement and the bind variables to bind to the statement
+// that is created for calling a stored procedure or function.
+//-----------------------------------------------------------------------------
+static int Cursor_CallBuildStatement(
+    PyObject *name,                     // name of procedure/function to call
+    udt_Variable *returnValue,          // return value variable (optional)
+    PyObject *listOfArguments,          // arguments
+    PyObject *keywordArguments,         // keyword arguments
+    char *statement,                    // allocated statement text
+    PyObject **statementObj,            // statement object (OUT)
+    PyObject **bindVariables)           // variables to bind (OUT)
+{
+    PyObject *key, *value, *format, *formatArgs, *positionalArgs, *temp;
+    int i, argNum, numPositionalArgs;
+    Py_ssize_t pos;
+    char *ptr;
+
+    // initialize the bind variables to the list of positional arguments
+    if (listOfArguments)
+        *bindVariables = PySequence_List(listOfArguments);
+    else *bindVariables = PyList_New(0);
+    if (!*bindVariables)
+        return -1;
+
+    // insert the return variable, if applicable
+    if (returnValue) {
+        if (PyList_Insert(*bindVariables, 0, (PyObject*) returnValue) < 0)
+            return -1;
+    }
+
+    // initialize format arguments
+    formatArgs = PyList_New(0);
+    if (!formatArgs)
+        return -1;
+    if (PyList_Append(formatArgs, name) < 0) {
+        Py_DECREF(formatArgs);
+        return -1;
+    }
+
+    // begin building the statement
+    argNum = 1;
+    strcpy(statement, "begin ");
+    if (returnValue) {
+        strcat(statement, ":1 := ");
+        argNum++;
+    }
+    strcat(statement, "%s");
+    ptr = statement + strlen(statement);
+    *ptr++ = '(';
+
+    // include any positional arguments first
+    if (listOfArguments) {
+        positionalArgs = PySequence_Fast(listOfArguments,
+                "expecting sequence of arguments");
+        if (!positionalArgs) {
+            Py_DECREF(formatArgs);
+            return -1;
+        }
+        numPositionalArgs = PySequence_Size(listOfArguments);
+        for (i = 0; i < numPositionalArgs; i++) {
+            if (i > 0)
+                *ptr++ = ',';
+            ptr += sprintf(ptr, ":%d", argNum++);
+            if (PyBool_Check(PySequence_Fast_GET_ITEM(positionalArgs, i)))
+                ptr += sprintf(ptr, " = 1");
+        }
+        Py_DECREF(positionalArgs);
+    }
+
+    // next append any keyword arguments
+    if (keywordArguments) {
+        pos = 0;
+        while (PyDict_Next(keywordArguments, &pos, &key, &value)) {
+            if (PyList_Append(*bindVariables, value) < 0) {
+                Py_DECREF(formatArgs);
+                return -1;
+            }
+            if (PyList_Append(formatArgs, key) < 0) {
+                Py_DECREF(formatArgs);
+                return -1;
+            }
+            if ((argNum > 1 && !returnValue) || (argNum > 2 && returnValue))
+                *ptr++ = ',';
+            ptr += sprintf(ptr, "%%s => :%d", argNum++);
+            if (PyBool_Check(value))
+                ptr += sprintf(ptr, " = 1");
+        }
+    }
+
+    // create statement object
+    strcpy(ptr, "); end;");
+    format = cxString_FromAscii(statement);
+    if (!format) {
+        Py_DECREF(formatArgs);
+        return -1;
+    }
+    temp = PyList_AsTuple(formatArgs);
+    Py_DECREF(formatArgs);
+    if (!temp) {
+        Py_DECREF(format);
+        return -1;
+    }
+    *statementObj = cxString_Format(format, temp);
+    Py_DECREF(format);
+    Py_DECREF(temp);
+    if (!*statementObj)
+        return -1;
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_Call()
+//   Call a stored procedure or function.
+//-----------------------------------------------------------------------------
+static int Cursor_Call(
+    udt_Cursor *self,                   // cursor to call procedure/function
+    udt_Variable *returnValue,          // return value variable (optional)
+    PyObject *name,                     // name of procedure/function to call
+    PyObject *listOfArguments,          // arguments
+    PyObject *keywordArguments)         // keyword arguments
+{
+    PyObject *bindVariables, *statementObj, *results;
+    int statementSize;
+    char *statement;
+
+    // verify that the arguments are passed correctly
+    if (listOfArguments) {
+        if (!PySequence_Check(listOfArguments)) {
+            PyErr_SetString(PyExc_TypeError, "arguments must be a sequence");
+            return -1;
+        }
+    }
+    if (keywordArguments) {
+        if (!PyDict_Check(keywordArguments)) {
+            PyErr_SetString(PyExc_TypeError,
+                    "keyword arguments must be a dictionary");
+            return -1;
+        }
+    }
+
+    // make sure the cursor is open
+    if (Cursor_IsOpen(self) < 0)
+        return -1;
+
+    // determine the statement size
+    if (Cursor_CallCalculateSize(name, returnValue, listOfArguments,
+            keywordArguments, &statementSize) < 0)
+        return -1;
+
+    // allocate a string for the statement
+    statement = (char*) PyMem_Malloc(statementSize);
+    if (!statement) {
+        PyErr_NoMemory();
+        return -1;
+    }
+
+    // determine the statement to execute and the argument to pass
+    bindVariables = statementObj = NULL;
+    if (Cursor_CallBuildStatement(name, returnValue, listOfArguments,
+            keywordArguments, statement, &statementObj, &bindVariables) < 0) {
+        PyMem_Free(statement);
+        Py_XDECREF(statementObj);
+        Py_XDECREF(bindVariables);
+        return -1;
+    }
+    PyMem_Free(statement);
+
+    // execute the statement on the cursor
+    results = PyObject_CallMethod( (PyObject*) self, "execute", "OO",
+            statementObj, bindVariables);
+    Py_DECREF(statementObj);
+    Py_DECREF(bindVariables);
+    if (!results)
+        return -1;
+    Py_DECREF(results);
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_CallFunc()
+//   Call a stored function and return the return value of the function.
+//-----------------------------------------------------------------------------
+static PyObject *Cursor_CallFunc(
+    udt_Cursor *self,                   // cursor to execute
+    PyObject *args,                     // arguments
+    PyObject *keywordArgs)              // keyword arguments
+{
+    static char *keywordList[] = { "name", "returnType", "parameters",
+            "keywordParameters", NULL };
+    PyObject *listOfArguments, *keywordArguments, *returnType, *results, *name;
+    udt_Variable *var;
+
+    // parse arguments
+    listOfArguments = keywordArguments = NULL;
+    if (!PyArg_ParseTupleAndKeywords(args, keywordArgs, "OO|OO", keywordList,
+            &name, &returnType, &listOfArguments, &keywordArguments))
+        return NULL;
+
+    // create the return variable
+    var = Variable_NewByType(self, returnType, 1);
+    if (!var)
+        return NULL;
+
+    // call the function
+    if (Cursor_Call(self, var, name, listOfArguments, keywordArguments) < 0)
+        return NULL;
+
+    // determine the results
+    results = Variable_GetValue(var, 0);
+    Py_DECREF(var);
+    return results;
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_CallProc()
+//   Call a stored procedure and return the (possibly modified) arguments.
+//-----------------------------------------------------------------------------
+static PyObject *Cursor_CallProc(
+    udt_Cursor *self,                   // cursor to execute
+    PyObject *args,                     // arguments
+    PyObject *keywordArgs)              // keyword arguments
+{
+    static char *keywordList[] = { "name", "parameters", "keywordParameters",
+            NULL };
+    PyObject *listOfArguments, *keywordArguments, *results, *var, *temp, *name;
+    int numArgs, i;
+
+    // parse arguments
+    listOfArguments = keywordArguments = NULL;
+    if (!PyArg_ParseTupleAndKeywords(args, keywordArgs, "O|OO", keywordList,
+            &name, &listOfArguments, &keywordArguments))
+        return NULL;
+
+    // call the stored procedure
+    if (Cursor_Call(self, NULL, name, listOfArguments, keywordArguments) < 0)
+        return NULL;
+
+    // create the return value
+    numArgs = PyList_GET_SIZE(self->bindVariables);
+    results = PyList_New(numArgs);
+    if (!results)
+        return NULL;
+    for (i = 0; i < numArgs; i++) {
+        var = PyList_GET_ITEM(self->bindVariables, i);
+        temp = Variable_GetValue((udt_Variable*) var, 0);
+        if (!temp) {
+            Py_DECREF(results);
+            return NULL;
+        }
+        PyList_SET_ITEM(results, i, temp);
+    }
+
+    return results;
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_Execute()
+//   Execute the statement.
+//-----------------------------------------------------------------------------
+static PyObject *Cursor_Execute(
+    udt_Cursor *self,                   // cursor to execute
+    PyObject *args,                     // arguments
+    PyObject *keywordArgs)              // keywords
+{
+    PyObject *statement, *executeArgs;
+    int isQuery;
+
+    executeArgs = NULL;
+    if (!PyArg_ParseTuple(args, "O|O", &statement, &executeArgs))
+        return NULL;
+    if (executeArgs && keywordArgs) {
+        if (PyDict_Size(keywordArgs) == 0)
+            keywordArgs = NULL;
+        else {
+            PyErr_SetString(g_InterfaceErrorException,
+                    "expecting argument or keyword arguments, not both");
+            return NULL;
+        }
+    }
+    if (keywordArgs)
+        executeArgs = keywordArgs;
+    if (executeArgs) {
+        if (!PyDict_Check(executeArgs) && !PySequence_Check(executeArgs)) {
+            PyErr_SetString(PyExc_TypeError,
+                    "expecting a dictionary, sequence or keyword args");
+            return NULL;
+        }
+    }
+
+    // make sure the cursor is open
+    if (Cursor_IsOpen(self) < 0)
+        return NULL;
+
+    // prepare the statement, if applicable
+    if (Cursor_InternalPrepare(self, statement, NULL) < 0)
+        return NULL;
+
+    // perform binds
+    if (executeArgs && Cursor_SetBindVariables(self, executeArgs, 1, 0,
+            0) < 0)
+        return NULL;
+    if (Cursor_PerformBind(self) < 0)
+        return NULL;
+
+    // execute the statement
+    isQuery = (self->statementType == OCI_STMT_SELECT);
+    if (Cursor_InternalExecute(self, isQuery ? 0 : 1) < 0)
+        return NULL;
+
+    // perform defines, if necessary
+    if (isQuery && !self->fetchVariables && Cursor_PerformDefine(self) < 0)
+        return NULL;
+
+    // reset the values of setoutputsize()
+    self->outputSize = -1;
+    self->outputSizeColumn = -1;
+
+    // for queries, return the cursor for convenience
+    if (isQuery) {
+        Py_INCREF(self);
+        return (PyObject*) self;
+    }
+
+    // for all other statements, simply return None
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_ExecuteMany()
+//   Execute the statement many times. The number of times is equivalent to the
+// number of elements in the array of dictionaries.
+//-----------------------------------------------------------------------------
+static PyObject *Cursor_ExecuteMany(
+    udt_Cursor *self,                   // cursor to execute
+    PyObject *args)                     // arguments
+{
+    PyObject *arguments, *listOfArguments, *statement;
+    int i, numRows;
+
+    // expect statement text (optional) plus list of mappings
+    if (!PyArg_ParseTuple(args, "OO!", &statement, &PyList_Type,
+            &listOfArguments))
+        return NULL;
+
+    // make sure the cursor is open
+    if (Cursor_IsOpen(self) < 0)
+        return NULL;
+
+    // prepare the statement
+    if (Cursor_InternalPrepare(self, statement, NULL) < 0)
+        return NULL;
+
+    // queries are not supported as the result is undefined
+    if (self->statementType == OCI_STMT_SELECT) {
+        PyErr_SetString(g_NotSupportedErrorException,
+                "queries not supported: results undefined");
+        return NULL;
+    }
+
+    // perform binds
+    numRows = PyList_GET_SIZE(listOfArguments);
+    for (i = 0; i < numRows; i++) {
+        arguments = PyList_GET_ITEM(listOfArguments, i);
+        if (!PyDict_Check(arguments) && !PySequence_Check(arguments)) {
+            PyErr_SetString(g_InterfaceErrorException,
+                    "expecting a list of dictionaries or sequences");
+            return NULL;
+        }
+        if (Cursor_SetBindVariables(self, arguments, numRows, i,
+                (i < numRows - 1)) < 0)
+            return NULL;
+    }
+    if (Cursor_PerformBind(self) < 0)
+        return NULL;
+
+    // execute the statement, but only if the number of rows is greater than
+    // zero since Oracle raises an error otherwise
+    if (numRows > 0) {
+        if (Cursor_InternalExecute(self, numRows) < 0)
+            return NULL;
+    }
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_ExecuteManyPrepared()
+//   Execute the prepared statement the number of times requested. At this
+// point, the statement must have been already prepared and the bind variables
+// must have their values set.
+//-----------------------------------------------------------------------------
+static PyObject *Cursor_ExecuteManyPrepared(
+    udt_Cursor *self,                   // cursor to execute
+    PyObject *args)                     // arguments
+{
+    int numIters;
+
+    // expect number of times to execute the statement
+    if (!PyArg_ParseTuple(args, "i", &numIters))
+        return NULL;
+    if (numIters > self->bindArraySize) {
+        PyErr_SetString(g_InterfaceErrorException,
+                "iterations exceed bind array size");
+        return NULL;
+    }
+
+    // make sure the cursor is open
+    if (Cursor_IsOpen(self) < 0)
+        return NULL;
+
+    // queries are not supported as the result is undefined
+    if (self->statementType == OCI_STMT_SELECT) {
+        PyErr_SetString(g_NotSupportedErrorException,
+                "queries not supported: results undefined");
+        return NULL;
+    }
+
+    // perform binds
+    if (Cursor_PerformBind(self) < 0)
+        return NULL;
+
+    // execute the statement
+    if (Cursor_InternalExecute(self, numIters) < 0)
+        return NULL;
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_VerifyFetch()
+//   Verify that fetching may happen from this cursor.
+//-----------------------------------------------------------------------------
+static int Cursor_VerifyFetch(
+    udt_Cursor *self)                   // cursor to fetch from
+{
+    // make sure the cursor is open
+    if (Cursor_IsOpen(self) < 0)
+        return -1;
+
+    // fixup bound cursor, if necessary
+    if (Cursor_FixupBoundCursor(self) < 0)
+        return -1;
+
+    // make sure the cursor is for a query
+    if (self->statementType != OCI_STMT_SELECT) {
+        PyErr_SetString(g_InterfaceErrorException, "not a query");
+        return -1;
+    }
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_InternalFetch()
+//   Performs the actual fetch from Oracle.
+//-----------------------------------------------------------------------------
+static int Cursor_InternalFetch(
+    udt_Cursor *self,                   // cursor to fetch from
+    int numRows)                        // number of rows to fetch
+{
+    udt_Variable *var;
+    sword status;
+    ub4 rowCount;
+    int i;
+
+    if (!self->fetchVariables) {
+        PyErr_SetString(g_InterfaceErrorException, "query not executed");
+        return -1;
+    }
+    for (i = 0; i < PyList_GET_SIZE(self->fetchVariables); i++) {
+        var = (udt_Variable*) PyList_GET_ITEM(self->fetchVariables, i);
+        var->internalFetchNum++;
+        if (var->type->preFetchProc) {
+            if ((*var->type->preFetchProc)(var) < 0)
+                return -1;
+        }
+    }
+    Py_BEGIN_ALLOW_THREADS
+    status = OCIStmtFetch(self->handle, self->environment->errorHandle,
+            numRows, OCI_FETCH_NEXT, OCI_DEFAULT);
+    Py_END_ALLOW_THREADS
+    if (status != OCI_NO_DATA) {
+        if (Environment_CheckForError(self->environment, status,
+                "Cursor_InternalFetch(): fetch") < 0)
+            return -1;
+    }
+    status = OCIAttrGet(self->handle, OCI_HTYPE_STMT, &rowCount, 0,
+            OCI_ATTR_ROW_COUNT, self->environment->errorHandle);
+    if (Environment_CheckForError(self->environment, status,
+            "Cursor_InternalFetch(): row count") < 0)
+        return -1;
+    self->actualRows = rowCount - self->rowCount;
+    self->rowNum = 0;
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_MoreRows()
+//   Returns an integer indicating if more rows can be retrieved from the
+// cursor.
+//-----------------------------------------------------------------------------
+static int Cursor_MoreRows(
+    udt_Cursor *self)                   // cursor to fetch from
+{
+    if (self->rowNum >= self->actualRows) {
+        if (self->actualRows < 0 || self->actualRows == self->fetchArraySize) {
+            if (Cursor_InternalFetch(self, self->fetchArraySize) < 0)
+                return -1;
+        }
+        if (self->rowNum >= self->actualRows)
+            return 0;
+    }
+    return 1;
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_MultiFetch()
+//   Return a list consisting of the remaining rows up to the given row limit
+// (if specified).
+//-----------------------------------------------------------------------------
+static PyObject *Cursor_MultiFetch(
+    udt_Cursor *self,                   // cursor to fetch from
+    int rowLimit)                       // row limit
+{
+    PyObject *results, *row;
+    int rowNum, status;
+
+    // create an empty list
+    results = PyList_New(0);
+    if (!results)
+        return NULL;
+
+    // fetch as many rows as possible
+    for (rowNum = 0; rowLimit == 0 || rowNum < rowLimit; rowNum++) {
+        status = Cursor_MoreRows(self);
+        if (status < 0) {
+            Py_DECREF(results);
+            return NULL;
+        } else if (status == 0) {
+            break;
+        } else {
+            row = Cursor_CreateRow(self);
+            if (!row) {
+                Py_DECREF(results);
+                return NULL;
+            }
+            if (PyList_Append(results, row) < 0) {
+                Py_DECREF(row);
+                Py_DECREF(results);
+                return NULL;
+            }
+            Py_DECREF(row);
+        }
+    }
+
+    return results;
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_FetchOne()
+//   Fetch a single row from the cursor.
+//-----------------------------------------------------------------------------
+static PyObject *Cursor_FetchOne(
+    udt_Cursor *self,                   // cursor to fetch from
+    PyObject *args)                     // arguments
+{
+    int status;
+
+    // verify fetch can be performed
+    if (Cursor_VerifyFetch(self) < 0)
+        return NULL;
+
+    // setup return value
+    status = Cursor_MoreRows(self);
+    if (status < 0)
+        return NULL;
+    else if (status > 0)
+        return Cursor_CreateRow(self);
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_FetchMany()
+//   Fetch multiple rows from the cursor based on the arraysize.
+//-----------------------------------------------------------------------------
+static PyObject *Cursor_FetchMany(
+    udt_Cursor *self,                   // cursor to fetch from
+    PyObject *args,                     // arguments
+    PyObject *keywordArgs)              // keyword arguments
+{
+    static char *keywordList[] = { "numRows", NULL };
+    int rowLimit;
+
+    // parse arguments -- optional rowlimit expected
+    rowLimit = self->arraySize;
+    if (!PyArg_ParseTupleAndKeywords(args, keywordArgs, "|i", keywordList,
+            &rowLimit))
+        return NULL;
+
+    // verify fetch can be performed
+    if (Cursor_VerifyFetch(self) < 0)
+        return NULL;
+
+    return Cursor_MultiFetch(self, rowLimit);
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_FetchAll()
+//   Fetch all remaining rows from the cursor.
+//-----------------------------------------------------------------------------
+static PyObject *Cursor_FetchAll(
+    udt_Cursor *self,                   // cursor to fetch from
+    PyObject *args)                     // arguments
+{
+    if (Cursor_VerifyFetch(self) < 0)
+        return NULL;
+    return Cursor_MultiFetch(self, 0);
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_FetchRaw()
+//   Perform raw fetch on the cursor; return the actual number of rows fetched.
+//-----------------------------------------------------------------------------
+static PyObject *Cursor_FetchRaw(
+    udt_Cursor *self,                   // cursor to fetch from
+    PyObject *args,                     // arguments
+    PyObject *keywordArgs)              // keyword arguments
+{
+    static char *keywordList[] = { "numRows", NULL };
+    int numRowsToFetch, numRowsFetched;
+
+    // expect an optional number of rows to retrieve
+    numRowsToFetch = self->fetchArraySize;
+    if (!PyArg_ParseTupleAndKeywords(args, keywordArgs, "|i", keywordList,
+            &numRowsToFetch))
+        return NULL;
+    if (numRowsToFetch > self->fetchArraySize) {
+        PyErr_SetString(g_InterfaceErrorException,
+                "rows to fetch exceeds array size");
+        return NULL;
+    }
+
+    // do not attempt to perform fetch if no more rows to fetch
+    if (self->actualRows > 0 && self->actualRows < self->fetchArraySize)
+        return PyInt_FromLong(0);
+
+    // perform internal fetch
+    if (Cursor_InternalFetch(self, numRowsToFetch) < 0)
+        return NULL;
+
+    self->rowCount += self->actualRows;
+    numRowsFetched = self->actualRows;
+    if (self->actualRows == numRowsToFetch)
+        self->actualRows = -1;
+    return PyInt_FromLong(numRowsFetched);
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_SetInputSizes()
+//   Set the sizes of the bind variables.
+//-----------------------------------------------------------------------------
+static PyObject *Cursor_SetInputSizes(
+    udt_Cursor *self,                   // cursor to fetch from
+    PyObject *args,                     // arguments
+    PyObject *keywordArgs)              // keyword arguments
+{
+    int numPositionalArgs;
+    PyObject *key, *value;
+    udt_Variable *var;
+    Py_ssize_t i;
+
+    // only expect keyword arguments or positional arguments, not both
+    numPositionalArgs = PyTuple_Size(args);
+    if (keywordArgs && numPositionalArgs > 0) {
+        PyErr_SetString(g_InterfaceErrorException,
+                "expecting arguments or keyword arguments, not both");
+        return NULL;
+    }
+
+    // make sure the cursor is open
+    if (Cursor_IsOpen(self) < 0)
+        return NULL;
+
+    // eliminate existing bind variables
+    Py_XDECREF(self->bindVariables);
+    if (keywordArgs)
+        self->bindVariables = PyDict_New();
+    else self->bindVariables = PyList_New(numPositionalArgs);
+    if (!self->bindVariables)
+        return NULL;
+    self->setInputSizes = 1;
+
+    // process each input
+    if (keywordArgs) {
+        i = 0;
+        while (PyDict_Next(keywordArgs, &i, &key, &value)) {
+            var = Variable_NewByType(self, value, self->bindArraySize);
+            if (!var)
+                return NULL;
+            if (PyDict_SetItem(self->bindVariables, key,
+                    (PyObject*) var) < 0) {
+                Py_DECREF(var);
+                return NULL;
+            }
+            Py_DECREF(var);
+        }
+    } else {
+        for (i = 0; i < numPositionalArgs; i++) {
+            value = PyTuple_GET_ITEM(args, i);
+            if (value == Py_None) {
+                Py_INCREF(Py_None);
+                PyList_SET_ITEM(self->bindVariables, i, Py_None);
+            } else {
+                var = Variable_NewByType(self, value, self->bindArraySize);
+                if (!var)
+                    return NULL;
+                PyList_SET_ITEM(self->bindVariables, i, (PyObject*) var);
+            }
+        }
+    }
+
+    Py_INCREF(self->bindVariables);
+    return self->bindVariables;
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_SetOutputSize()
+//   Set the size of all of the long columns or just one of them.
+//-----------------------------------------------------------------------------
+static PyObject *Cursor_SetOutputSize(
+    udt_Cursor *self,                   // cursor to fetch from
+    PyObject *args)                     // arguments
+{
+    self->outputSizeColumn = -1;
+    if (!PyArg_ParseTuple(args, "i|i", &self->outputSize,
+            &self->outputSizeColumn))
+        return NULL;
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_Var()
+//   Create a bind variable and return it.
+//-----------------------------------------------------------------------------
+static PyObject *Cursor_Var(
+    udt_Cursor *self,                   // cursor to fetch from
+    PyObject *args,                     // arguments
+    PyObject *keywordArgs)              // keyword arguments
+{
+    static char *keywordList[] = { "type", "size", "arraysize",
+            "inconverter", "outconverter", "typename", NULL };
+    PyObject *inConverter, *outConverter, *typeNameObj;
+    udt_VariableType *varType;
+    udt_ObjectVar *objectVar;
+    int size, arraySize;
+    udt_Variable *var;
+    PyObject *type;
+
+    // parse arguments
+    size = 0;
+    arraySize = self->bindArraySize;
+    inConverter = outConverter = typeNameObj = NULL;
+    if (!PyArg_ParseTupleAndKeywords(args, keywordArgs, "O|iiOOO", keywordList,
+            &type, &size, &arraySize, &inConverter, &outConverter,
+            &typeNameObj))
+        return NULL;
+
+    // determine the type of variable
+    varType = Variable_TypeByPythonType(self, type);
+    if (!varType)
+        return NULL;
+    if (varType->isVariableLength && size == 0)
+        size = varType->size;
+    if (type == (PyObject*) &g_ObjectVarType && !typeNameObj) {
+        PyErr_SetString(PyExc_TypeError,
+                "expecting type name for object variables");
+        return NULL;
+    }
+
+    // create the variable
+    var = Variable_New(self, arraySize, varType, size);
+    if (!var)
+        return NULL;
+    Py_XINCREF(inConverter);
+    var->inConverter = inConverter;
+    Py_XINCREF(outConverter);
+    var->outConverter = outConverter;
+
+    // define the object type if needed
+    if (type == (PyObject*) &g_ObjectVarType) {
+        objectVar = (udt_ObjectVar*) var;
+        objectVar->objectType = ObjectType_NewByName(self->connection,
+                typeNameObj);
+        if (!objectVar->objectType) {
+            Py_DECREF(var);
+            return NULL;
+        }
+    }
+
+    return (PyObject*) var;
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_ArrayVar()
+//   Create an array bind variable and return it.
+//-----------------------------------------------------------------------------
+static PyObject *Cursor_ArrayVar(
+    udt_Cursor *self,                   // cursor to fetch from
+    PyObject *args)                     // arguments
+{
+    udt_VariableType *varType;
+    PyObject *type, *value;
+    int size, numElements;
+    udt_Variable *var;
+
+    // parse arguments
+    size = 0;
+    if (!PyArg_ParseTuple(args, "OO|i", &type, &value, &size))
+        return NULL;
+
+    // determine the type of variable
+    varType = Variable_TypeByPythonType(self, type);
+    if (!varType)
+        return NULL;
+    if (varType->isVariableLength && size == 0)
+        size = varType->size;
+
+    // determine the number of elements to create
+    if (PyList_Check(value))
+        numElements = PyList_GET_SIZE(value);
+    else if (PyInt_Check(value)) {
+        numElements = PyInt_AsLong(value);
+        if (PyErr_Occurred())
+            return NULL;
+    } else {
+        PyErr_SetString(PyExc_TypeError,
+                "expecting integer or list of values");
+        return NULL;
+    }
+
+    // create the variable
+    var = Variable_New(self, numElements, varType, size);
+    if (!var)
+        return NULL;
+    if (Variable_MakeArray(var) < 0) {
+        Py_DECREF(var);
+        return NULL;
+    }
+
+    // set the value, if applicable
+    if (PyList_Check(value)) {
+        if (Variable_SetArrayValue(var, value) < 0)
+            return NULL;
+    }
+
+    return (PyObject*) var;
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_BindNames()
+//   Return a list of bind variable names.
+//-----------------------------------------------------------------------------
+static PyObject *Cursor_BindNames(
+    udt_Cursor *self,                   // cursor to fetch from
+    PyObject *args)                     // arguments
+{
+    PyObject *names;
+    int result;
+
+    // make sure the cursor is open
+    if (Cursor_IsOpen(self) < 0)
+        return NULL;
+
+    // return result
+    result = Cursor_GetBindNames(self, 8, &names);
+    if (result < 0)
+        return NULL;
+    if (!names && Cursor_GetBindNames(self, result, &names) < 0)
+        return NULL;
+    return names;
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_GetIter()
+//   Return a reference to the cursor which supports the iterator protocol.
+//-----------------------------------------------------------------------------
+static PyObject *Cursor_GetIter(
+    udt_Cursor *self)                   // cursor
+{
+    if (Cursor_VerifyFetch(self) < 0)
+        return NULL;
+    Py_INCREF(self);
+    return (PyObject*) self;
+}
+
+
+//-----------------------------------------------------------------------------
+// Cursor_GetNext()
+//   Return a reference to the cursor which supports the iterator protocol.
+//-----------------------------------------------------------------------------
+static PyObject *Cursor_GetNext(
+    udt_Cursor *self)                   // cursor
+{
+    int status;
+
+    if (Cursor_VerifyFetch(self) < 0)
+        return NULL;
+    status = Cursor_MoreRows(self);
+    if (status < 0)
+        return NULL;
+    else if (status > 0)
+        return Cursor_CreateRow(self);
+
+    // no more rows, return NULL without setting an exception
+    return NULL;
+}
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/CursorVar.c b/desktop/core/ext-py/cx_Oracle-5.1.2/CursorVar.c
new file mode 100644
index 0000000..08448a1
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/CursorVar.c
@@ -0,0 +1,172 @@
+//-----------------------------------------------------------------------------
+// CursorVar.c
+//   Defines the routines specific to the cursor type.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// Cursor variable type
+//-----------------------------------------------------------------------------
+typedef struct {
+    Variable_HEAD
+    OCIStmt **data;
+    udt_Connection *connection;
+    PyObject *cursors;
+} udt_CursorVar;
+
+
+//-----------------------------------------------------------------------------
+// Declaration of cursor variable functions.
+//-----------------------------------------------------------------------------
+static int CursorVar_Initialize(udt_CursorVar*, udt_Cursor*);
+static void CursorVar_Finalize(udt_CursorVar*);
+static int CursorVar_SetValue(udt_CursorVar*, unsigned, PyObject*);
+static PyObject *CursorVar_GetValue(udt_CursorVar*, unsigned);
+
+
+//-----------------------------------------------------------------------------
+// Python type declarations
+//-----------------------------------------------------------------------------
+static PyTypeObject g_CursorVarType = {
+    PyVarObject_HEAD_INIT(NULL, 0)
+    "cx_Oracle.CURSOR",                 // tp_name
+    sizeof(udt_CursorVar),              // tp_basicsize
+    0,                                  // tp_itemsize
+    0,                                  // tp_dealloc
+    0,                                  // tp_print
+    0,                                  // tp_getattr
+    0,                                  // tp_setattr
+    0,                                  // tp_compare
+    0,                                  // tp_repr
+    0,                                  // tp_as_number
+    0,                                  // tp_as_sequence
+    0,                                  // tp_as_mapping
+    0,                                  // tp_hash
+    0,                                  // tp_call
+    0,                                  // tp_str
+    0,                                  // tp_getattro
+    0,                                  // tp_setattro
+    0,                                  // tp_as_buffer
+    Py_TPFLAGS_DEFAULT,                 // tp_flags
+    0                                   // tp_doc
+};
+
+
+//-----------------------------------------------------------------------------
+// variable type declarations
+//-----------------------------------------------------------------------------
+static udt_VariableType vt_Cursor = {
+    (InitializeProc) CursorVar_Initialize,
+    (FinalizeProc) CursorVar_Finalize,
+    (PreDefineProc) NULL,
+    (PostDefineProc) NULL,
+    (PreFetchProc) NULL,
+    (IsNullProc) NULL,
+    (SetValueProc) CursorVar_SetValue,
+    (GetValueProc) CursorVar_GetValue,
+    (GetBufferSizeProc) NULL,
+    &g_CursorVarType,                   // Python type
+    SQLT_RSET,                          // Oracle type
+    SQLCS_IMPLICIT,                     // charset form
+    sizeof(OCIStmt*),                   // element length
+    0,                                  // is character data
+    0,                                  // is variable length
+    0,                                  // can be copied
+    0                                   // can be in array
+};
+
+
+//-----------------------------------------------------------------------------
+// CursorVar_Initialize()
+//   Initialize the variable.
+//-----------------------------------------------------------------------------
+static int CursorVar_Initialize(
+    udt_CursorVar *var,                 // variable to initialize
+    udt_Cursor *cursor)                 // cursor created by
+{
+    udt_Cursor *tempCursor;
+    ub4 i;
+
+    Py_INCREF(cursor->connection);
+    var->connection = cursor->connection;
+    var->cursors = PyList_New(var->allocatedElements);
+    if (!var->cursors)
+        return -1;
+    for (i = 0; i < var->allocatedElements; i++) {
+        tempCursor = (udt_Cursor*) Connection_NewCursor(var->connection, NULL);
+        if (!tempCursor) {
+            Py_DECREF(var);
+            return -1;
+        }
+        PyList_SET_ITEM(var->cursors, i, (PyObject*) tempCursor);
+        if (Cursor_AllocateHandle(tempCursor) < 0) {
+            Py_DECREF(var);
+            return -1;
+        }
+        var->data[i] = tempCursor->handle;
+    }
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// CursorVar_Finalize()
+//   Prepare for variable destruction.
+//-----------------------------------------------------------------------------
+static void CursorVar_Finalize(
+    udt_CursorVar *var)                 // variable to free
+{
+    Py_DECREF(var->connection);
+    Py_XDECREF(var->cursors);
+}
+
+
+//-----------------------------------------------------------------------------
+// CursorVar_SetValue()
+//   Set the value of the variable.
+//-----------------------------------------------------------------------------
+static int CursorVar_SetValue(
+    udt_CursorVar *var,                 // variable to set value for
+    unsigned pos,                       // array position to set
+    PyObject *value)                    // value to set
+{
+    udt_Cursor *cursor;
+
+    if (!PyObject_IsInstance(value, (PyObject*) &g_CursorType)) {
+        PyErr_SetString(PyExc_TypeError, "expecting cursor");
+        return -1;
+    }
+
+    Py_XDECREF(PyList_GET_ITEM(var->cursors, pos));
+    Py_INCREF(value);
+    PyList_SET_ITEM(var->cursors, pos, value);
+    cursor = (udt_Cursor *) value;
+    if (!cursor->isOwned) {
+        if (Cursor_FreeHandle(cursor, 1) < 0)
+            return -1;
+        cursor->isOwned = 1;
+        if (Cursor_AllocateHandle(cursor) < 0)
+            return -1;
+    }
+    var->data[pos] = cursor->handle;
+    cursor->statementType = -1;
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// CursorVar_GetValue()
+//   Set the value of the variable.
+//-----------------------------------------------------------------------------
+static PyObject *CursorVar_GetValue(
+    udt_CursorVar *var,                 // variable to set value for
+    unsigned pos)                       // array position to set
+{
+    PyObject *cursor;
+
+    cursor = PyList_GET_ITEM(var->cursors, pos);
+    ((udt_Cursor*) cursor)->statementType = -1;
+    Py_INCREF(cursor);
+    return cursor;
+}
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/DateTimeVar.c b/desktop/core/ext-py/cx_Oracle-5.1.2/DateTimeVar.c
new file mode 100644
index 0000000..a1bf6b2
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/DateTimeVar.c
@@ -0,0 +1,142 @@
+//-----------------------------------------------------------------------------
+// DateTimeVar.c
+//   Defines the routines for handling date (time) variables.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// DateTime type
+//-----------------------------------------------------------------------------
+typedef struct {
+    Variable_HEAD
+    OCIDate *data;
+} udt_DateTimeVar;
+
+
+//-----------------------------------------------------------------------------
+// Declaration of date/time variable functions.
+//-----------------------------------------------------------------------------
+static int DateTimeVar_SetValue(udt_DateTimeVar*, unsigned, PyObject*);
+static PyObject *DateTimeVar_GetValue(udt_DateTimeVar*, unsigned);
+
+
+//-----------------------------------------------------------------------------
+// Python type declarations
+//-----------------------------------------------------------------------------
+static PyTypeObject g_DateTimeVarType = {
+    PyVarObject_HEAD_INIT(NULL, 0)
+    "cx_Oracle.DATETIME",               // tp_name
+    sizeof(udt_DateTimeVar),            // tp_basicsize
+    0,                                  // tp_itemsize
+    0,                                  // tp_dealloc
+    0,                                  // tp_print
+    0,                                  // tp_getattr
+    0,                                  // tp_setattr
+    0,                                  // tp_compare
+    0,                                  // tp_repr
+    0,                                  // tp_as_number
+    0,                                  // tp_as_sequence
+    0,                                  // tp_as_mapping
+    0,                                  // tp_hash
+    0,                                  // tp_call
+    0,                                  // tp_str
+    0,                                  // tp_getattro
+    0,                                  // tp_setattro
+    0,                                  // tp_as_buffer
+    Py_TPFLAGS_DEFAULT,                 // tp_flags
+    0                                   // tp_doc
+};
+
+
+//-----------------------------------------------------------------------------
+// variable type declarations
+//-----------------------------------------------------------------------------
+static udt_VariableType vt_DateTime = {
+    (InitializeProc) NULL,
+    (FinalizeProc) NULL,
+    (PreDefineProc) NULL,
+    (PostDefineProc) NULL,
+    (PreFetchProc) NULL,
+    (IsNullProc) NULL,
+    (SetValueProc) DateTimeVar_SetValue,
+    (GetValueProc) DateTimeVar_GetValue,
+    (GetBufferSizeProc) NULL,
+    &g_DateTimeVarType,                 // Python type
+    SQLT_ODT,                           // Oracle type
+    SQLCS_IMPLICIT,                     // charset form
+    sizeof(OCIDate),                    // element length (default)
+    0,                                  // is character data
+    0,                                  // is variable length
+    1,                                  // can be copied
+    1                                   // can be in array
+};
+
+
+static udt_VariableType vt_Date = {
+    (InitializeProc) NULL,
+    (FinalizeProc) NULL,
+    (PreDefineProc) NULL,
+    (PostDefineProc) NULL,
+    (PreFetchProc) NULL,
+    (IsNullProc) NULL,
+    (SetValueProc) DateTimeVar_SetValue,
+    (GetValueProc) DateTimeVar_GetValue,
+    (GetBufferSizeProc) NULL,
+    &g_DateTimeVarType,                 // Python type
+    SQLT_ODT,                           // Oracle type
+    SQLCS_IMPLICIT,                     // charset form
+    sizeof(OCIDate),                    // element length (default)
+    0,                                  // is character data
+    0,                                  // is variable length
+    1,                                  // can be copied
+    1                                   // can be in array
+};
+
+
+//-----------------------------------------------------------------------------
+// DateTimeVar_SetValue()
+//   Set the value of the variable.
+//-----------------------------------------------------------------------------
+static int DateTimeVar_SetValue(
+    udt_DateTimeVar *var,               // variable to set value for
+    unsigned pos,                       // array position to set
+    PyObject *value)                    // value to set
+{
+    ub1 month, day, hour, minute, second;
+    short year;
+
+    if (PyDateTime_Check(value)) {
+        year = (short) PyDateTime_GET_YEAR(value);
+        month = PyDateTime_GET_MONTH(value);
+        day = PyDateTime_GET_DAY(value);
+        hour = PyDateTime_DATE_GET_HOUR(value);
+        minute = PyDateTime_DATE_GET_MINUTE(value);
+        second = PyDateTime_DATE_GET_SECOND(value);
+    } else if (PyDate_Check(value)) {
+        year = (short) PyDateTime_GET_YEAR(value);
+        month = PyDateTime_GET_MONTH(value);
+        day = PyDateTime_GET_DAY(value);
+        hour = minute = second = 0;
+    } else {
+        PyErr_SetString(PyExc_TypeError, "expecting date data");
+        return -1;
+    }
+
+    // store a copy of the value
+    OCIDateSetDate(&var->data[pos], year, month, day);
+    OCIDateSetTime(&var->data[pos], hour, minute, second);
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// DateTimeVar_GetValue()
+//   Returns the value stored at the given array position.
+//-----------------------------------------------------------------------------
+static PyObject *DateTimeVar_GetValue(
+    udt_DateTimeVar *var,               // variable to determine value for
+    unsigned pos)                       // array position
+{
+    return OracleDateToPythonDate(var->type, &var->data[pos]);
+}
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/Environment.c b/desktop/core/ext-py/cx_Oracle-5.1.2/Environment.c
new file mode 100644
index 0000000..35fdd0a
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/Environment.c
@@ -0,0 +1,404 @@
+//-----------------------------------------------------------------------------
+// Environment.c
+//   Environment handling.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// structure for the Python type
+//-----------------------------------------------------------------------------
+typedef struct {
+    PyObject_HEAD
+    OCIEnv *handle;
+    OCIError *errorHandle;
+    int maxBytesPerCharacter;
+    int fixedWidth;
+    char *encoding;
+    char *nencoding;
+    ub4 maxStringBytes;
+    PyObject *cloneEnv;
+    udt_Buffer numberToStringFormatBuffer;
+    udt_Buffer numberFromStringFormatBuffer;
+    udt_Buffer nlsNumericCharactersBuffer;
+} udt_Environment;
+
+//-----------------------------------------------------------------------------
+// maximum number of characters/bytes applicable to strings/binaries
+//-----------------------------------------------------------------------------
+#define MAX_STRING_CHARS                4000
+#define MAX_BINARY_BYTES                4000
+
+//-----------------------------------------------------------------------------
+// forward declarations
+//-----------------------------------------------------------------------------
+static void Environment_Free(udt_Environment*);
+static int Environment_CheckForError(udt_Environment*, sword, const char*);
+
+//-----------------------------------------------------------------------------
+// declaration of Python type
+//-----------------------------------------------------------------------------
+static PyTypeObject g_EnvironmentType = {
+    PyVarObject_HEAD_INIT(NULL, 0)
+    "OracleEnvironment",                // tp_name
+    sizeof(udt_Environment),            // tp_basicsize
+    0,                                  // tp_itemsize
+    (destructor) Environment_Free,      // tp_dealloc
+    0,                                  // tp_print
+    0,                                  // tp_getattr
+    0,                                  // tp_setattr
+    0,                                  // tp_compare
+    0,                                  // tp_repr
+    0,                                  // tp_as_number
+    0,                                  // tp_as_sequence
+    0,                                  // tp_as_mapping
+    0,                                  // tp_hash
+    0,                                  // tp_call
+    0,                                  // tp_str
+    0,                                  // tp_getattro
+    0,                                  // tp_setattro
+    0,                                  // tp_as_buffer
+    Py_TPFLAGS_DEFAULT,                 // tp_flags
+    0                                   // tp_doc
+};
+
+
+#include "Error.c"
+
+
+//-----------------------------------------------------------------------------
+// Environment_New()
+//   Create a new environment object.
+//-----------------------------------------------------------------------------
+static udt_Environment *Environment_New(
+    OCIEnv *handle)                     // handle to use
+{
+    udt_Environment *env;
+    sword status;
+
+    // create a new object for the Oracle environment
+    env = (udt_Environment*) g_EnvironmentType.tp_alloc(&g_EnvironmentType, 0);
+    if (!env)
+        return NULL;
+    env->handle = NULL;
+    env->errorHandle = NULL;
+    env->fixedWidth = 1;
+    env->maxBytesPerCharacter = 1;
+    env->maxStringBytes = MAX_STRING_CHARS;
+    env->cloneEnv = NULL;
+    cxBuffer_Init(&env->numberToStringFormatBuffer);
+    cxBuffer_Init(&env->numberFromStringFormatBuffer);
+    cxBuffer_Init(&env->nlsNumericCharactersBuffer);
+
+    // create the error handle
+    status = OCIHandleAlloc(handle, (dvoid**) &env->errorHandle,
+            OCI_HTYPE_ERROR, 0, 0);
+    if (Environment_CheckForError(env, status,
+            "Environment_New(): create error handle") < 0) {
+        Py_DECREF(env);
+        return NULL;
+    }
+
+    env->handle = handle;
+    return env;
+}
+
+
+//-----------------------------------------------------------------------------
+// Environment_GetCharacterSetName()
+//   Retrieve and store the IANA character set name for the attribute.
+//-----------------------------------------------------------------------------
+static int Environment_GetCharacterSetName(
+    udt_Environment *self,              // environment object
+    ub2 attribute,                      // attribute to fetch
+    const char *overrideValue,          // override value, if specified
+    char **result)                      // place to store result
+{
+    char charsetName[OCI_NLS_MAXBUFSZ], ianaCharsetName[OCI_NLS_MAXBUFSZ];
+    ub2 charsetId;
+    sword status;
+
+    // if override value specified, use it
+    if (overrideValue) {
+        *result = PyMem_Malloc(strlen(overrideValue) + 1);
+        if (!*result)
+            return -1;
+        strcpy(*result, overrideValue);
+        return 0;
+    }
+
+    // get character set id
+    status = OCIAttrGet(self->handle, OCI_HTYPE_ENV, &charsetId, NULL,
+            attribute, self->errorHandle);
+    if (Environment_CheckForError(self, status,
+            "Environment_GetCharacterSetName(): get charset id") < 0)
+        return -1;
+
+    // get character set name
+    status = OCINlsCharSetIdToName(self->handle, (text*) charsetName,
+            OCI_NLS_MAXBUFSZ, charsetId);
+    if (Environment_CheckForError(self, status,
+            "Environment_GetCharacterSetName(): get Oracle charset name") < 0)
+        return -1;
+
+    // get IANA character set name
+    status = OCINlsNameMap(self->handle, (oratext*) ianaCharsetName,
+            OCI_NLS_MAXBUFSZ, (oratext*) charsetName, OCI_NLS_CS_ORA_TO_IANA);
+    if (Environment_CheckForError(self, status,
+            "Environment_GetCharacterSetName(): translate NLS charset") < 0)
+        return -1;
+
+    // store results
+    *result = PyMem_Malloc(strlen(ianaCharsetName) + 1);
+    if (!*result)
+        return -1;
+    strcpy(*result, ianaCharsetName);
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// Environment_SetBuffer()
+//   Set the buffer in the environment from the specified string.
+//-----------------------------------------------------------------------------
+static int Environment_SetBuffer(
+    udt_Buffer *buf,                    // buffer to set
+    const char *value,                  // ASCII value to use
+    const char *encoding)               // encoding to use
+{
+    PyObject *obj;
+
+    obj = cxString_FromAscii(value);
+    if (!obj)
+        return -1;
+    return cxBuffer_FromObject(buf, obj, encoding);
+}
+
+
+//-----------------------------------------------------------------------------
+// Environment_NewFromScratch()
+//   Create a new environment object from scratch.
+//-----------------------------------------------------------------------------
+static udt_Environment *Environment_NewFromScratch(
+    int threaded,                       // use threaded mode?
+    int events,                         // use events mode?
+    char *encoding,                     // override value for encoding
+    char *nencoding)                    // override value for nencoding
+{
+    udt_Environment *env;
+    OCIEnv *handle;
+    sword status;
+    ub4 mode;
+
+    // turn threading mode on, if desired
+    mode = OCI_OBJECT;
+    if (threaded)
+        mode |= OCI_THREADED;
+#ifdef OCI_EVENTS
+    if (events)
+        mode |= OCI_EVENTS;
+#endif
+
+    // create the new environment handle
+    status = OCIEnvNlsCreate(&handle, mode, NULL, NULL, NULL, NULL, 0, NULL, 0,
+            0);
+    if (!handle ||
+            (status != OCI_SUCCESS && status != OCI_SUCCESS_WITH_INFO)) {
+        PyErr_SetString(g_InterfaceErrorException,
+                "Unable to acquire Oracle environment handle");
+        return NULL;
+    }
+
+    // create the environment object
+    env = Environment_New(handle);
+    if (!env) {
+        OCIHandleFree(handle, OCI_HTYPE_ENV);
+        return NULL;
+    }
+
+    // acquire max bytes per character
+    status = OCINlsNumericInfoGet(env->handle, env->errorHandle,
+            &env->maxBytesPerCharacter, OCI_NLS_CHARSET_MAXBYTESZ);
+    if (Environment_CheckForError(env, status,
+            "Environment_New(): get max bytes per character") < 0) {
+        Py_DECREF(env);
+        return NULL;
+    }
+    env->maxStringBytes = MAX_STRING_CHARS * env->maxBytesPerCharacter;
+
+    // acquire whether character set is fixed width
+    status = OCINlsNumericInfoGet(env->handle, env->errorHandle,
+            &env->fixedWidth, OCI_NLS_CHARSET_FIXEDWIDTH);
+    if (Environment_CheckForError(env, status,
+            "Environment_New(): determine if charset fixed width") < 0) {
+        Py_DECREF(env);
+        return NULL;
+    }
+
+    // determine encodings to use for Unicode values
+    if (Environment_GetCharacterSetName(env, OCI_ATTR_ENV_CHARSET_ID,
+            encoding, &env->encoding) < 0)
+        return NULL;
+    if (Environment_GetCharacterSetName(env, OCI_ATTR_ENV_NCHARSET_ID,
+            nencoding, &env->nencoding) < 0)
+        return NULL;
+
+    // fill buffers for number formats
+    if (Environment_SetBuffer(&env->numberToStringFormatBuffer, "TM9",
+            env->encoding) < 0)
+        return NULL;
+    if (Environment_SetBuffer(&env->numberFromStringFormatBuffer,
+            "999999999999999999999999999999999999999999999999999999999999999",
+            env->encoding) < 0)
+        return NULL;
+    if (Environment_SetBuffer(&env->nlsNumericCharactersBuffer,
+            "NLS_NUMERIC_CHARACTERS='.,'", env->encoding) < 0)
+        return NULL;
+
+    return env;
+}
+
+
+//-----------------------------------------------------------------------------
+// Environment_Clone()
+//   Clone an existing environment which is used when acquiring a connection
+// from a session pool, for example.
+//-----------------------------------------------------------------------------
+static udt_Environment *Environment_Clone(
+    udt_Environment *cloneEnv)          // environment to clone
+{
+    udt_Environment *env;
+
+    env = Environment_New(cloneEnv->handle);
+    if (!env)
+        return NULL;
+    env->maxBytesPerCharacter = cloneEnv->maxBytesPerCharacter;
+    env->maxStringBytes = cloneEnv->maxStringBytes;
+    env->fixedWidth = cloneEnv->fixedWidth;
+    Py_INCREF(cloneEnv);
+    env->cloneEnv = (PyObject*) cloneEnv;
+    env->encoding = cloneEnv->encoding;
+    env->nencoding = cloneEnv->nencoding;
+    cxBuffer_Copy(&env->numberToStringFormatBuffer,
+            &cloneEnv->numberToStringFormatBuffer);
+    cxBuffer_Copy(&env->numberFromStringFormatBuffer,
+            &cloneEnv->numberFromStringFormatBuffer);
+    cxBuffer_Copy(&env->nlsNumericCharactersBuffer,
+            &cloneEnv->nlsNumericCharactersBuffer);
+    return env;
+}
+
+
+//-----------------------------------------------------------------------------
+// Environment_Free()
+//   Deallocate the environment. Note that destroying the environment handle
+// will automatically destroy any child handles that were created.
+//-----------------------------------------------------------------------------
+static void Environment_Free(
+    udt_Environment *self)              // environment object
+{
+    if (self->errorHandle)
+        OCIHandleFree(self->errorHandle, OCI_HTYPE_ERROR);
+    if (self->handle && !self->cloneEnv)
+        OCIHandleFree(self->handle, OCI_HTYPE_ENV);
+    if (!self->cloneEnv) {
+        if (self->encoding)
+            PyMem_Free(self->encoding);
+        if (self->nencoding)
+            PyMem_Free(self->nencoding);
+    }
+    cxBuffer_Clear(&self->numberToStringFormatBuffer);
+    cxBuffer_Clear(&self->numberFromStringFormatBuffer);
+    cxBuffer_Clear(&self->nlsNumericCharactersBuffer);
+    Py_CLEAR(self->cloneEnv);
+    Py_TYPE(self)->tp_free((PyObject*) self);
+}
+
+
+//-----------------------------------------------------------------------------
+// Environment_RaiseError()
+//   Reads the error that was caused by the last Oracle statement and raise an
+// exception for Python. At this point it is assumed that the Oracle
+// environment is fully initialized.
+//-----------------------------------------------------------------------------
+static int Environment_RaiseError(
+    udt_Environment *environment,       // environment to raise error for
+    const char *context)                // context in which error occurred
+{
+    PyObject *exceptionType;
+    udt_Error *error;
+
+    error = Error_New(environment, context, 1);
+    if (error) {
+        switch (error->code) {
+            case 1:
+            case 1400:
+            case 2290:
+            case 2291:
+            case 2292:
+                exceptionType = g_IntegrityErrorException;
+                break;
+            case 22:
+            case 378:
+            case 602:
+            case 603:
+            case 604:
+            case 609:
+            case 1012:
+            case 1013:
+            case 1033:
+            case 1034:
+            case 1041:
+            case 1043:
+            case 1089:
+            case 1090:
+            case 1092:
+            case 3113:
+            case 3114:
+            case 3122:
+            case 3135:
+            case 12153:
+            case 12203:
+            case 12500:
+            case 12571:
+            case 27146:
+            case 28511:
+                exceptionType = g_OperationalErrorException;
+                break;
+            default:
+                exceptionType = g_DatabaseErrorException;
+                break;
+        }
+        PyErr_SetObject(exceptionType, (PyObject*) error);
+        Py_DECREF(error);
+    }
+    return -1;
+}
+
+
+//-----------------------------------------------------------------------------
+// Environment_CheckForError()
+//   Check for an error in the last call and if an error has occurred, raise a
+// Python exception.
+//-----------------------------------------------------------------------------
+static int Environment_CheckForError(
+    udt_Environment *environment,       // environment to raise error in
+    sword status,                       // status of last call
+    const char *context)                // context
+{
+    udt_Error *error;
+
+    if (status != OCI_SUCCESS && status != OCI_SUCCESS_WITH_INFO) {
+        if (status != OCI_INVALID_HANDLE)
+            return Environment_RaiseError(environment, context);
+        error = Error_New(environment, context, 0);
+        if (!error)
+            return -1;
+        error->code = 0;
+        error->message = cxString_FromAscii("Invalid handle!");
+        if (!error->message)
+            Py_DECREF(error);
+        else PyErr_SetObject(g_DatabaseErrorException, (PyObject*) error);
+        return -1;
+    }
+    return 0;
+}
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/Error.c b/desktop/core/ext-py/cx_Oracle-5.1.2/Error.c
new file mode 100644
index 0000000..f7caba4
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/Error.c
@@ -0,0 +1,153 @@
+//-----------------------------------------------------------------------------
+// Error.c
+//   Error handling.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// structure for the Python type
+//-----------------------------------------------------------------------------
+typedef struct {
+    PyObject_HEAD
+    sb4 code;
+    ub4 offset;
+    PyObject *message;
+    const char *context;
+} udt_Error;
+
+
+//-----------------------------------------------------------------------------
+// forward declarations
+//-----------------------------------------------------------------------------
+static void Error_Free(udt_Error*);
+static PyObject *Error_Str(udt_Error*);
+
+
+//-----------------------------------------------------------------------------
+// declaration of members
+//-----------------------------------------------------------------------------
+static PyMemberDef g_ErrorMembers[] = {
+    { "code", T_INT, offsetof(udt_Error, code), READONLY },
+    { "offset", T_INT, offsetof(udt_Error, offset), READONLY },
+    { "message", T_OBJECT, offsetof(udt_Error, message), READONLY },
+    { "context", T_STRING, offsetof(udt_Error, context), READONLY },
+    { NULL }
+};
+
+
+//-----------------------------------------------------------------------------
+// declaration of Python type
+//-----------------------------------------------------------------------------
+static PyTypeObject g_ErrorType = {
+    PyVarObject_HEAD_INIT(NULL, 0)
+    "cx_Oracle._Error",                 // tp_name
+    sizeof(udt_Error),                  // tp_basicsize
+    0,                                  // tp_itemsize
+    (destructor) Error_Free,            // tp_dealloc
+    0,                                  // tp_print
+    0,                                  // tp_getattr
+    0,                                  // tp_setattr
+    0,                                  // tp_compare
+    0,                                  // tp_repr
+    0,                                  // tp_as_number
+    0,                                  // tp_as_sequence
+    0,                                  // tp_as_mapping
+    0,                                  // tp_hash
+    0,                                  // tp_call
+    (reprfunc) Error_Str,               // tp_str
+    0,                                  // tp_getattro
+    0,                                  // tp_setattro
+    0,                                  // tp_as_buffer
+    Py_TPFLAGS_DEFAULT,                 // tp_flags
+    0,                                  // tp_doc
+    0,                                  // tp_traverse
+    0,                                  // tp_clear
+    0,                                  // tp_richcompare
+    0,                                  // tp_weaklistoffset
+    0,                                  // tp_iter
+    0,                                  // tp_iternext
+    0,                                  // tp_methods
+    g_ErrorMembers,                     // tp_members
+    0                                   // tp_getset
+};
+
+
+//-----------------------------------------------------------------------------
+// Error_New()
+//   Create a new error object.
+//-----------------------------------------------------------------------------
+static udt_Error *Error_New(
+    udt_Environment *environment,       // environment object
+    const char *context,                // context in which error occurred
+    int retrieveError)                  // retrieve error from OCI?
+{
+    char errorText[4096];
+    udt_Error *self;
+    ub4 handleType;
+    dvoid *handle;
+    sword status;
+#if PY_MAJOR_VERSION >= 3
+    Py_ssize_t len;
+#endif
+
+    self = (udt_Error*) g_ErrorType.tp_alloc(&g_ErrorType, 0);
+    if (!self)
+        return NULL;
+    self->context = context;
+    if (retrieveError) {
+        if (environment->errorHandle) {
+            handle = environment->errorHandle;
+            handleType = OCI_HTYPE_ERROR;
+        } else {
+            handle = environment->handle;
+            handleType = OCI_HTYPE_ENV;
+        }
+        status = OCIErrorGet(handle, 1, 0, &self->code,
+                (unsigned char*) errorText, sizeof(errorText), handleType);
+        if (status != OCI_SUCCESS) {
+            Py_DECREF(self);
+            PyErr_SetString(g_InternalErrorException, "No Oracle error?");
+            return NULL;
+        }
+#if PY_MAJOR_VERSION < 3
+        self->message = PyBytes_FromString(errorText);
+#else
+        len = strlen(errorText);
+        self->message = PyUnicode_Decode(errorText, len, environment->encoding,
+                NULL);
+#endif
+        if (!self->message) {
+            Py_DECREF(self);
+            return NULL;
+        }
+    }
+
+    return self;
+}
+
+
+//-----------------------------------------------------------------------------
+// Error_Free()
+//   Deallocate the environment, disconnecting from the database if necessary.
+//-----------------------------------------------------------------------------
+static void Error_Free(
+    udt_Error *self)                    // error object
+{
+    Py_CLEAR(self->message);
+    PyObject_Del(self);
+}
+
+
+//-----------------------------------------------------------------------------
+// Error_Str()
+//   Return a string representation of the error variable.
+//-----------------------------------------------------------------------------
+static PyObject *Error_Str(
+    udt_Error *self)                    // variable to return the string for
+{
+    if (self->message) {
+        Py_INCREF(self->message);
+        return self->message;
+    }
+    return cxString_FromAscii("");
+}
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/ExternalLobVar.c b/desktop/core/ext-py/cx_Oracle-5.1.2/ExternalLobVar.c
new file mode 100644
index 0000000..e627120
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/ExternalLobVar.c
@@ -0,0 +1,653 @@
+//-----------------------------------------------------------------------------
+// ExternalLobVar.c
+//   Defines the routines for handling LOB variables external to this module.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// external LOB type
+//-----------------------------------------------------------------------------
+typedef struct {
+    PyObject_HEAD
+    udt_LobVar *lobVar;
+    unsigned pos;
+    unsigned internalFetchNum;
+} udt_ExternalLobVar;
+
+
+//-----------------------------------------------------------------------------
+// Declaration of external LOB variable functions.
+//-----------------------------------------------------------------------------
+static void ExternalLobVar_Free(udt_ExternalLobVar*);
+static PyObject *ExternalLobVar_Str(udt_ExternalLobVar*);
+static PyObject *ExternalLobVar_Size(udt_ExternalLobVar*, PyObject*);
+static PyObject *ExternalLobVar_Open(udt_ExternalLobVar*, PyObject*);
+static PyObject *ExternalLobVar_Close(udt_ExternalLobVar*, PyObject*);
+static PyObject *ExternalLobVar_Read(udt_ExternalLobVar*, PyObject*,
+        PyObject*);
+static PyObject *ExternalLobVar_Write(udt_ExternalLobVar*, PyObject*,
+        PyObject*);
+static PyObject *ExternalLobVar_Trim(udt_ExternalLobVar*, PyObject*,
+        PyObject*);
+static PyObject *ExternalLobVar_GetChunkSize(udt_ExternalLobVar*, PyObject*);
+static PyObject *ExternalLobVar_IsOpen(udt_ExternalLobVar*, PyObject*);
+static PyObject *ExternalLobVar_GetFileName(udt_ExternalLobVar*, PyObject*);
+static PyObject *ExternalLobVar_SetFileName(udt_ExternalLobVar*, PyObject*);
+static PyObject *ExternalLobVar_FileExists(udt_ExternalLobVar*, PyObject*);
+static PyObject *ExternalLobVar_Reduce(udt_ExternalLobVar*);
+
+
+//-----------------------------------------------------------------------------
+// declaration of methods for Python type "ExternalLOBVar"
+//-----------------------------------------------------------------------------
+static PyMethodDef g_ExternalLobVarMethods[] = {
+    { "size", (PyCFunction) ExternalLobVar_Size, METH_NOARGS },
+    { "open", (PyCFunction) ExternalLobVar_Open, METH_NOARGS },
+    { "close", (PyCFunction) ExternalLobVar_Close, METH_NOARGS },
+    { "read", (PyCFunction) ExternalLobVar_Read,
+              METH_VARARGS  | METH_KEYWORDS },
+    { "write", (PyCFunction) ExternalLobVar_Write,
+              METH_VARARGS  | METH_KEYWORDS },
+    { "trim", (PyCFunction) ExternalLobVar_Trim,
+              METH_VARARGS  | METH_KEYWORDS },
+    { "getchunksize", (PyCFunction) ExternalLobVar_GetChunkSize, METH_NOARGS },
+    { "isopen", (PyCFunction) ExternalLobVar_IsOpen, METH_NOARGS },
+    { "getfilename", (PyCFunction) ExternalLobVar_GetFileName, METH_NOARGS },
+    { "setfilename", (PyCFunction) ExternalLobVar_SetFileName, METH_VARARGS },
+    { "fileexists", (PyCFunction) ExternalLobVar_FileExists, METH_NOARGS },
+    { "__reduce__", (PyCFunction) ExternalLobVar_Reduce, METH_NOARGS },
+    { NULL, NULL }
+};
+
+
+//-----------------------------------------------------------------------------
+// Python type declaration
+//-----------------------------------------------------------------------------
+static PyTypeObject g_ExternalLobVarType = {
+    PyVarObject_HEAD_INIT(NULL, 0)
+    "cx_Oracle.LOB",                    // tp_name
+    sizeof(udt_ExternalLobVar),         // tp_basicsize
+    0,                                  // tp_itemsize
+    (destructor) ExternalLobVar_Free,   // tp_dealloc
+    0,                                  // tp_print
+    0,                                  // tp_getattr
+    0,                                  // tp_setattr
+    0,                                  // tp_compare
+    0,                                  // tp_repr
+    0,                                  // tp_as_number
+    0,                                  // tp_as_sequence
+    0,                                  // tp_as_mapping
+    0,                                  // tp_hash
+    0,                                  // tp_call
+    (reprfunc) ExternalLobVar_Str,      // tp_str
+    0,                                  // tp_getattro
+    0,                                  // tp_setattro
+    0,                                  // tp_as_buffer
+    Py_TPFLAGS_DEFAULT,                 // tp_flags
+    0,                                  // tp_doc
+    0,                                  // tp_traverse
+    0,                                  // tp_clear
+    0,                                  // tp_richcompare
+    0,                                  // tp_weaklistoffset
+    0,                                  // tp_iter
+    0,                                  // tp_iternext
+    g_ExternalLobVarMethods,            // tp_methods
+    0,                                  // tp_members
+    0,                                  // tp_getset
+    0,                                  // tp_base
+    0,                                  // tp_dict
+    0,                                  // tp_descr_get
+    0,                                  // tp_descr_set
+    0,                                  // tp_dictoffset
+    0,                                  // tp_init
+    0,                                  // tp_alloc
+    0,                                  // tp_new
+    0,                                  // tp_free
+    0,                                  // tp_is_gc
+    0                                   // tp_bases
+};
+
+
+//-----------------------------------------------------------------------------
+// ExternalLobVar_New()
+//   Create a new external LOB variable.
+//-----------------------------------------------------------------------------
+PyObject *ExternalLobVar_New(
+    udt_LobVar *var,                    // variable to encapsulate
+    unsigned pos)                       // position in array to encapsulate
+{
+    udt_ExternalLobVar *self;
+
+    self = (udt_ExternalLobVar*)
+            g_ExternalLobVarType.tp_alloc(&g_ExternalLobVarType, 0);
+    if (!self)
+        return NULL;
+    self->pos = pos;
+    self->internalFetchNum = var->internalFetchNum;
+    Py_INCREF(var);
+    self->lobVar = var;
+
+    return (PyObject*) self;
+}
+
+
+//-----------------------------------------------------------------------------
+// ExternalLobVar_Free()
+//   Free an external LOB variable.
+//-----------------------------------------------------------------------------
+static void ExternalLobVar_Free(
+    udt_ExternalLobVar *self)           // variable to free
+{
+    Py_CLEAR(self->lobVar);
+    Py_TYPE(self)->tp_free((PyObject*) self);
+}
+
+
+//-----------------------------------------------------------------------------
+// ExternalLobVar_Verify()
+//   Verify that the external LOB var is still valid.
+//-----------------------------------------------------------------------------
+static int ExternalLobVar_Verify(
+    udt_ExternalLobVar *var)            // variable to verify
+{
+    if (var->internalFetchNum != var->lobVar->internalFetchNum) {
+        PyErr_SetString(g_ProgrammingErrorException,
+                "LOB variable no longer valid after subsequent fetch");
+        return -1;
+    }
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// ExternalLobVar_InternalRead()
+//   Return the size of the LOB variable for internal comsumption.
+//-----------------------------------------------------------------------------
+static int ExternalLobVar_InternalRead(
+    udt_ExternalLobVar *var,            // variable to return the size of
+    char *buffer,                       // buffer in which to put data
+    ub4 bufferSize,                     // size of buffer
+    ub4 *length,                        // length of data (IN/OUT)
+    int offset)                         // offset
+{
+    ub2 charsetId;
+    sword status;
+
+    if (var->lobVar->isFile) {
+        Py_BEGIN_ALLOW_THREADS
+        status = OCILobFileOpen(var->lobVar->connection->handle,
+                var->lobVar->environment->errorHandle,
+                var->lobVar->data[var->pos], OCI_FILE_READONLY);
+        Py_END_ALLOW_THREADS
+        if (Environment_CheckForError(var->lobVar->environment, status,
+                "ExternalLobVar_FileOpen()") < 0)
+            return -1;
+    }
+
+    Py_BEGIN_ALLOW_THREADS
+    if (var->lobVar->type == &vt_NCLOB)
+        charsetId = OCI_UTF16ID;
+    else charsetId = 0;
+    status = OCILobRead(var->lobVar->connection->handle,
+            var->lobVar->environment->errorHandle,
+            var->lobVar->data[var->pos], length, offset, buffer,
+            bufferSize, NULL, NULL, charsetId, var->lobVar->type->charsetForm); 
+    Py_END_ALLOW_THREADS
+    if (Environment_CheckForError(var->lobVar->environment, status,
+            "ExternalLobVar_LobRead()") < 0) {
+        OCILobFileClose(var->lobVar->connection->handle,
+                var->lobVar->environment->errorHandle,
+                var->lobVar->data[var->pos]);
+        return -1;
+    }
+
+    if (var->lobVar->isFile) {
+        Py_BEGIN_ALLOW_THREADS
+        status = OCILobFileClose(var->lobVar->connection->handle,
+                var->lobVar->environment->errorHandle,
+                var->lobVar->data[var->pos]);
+        Py_END_ALLOW_THREADS
+        if (Environment_CheckForError(var->lobVar->environment, status,
+                "ExternalLobVar_FileClose()") < 0)
+            return -1;
+    }
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// ExternalLobVar_InternalSize()
+//   Return the size of the LOB variable for internal comsumption.
+//-----------------------------------------------------------------------------
+static int ExternalLobVar_InternalSize(
+    udt_ExternalLobVar *var)            // variable to return the size of
+{
+    sword status;
+    ub4 length;
+
+    Py_BEGIN_ALLOW_THREADS
+    status = OCILobGetLength(var->lobVar->connection->handle,
+            var->lobVar->environment->errorHandle,
+            var->lobVar->data[var->pos], &length);
+    Py_END_ALLOW_THREADS
+    if (Environment_CheckForError(var->lobVar->environment, status,
+            "ExternalLobVar_InternalSize()") < 0)
+        return -1;
+
+    return length;
+}
+
+
+//-----------------------------------------------------------------------------
+// ExternalLobVar_Value()
+//   Return a portion (or all) of the data in the external LOB variable.
+//-----------------------------------------------------------------------------
+static PyObject *ExternalLobVar_Value(
+    udt_ExternalLobVar *var,            // variable to return the size of
+    int offset,                         // offset into LOB
+    int amount)                         // amount to read from LOB
+{
+    ub4 length, bufferSize;
+    PyObject *result;
+    char *buffer;
+
+    // modify the arguments
+    if (offset < 0)
+        offset = 1;
+    if (amount < 0) {
+        amount = ExternalLobVar_InternalSize(var);
+        if (amount < 0)
+            return NULL;
+        amount = amount - offset + 1;
+        if (amount <= 0)
+            amount = 1;
+    }
+    length = amount;
+    if (var->lobVar->type == &vt_CLOB)
+        bufferSize = amount * var->lobVar->environment->maxBytesPerCharacter;
+    else if (var->lobVar->type == &vt_NCLOB)
+        bufferSize = amount * 2;
+    else bufferSize = amount;
+
+    // create a string for retrieving the value
+    buffer = (char*) PyMem_Malloc(bufferSize);
+    if (!buffer)
+        return PyErr_NoMemory();
+    if (ExternalLobVar_InternalRead(var, buffer, bufferSize, &length,
+            offset) < 0) {
+        PyMem_Free(buffer);
+        return NULL;
+    }
+
+    // return the result
+    if (var->lobVar->type == &vt_CLOB) {
+        if (var->lobVar->environment->fixedWidth)
+            length = length * var->lobVar->environment->maxBytesPerCharacter;
+        result = cxString_FromEncodedString(buffer, length,
+                var->lobVar->environment->encoding);
+    } else if (var->lobVar->type == &vt_NCLOB) {
+        result = PyUnicode_DecodeUTF16(buffer, length * 2, NULL, NULL);
+    } else {
+        result = PyBytes_FromStringAndSize(buffer, length);
+    }
+    PyMem_Free(buffer);
+    return result;
+}
+
+
+//-----------------------------------------------------------------------------
+// ExternalLobVar_Size()
+//   Return the size of the data in the LOB variable.
+//-----------------------------------------------------------------------------
+static PyObject *ExternalLobVar_Size(
+    udt_ExternalLobVar *var,            // variable to return the size of
+    PyObject *args)                     // arguments
+{
+    int length;
+
+    if (ExternalLobVar_Verify(var) < 0)
+        return NULL;
+    length = ExternalLobVar_InternalSize(var);
+    if (length < 0)
+        return NULL;
+    return PyInt_FromLong(length);
+}
+
+
+//-----------------------------------------------------------------------------
+// ExternalLobVar_Open()
+//   Open the LOB to speed further accesses.
+//-----------------------------------------------------------------------------
+static PyObject *ExternalLobVar_Open(
+    udt_ExternalLobVar *var,            // variable to return the size of
+    PyObject *args)                     // arguments
+{
+    sword status;
+
+    if (ExternalLobVar_Verify(var) < 0)
+        return NULL;
+    Py_BEGIN_ALLOW_THREADS
+    status = OCILobOpen(var->lobVar->connection->handle,
+            var->lobVar->environment->errorHandle,
+            var->lobVar->data[var->pos], OCI_LOB_READWRITE);
+    Py_END_ALLOW_THREADS
+    if (Environment_CheckForError(var->lobVar->environment, status,
+            "ExternalLobVar_Open()") < 0)
+        return NULL;
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+
+//-----------------------------------------------------------------------------
+// ExternalLobVar_Close()
+//   Close the LOB.
+//-----------------------------------------------------------------------------
+static PyObject *ExternalLobVar_Close(
+    udt_ExternalLobVar *var,            // variable to return the size of
+    PyObject *args)                     // arguments
+{
+    sword status;
+
+    if (ExternalLobVar_Verify(var) < 0)
+        return NULL;
+    Py_BEGIN_ALLOW_THREADS
+    status = OCILobClose(var->lobVar->connection->handle,
+            var->lobVar->environment->errorHandle,
+            var->lobVar->data[var->pos]);
+    Py_END_ALLOW_THREADS
+    if (Environment_CheckForError(var->lobVar->environment, status,
+            "ExternalLobVar_Close()") < 0)
+        return NULL;
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+
+//-----------------------------------------------------------------------------
+// ExternalLobVar_Read()
+//   Return a portion (or all) of the data in the external LOB variable.
+//-----------------------------------------------------------------------------
+static PyObject *ExternalLobVar_Read(
+    udt_ExternalLobVar *var,            // variable to return the size of
+    PyObject *args,                     // arguments
+    PyObject *keywordArgs)              // keyword arguments
+{
+    static char *keywordList[] = { "offset", "amount", NULL };
+    int offset, amount;
+
+    // offset and amount are expected, both optional
+    offset = amount = -1;
+    if (!PyArg_ParseTupleAndKeywords(args, keywordArgs, "|ii", keywordList,
+            &offset, &amount))
+        return NULL;
+
+    if (ExternalLobVar_Verify(var) < 0)
+        return NULL;
+    return ExternalLobVar_Value(var, offset, amount);
+}
+
+
+//-----------------------------------------------------------------------------
+// ExternalLobVar_Str()
+//   Return all of the data in the external LOB variable.
+//-----------------------------------------------------------------------------
+static PyObject *ExternalLobVar_Str(
+    udt_ExternalLobVar *var)            // variable to return the string for
+{
+    if (ExternalLobVar_Verify(var) < 0)
+        return NULL;
+    return ExternalLobVar_Value(var, 1, -1);
+}
+
+
+//-----------------------------------------------------------------------------
+// ExternalLobVar_Write()
+//   Write a value to the LOB variable; return the number of bytes written.
+//-----------------------------------------------------------------------------
+static PyObject *ExternalLobVar_Write(
+    udt_ExternalLobVar *var,            // variable to perform write against
+    PyObject *args,                     // arguments
+    PyObject *keywordArgs)              // keyword arguments
+{
+    static char *keywordList[] = { "data", "offset", NULL };
+    PyObject *dataObj;
+    ub4 amount;
+    int offset;
+
+    // buffer and offset are expected, offset is optional
+    offset = -1;
+    if (!PyArg_ParseTupleAndKeywords(args, keywordArgs, "O|i", keywordList,
+            &dataObj, &offset))
+        return NULL;
+    if (offset < 0)
+        offset = 1;
+
+    // perform the write, if possible
+    if (ExternalLobVar_Verify(var) < 0)
+        return NULL;
+    if (LobVar_Write(var->lobVar, var->pos, dataObj, offset, &amount) < 0)
+        return NULL;
+
+    // return the result
+    return PyInt_FromLong(amount);
+}
+
+
+//-----------------------------------------------------------------------------
+// ExternalLobVar_Trim()
+//   Trim the LOB variable to the specified length.
+//-----------------------------------------------------------------------------
+static PyObject *ExternalLobVar_Trim(
+    udt_ExternalLobVar *var,            // variable to perform write against
+    PyObject *args,                     // arguments
+    PyObject *keywordArgs)              // keyword arguments
+{
+    static char *keywordList[] = { "newSize", NULL };
+    sword status;
+    ub4 newSize;
+
+    // buffer and offset are expected, offset is optional
+    newSize = 0;
+    if (!PyArg_ParseTupleAndKeywords(args, keywordArgs, "|i", keywordList,
+            &newSize))
+        return NULL;
+
+    // create a string for retrieving the value
+    if (ExternalLobVar_Verify(var) < 0)
+        return NULL;
+    Py_BEGIN_ALLOW_THREADS
+    status = OCILobTrim(var->lobVar->connection->handle,
+            var->lobVar->environment->errorHandle, var->lobVar->data[var->pos],
+            newSize);
+    Py_END_ALLOW_THREADS
+    if (Environment_CheckForError(var->lobVar->environment, status,
+            "ExternalLobVar_Trim()") < 0)
+        return NULL;
+
+    // return the result
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+
+//-----------------------------------------------------------------------------
+// ExternalLobVar_Reduce()
+//   Method provided for pickling/unpickling of LOB variables.
+//-----------------------------------------------------------------------------
+static PyObject *ExternalLobVar_Reduce(
+    udt_ExternalLobVar *self)           // variable to dump
+{
+    PyObject *result, *value;
+
+    value = ExternalLobVar_Str(self);
+    if (!value)
+        return NULL;
+    result = Py_BuildValue("(O(O))", Py_TYPE(value), value);
+    Py_DECREF(value);
+    return result;
+}
+
+
+//-----------------------------------------------------------------------------
+// ExternalLobVar_GetChunkSize()
+//   Return the chunk size that should be used when reading/writing the LOB in
+// chunks.
+//-----------------------------------------------------------------------------
+static PyObject *ExternalLobVar_GetChunkSize(
+    udt_ExternalLobVar *var,            // variable to get chunk size for
+    PyObject *args)                     // arguments
+{
+    ub4 chunkSize;
+    sword status;
+
+    if (ExternalLobVar_Verify(var) < 0)
+        return NULL;
+    status = OCILobGetChunkSize(var->lobVar->connection->handle,
+            var->lobVar->environment->errorHandle, var->lobVar->data[var->pos],
+            &chunkSize);
+    if (Environment_CheckForError(var->lobVar->environment, status,
+            "ExternalLobVar_GetChunkSize()") < 0)
+        return NULL;
+    return PyInt_FromLong(chunkSize);
+}
+
+
+//-----------------------------------------------------------------------------
+// ExternalLobVar_IsOpen()
+//   Return a boolean indicating if the lob is open or not.
+//-----------------------------------------------------------------------------
+static PyObject *ExternalLobVar_IsOpen(
+    udt_ExternalLobVar *var,            // variable to get chunk size for
+    PyObject *args)                     // arguments
+{
+    boolean isOpen;
+    sword status;
+
+    if (ExternalLobVar_Verify(var) < 0)
+        return NULL;
+    Py_BEGIN_ALLOW_THREADS
+    status = OCILobIsOpen(var->lobVar->connection->handle,
+            var->lobVar->environment->errorHandle, var->lobVar->data[var->pos],
+            &isOpen);
+    Py_END_ALLOW_THREADS
+    if (Environment_CheckForError(var->lobVar->environment, status,
+            "ExternalLobVar_IsOpen()") < 0)
+        return NULL;
+    return PyBool_FromLong(isOpen);
+}
+
+
+//-----------------------------------------------------------------------------
+// ExternalLobVar_GetFileName()
+//   Return the directory alias and file name for the BFILE lob.
+//-----------------------------------------------------------------------------
+static PyObject *ExternalLobVar_GetFileName(
+    udt_ExternalLobVar *var,            // variable to get file name for
+    PyObject *args)                     // arguments
+{
+    char dirAlias[120], name[1020];
+    ub2 dirAliasLength, nameLength;
+    PyObject *result, *temp;
+    sword status;
+
+    // determine the directory alias and name
+    if (ExternalLobVar_Verify(var) < 0)
+        return NULL;
+    nameLength = sizeof(name);
+    dirAliasLength = sizeof(dirAlias);
+    status = OCILobFileGetName(var->lobVar->environment->handle,
+            var->lobVar->environment->errorHandle, var->lobVar->data[var->pos],
+            (text*) dirAlias, &dirAliasLength, (text*) name, &nameLength);
+    if (Environment_CheckForError(var->lobVar->environment, status,
+            "ExternalLobVar_GetFileName()") < 0)
+        return NULL;
+
+    // create the two-tuple for returning
+    result = PyTuple_New(2);
+    if (!result)
+        return NULL;
+    temp = cxString_FromEncodedString(dirAlias, dirAliasLength,
+            var->lobVar->environment->encoding);
+    if (!temp) {
+        Py_DECREF(result);
+        return NULL;
+    }
+    PyTuple_SET_ITEM(result, 0, temp);
+    temp = cxString_FromEncodedString(name, nameLength,
+            var->lobVar->environment->encoding);
+    if (!temp) {
+        Py_DECREF(result);
+        return NULL;
+    }
+    PyTuple_SET_ITEM(result, 1, temp);
+
+    return result;
+}
+
+
+//-----------------------------------------------------------------------------
+// ExternalLobVar_SetFileName()
+//   Set the directory alias and file name for the BFILE lob.
+//-----------------------------------------------------------------------------
+static PyObject *ExternalLobVar_SetFileName(
+    udt_ExternalLobVar *var,            // variable to set file name for
+    PyObject *args)                     // arguments
+{
+    int dirAliasLength, nameLength;
+    char *dirAlias, *name;
+    sword status;
+
+    // get the directory alias and name as strings
+    if (!PyArg_ParseTuple(args, "s#s#", &dirAlias, &dirAliasLength, &name,
+            &nameLength))
+        return NULL;
+
+    // create a string for retrieving the value
+    if (ExternalLobVar_Verify(var) < 0)
+        return NULL;
+    status = OCILobFileSetName(var->lobVar->environment->handle,
+            var->lobVar->environment->errorHandle,
+            &var->lobVar->data[var->pos], (text*) dirAlias,
+            (ub2) dirAliasLength, (text*) name, (ub2) nameLength);
+    if (Environment_CheckForError(var->lobVar->environment, status,
+            "ExternalLobVar_SetFileName()") < 0)
+        return NULL;
+
+    // return the result
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+
+//-----------------------------------------------------------------------------
+// ExternalLobVar_FileExists()
+//   Return a boolean indicating if the BFIILE lob exists.
+//-----------------------------------------------------------------------------
+static PyObject *ExternalLobVar_FileExists(
+    udt_ExternalLobVar *var,            // variable to perform write against
+    PyObject *args)                     // arguments
+{
+    PyObject *result;
+    sword status;
+    boolean flag;
+
+    if (ExternalLobVar_Verify(var) < 0)
+        return NULL;
+    Py_BEGIN_ALLOW_THREADS
+    status = OCILobFileExists(var->lobVar->connection->handle,
+            var->lobVar->environment->errorHandle, var->lobVar->data[var->pos],
+            &flag);
+    Py_END_ALLOW_THREADS
+    if (Environment_CheckForError(var->lobVar->environment, status,
+            "ExternalLobVar_FileExists()") < 0)
+        return NULL;
+
+    // return the result
+    if (flag)
+        result = Py_True;
+    else result = Py_False;
+    Py_INCREF(result);
+    return result;
+}
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/ExternalObjectVar.c b/desktop/core/ext-py/cx_Oracle-5.1.2/ExternalObjectVar.c
new file mode 100644
index 0000000..c4c544e
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/ExternalObjectVar.c
@@ -0,0 +1,305 @@
+//-----------------------------------------------------------------------------
+// ExternalObjectVar.c
+//   Defines the routines for handling object variables external to this
+// module.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// external Object type
+//-----------------------------------------------------------------------------
+typedef struct {
+    PyObject_HEAD
+    PyObject *referencedObject;
+    udt_ObjectType *objectType;
+    dvoid *instance;
+    dvoid *indicator;
+    int isIndependent;
+} udt_ExternalObjectVar;
+
+
+//-----------------------------------------------------------------------------
+// Declaration of external object variable functions.
+//-----------------------------------------------------------------------------
+static void ExternalObjectVar_Free(udt_ExternalObjectVar*);
+static PyObject *ExternalObjectVar_GetAttr(udt_ExternalObjectVar*, PyObject*);
+static PyObject *ExternalObjectVar_ConvertToPython(udt_Environment*,
+        OCITypeCode, dvoid*, dvoid*, PyObject*, udt_ObjectType*);
+
+//-----------------------------------------------------------------------------
+// Declaration of external object variable members.
+//-----------------------------------------------------------------------------
+static PyMemberDef g_ExternalObjectVarMembers[] = {
+    { "type", T_OBJECT, offsetof(udt_ExternalObjectVar, objectType),
+            READONLY },
+    { NULL }
+};
+
+//-----------------------------------------------------------------------------
+// Python type declaration
+//-----------------------------------------------------------------------------
+static PyTypeObject g_ExternalObjectVarType = {
+    PyVarObject_HEAD_INIT(NULL, 0)
+    "cx_Oracle.OBJECT",                 // tp_name
+    sizeof(udt_ExternalObjectVar),      // tp_basicsize
+    0,                                  // tp_itemsize
+    (destructor) ExternalObjectVar_Free,
+                                        // tp_dealloc
+    0,                                  // tp_print
+    0,                                  // tp_getattr
+    0,                                  // tp_setattr
+    0,                                  // tp_compare
+    0,                                  // tp_repr
+    0,                                  // tp_as_number
+    0,                                  // tp_as_sequence
+    0,                                  // tp_as_mapping
+    0,                                  // tp_hash
+    0,                                  // tp_call
+    0,                                  // tp_str
+    (getattrofunc) ExternalObjectVar_GetAttr,
+                                        // tp_getattro
+    0,                                  // tp_setattro
+    0,                                  // tp_as_buffer
+    Py_TPFLAGS_DEFAULT,                 // tp_flags
+    0,                                  // tp_doc
+    0,                                  // tp_traverse
+    0,                                  // tp_clear
+    0,                                  // tp_richcompare
+    0,                                  // tp_weaklistoffset
+    0,                                  // tp_iter
+    0,                                  // tp_iternext
+    0,                                  // tp_methods
+    g_ExternalObjectVarMembers          // tp_members
+};
+
+
+//-----------------------------------------------------------------------------
+// ExternalObjectVar_New()
+//   Create a new external LOB variable.
+//-----------------------------------------------------------------------------
+PyObject *ExternalObjectVar_New(
+    PyObject *referencedObject,         // referenced object
+    udt_ObjectType *objectType,         // type of object
+    dvoid *instance,                    // object instance data
+    dvoid *indicator,                   // indicator structure
+    int isIndependent)                  // is object independent?
+{
+    udt_ExternalObjectVar *self;
+
+    self = (udt_ExternalObjectVar*)
+            g_ExternalObjectVarType.tp_alloc(&g_ExternalObjectVarType, 0);
+    if (!self)
+        return NULL;
+    Py_INCREF(referencedObject);
+    self->referencedObject = referencedObject;
+    Py_INCREF(objectType);
+    self->objectType = objectType;
+    self->instance = instance;
+    self->indicator = indicator;
+    self->isIndependent = isIndependent;
+    return (PyObject*) self;
+}
+
+
+//-----------------------------------------------------------------------------
+// ExternalObjectVar_Free()
+//   Free an external LOB variable.
+//-----------------------------------------------------------------------------
+static void ExternalObjectVar_Free(
+    udt_ExternalObjectVar *self)        // variable to free
+{
+    if (self->isIndependent)
+        OCIObjectFree(self->objectType->environment->handle,
+                self->objectType->environment->errorHandle,
+                self->instance, OCI_OBJECTFREE_FORCE);
+    Py_CLEAR(self->objectType);
+    Py_CLEAR(self->referencedObject);
+    Py_TYPE(self)->tp_free((PyObject*) self);
+}
+
+
+//-----------------------------------------------------------------------------
+// ExternalObjectVar_ConvertCollectionElements()
+//   Convert the collection elements to Python values.
+//-----------------------------------------------------------------------------
+static int ExternalObjectVar_ConvertCollectionElements(
+    udt_Environment *environment,       // environment to use
+    OCIIter *iter,                      // iterator
+    PyObject *list,                     // list result
+    PyObject *referencedObject,         // referenced object
+    udt_ObjectType *objectType)         // collection type information
+{
+    dvoid *elementValue, *elementIndicator;
+    PyObject *elementObject;
+    boolean endOfCollection;
+    sword status;
+
+    while (list) {
+        status = OCIIterNext(environment->handle, environment->errorHandle,
+                iter, &elementValue, &elementIndicator, &endOfCollection);
+        if (Environment_CheckForError(environment, status,
+                "ExternalObjectVar_ConvertCollection(): get next") < 0)
+            return -1;
+        if (endOfCollection)
+            break;
+        elementObject = ExternalObjectVar_ConvertToPython(environment,
+                objectType->elementTypeCode, elementValue, elementIndicator,
+                referencedObject, (udt_ObjectType*) objectType->elementType);
+        if (!elementObject)
+            return -1;
+        if (PyList_Append(list, elementObject) < 0) {
+            Py_DECREF(elementObject);
+            return -1;
+        }
+        Py_DECREF(elementObject);
+    }
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// ExternalObjectVar_ConvertCollection()
+//   Convert a collection to a Python list.
+//-----------------------------------------------------------------------------
+static PyObject *ExternalObjectVar_ConvertCollection(
+    udt_Environment *environment,       // environment to use
+    OCIColl *collectionValue,           // collection value
+    PyObject *referencedObject,         // referenced object
+    udt_ObjectType *objectType)         // collection type information
+{
+    PyObject *list;
+    OCIIter *iter;
+    sword status;
+    int result;
+
+    // create the iterator
+    status = OCIIterCreate(environment->handle, environment->errorHandle,
+            collectionValue, &iter);
+    if (Environment_CheckForError(environment, status,
+            "ExternalObjectVar_ConvertCollection(): creating iterator") < 0)
+        return NULL;
+
+    // create the result list
+    list = PyList_New(0);
+    if (list) {
+        result = ExternalObjectVar_ConvertCollectionElements(environment, iter,
+                list, referencedObject, objectType);
+        if (result < 0) {
+            Py_DECREF(list);
+            list = NULL;
+        }
+    }
+    OCIIterDelete(environment->handle, environment->errorHandle, &iter);
+
+    return list;
+}
+
+
+//-----------------------------------------------------------------------------
+// ExternalObjectVar_ConvertToPython()
+//   Convert an Oracle value to a Python value.
+//-----------------------------------------------------------------------------
+static PyObject *ExternalObjectVar_ConvertToPython(
+    udt_Environment *environment,       // environment to use
+    OCITypeCode typeCode,               // type of Oracle data
+    dvoid *value,                       // Oracle value
+    dvoid *indicator,                   // null indicator
+    PyObject *referencedObject,         // referenced object (for sub objects)
+    udt_ObjectType *subType)            // sub type (for sub objects)
+{
+    text *stringValue;
+    ub4 stringSize;
+
+    // null values returned as None
+    if (* (OCIInd*) indicator == OCI_IND_NULL) {
+        Py_INCREF(Py_None);
+        return Py_None;
+    }
+
+    switch (typeCode) {
+        case OCI_TYPECODE_CHAR:
+        case OCI_TYPECODE_VARCHAR:
+        case OCI_TYPECODE_VARCHAR2:
+            stringValue = OCIStringPtr(environment->handle,
+                    * (OCIString**) value);
+            stringSize = OCIStringSize(environment->handle,
+                    * (OCIString**) value);
+            return cxString_FromEncodedString( (char*) stringValue,
+                    stringSize, environment->encoding);
+        case OCI_TYPECODE_NUMBER:
+            return OracleNumberToPythonFloat(environment, (OCINumber*) value);
+        case OCI_TYPECODE_DATE:
+            return OracleDateToPythonDate(&vt_DateTime, (OCIDate*) value);
+        case OCI_TYPECODE_TIMESTAMP:
+            return OracleTimestampToPythonDate(environment,
+                    * (OCIDateTime**) value);
+        case OCI_TYPECODE_OBJECT:
+            return ExternalObjectVar_New(referencedObject, subType, value,
+                    indicator, 0);
+        case OCI_TYPECODE_NAMEDCOLLECTION:
+            return ExternalObjectVar_ConvertCollection(environment,
+                    * (OCIColl**) value, referencedObject, subType);
+    };
+
+    return PyErr_Format(g_NotSupportedErrorException,
+            "ExternalObjectVar_GetAttributeValue(): unhandled data type %d",
+            typeCode);
+}
+
+
+//-----------------------------------------------------------------------------
+// ExternalObjectVar_GetAttributeValue()
+//   Retrieve an attribute on the external LOB variable object.
+//-----------------------------------------------------------------------------
+static PyObject *ExternalObjectVar_GetAttributeValue(
+    udt_ExternalObjectVar *self,        // object
+    udt_ObjectAttribute *attribute)     // attribute to get
+{
+    dvoid *valueIndicator, *value;
+    OCIInd scalarValueIndicator;
+    udt_Buffer buffer;
+    sword status;
+    OCIType *tdo;
+
+    // get the value for the attribute
+    if (cxBuffer_FromObject(&buffer, attribute->name,
+            self->objectType->environment->encoding) < 0)
+        return NULL;
+    status = OCIObjectGetAttr(self->objectType->environment->handle,
+            self->objectType->environment->errorHandle, self->instance,
+            self->indicator, self->objectType->tdo,
+            (const OraText**) &buffer.ptr, (ub4*) &buffer.size, 1, 0, 0,
+            &scalarValueIndicator, &valueIndicator, &value, &tdo);
+    cxBuffer_Clear(&buffer);
+    if (Environment_CheckForError(self->objectType->environment, status,
+            "ExternalObjectVar_GetAttributeValue(): getting value") < 0)
+        return NULL;
+
+    // determine the proper null indicator
+    if (!valueIndicator)
+        valueIndicator = &scalarValueIndicator;
+
+    return ExternalObjectVar_ConvertToPython(self->objectType->environment,
+            attribute->typeCode, value, valueIndicator, (PyObject*) self,
+            attribute->subType);
+}
+
+
+//-----------------------------------------------------------------------------
+// ExternalObjectVar_GetAttr()
+//   Retrieve an attribute on the external LOB variable object.
+//-----------------------------------------------------------------------------
+static PyObject *ExternalObjectVar_GetAttr(
+    udt_ExternalObjectVar *self,        // object
+    PyObject *nameObject)               // name of attribute
+{
+    udt_ObjectAttribute *attribute;
+
+    attribute = (udt_ObjectAttribute*)
+            PyDict_GetItem(self->objectType->attributesByName, nameObject);
+    if (attribute)
+        return ExternalObjectVar_GetAttributeValue(self, attribute);
+
+    return PyObject_GenericGetAttr( (PyObject*) self, nameObject);
+}
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/HISTORY.txt b/desktop/core/ext-py/cx_Oracle-5.1.2/HISTORY.txt
new file mode 100644
index 0000000..5077353
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/HISTORY.txt
@@ -0,0 +1,715 @@
+Changes from 5.1.1 to 5.1.2
+ 1) Added support for LONG_UNICODE which is a type used to handle long unicode
+    strings. These are not explicitly supported in Oracle but can be used to
+    bind to NCLOB, for example, without getting the error "unimplemented or
+    unreasonable conversion requested".
+ 2) Set the row number in a cursor when executing PL/SQL blocks as requested
+    by Robert Ritchie.
+ 3) Added support for setting the module, action and client_info attributes
+    during connection so that logon triggers will see the supplied values, as
+    requested by Rodney Barnett.
+
+Changes from 5.1 to 5.1.1
+ 1) Simplify management of threads for callbacks performed by database change
+    notification and eliminate a crash that occurred under high load in
+    certain situations. Thanks to Calvin S. for noting the issue and suggesting
+    a solution and testing the patch.
+ 2) Force server detach on close so that the connection is completely closed
+    and not just the session as before.
+ 3) Force use of OCI_UTF16ID for NCLOBs as using the default character set
+    would result in ORA-03127 with Oracle 11.2.0.2 and UTF8 character set.
+ 4) Avoid attempting to clear temporary LOBs a second time when destroying the
+    variable as in certain situations this results in spurious errors.
+ 5) Added additional parameter service_name to makedsn() which can be used to
+    use the service_name rather than the SID in the DSN string that is
+    generated.
+ 6) Fix cursor description in test suite to take into account the number of
+    bytes per character.
+ 7) Added tests for NCLOBS to the test suite.
+ 8) Removed redundant code in setup.py for calculating the library path.
+
+Changes from 5.0.4 to 5.1
+ 1) Remove support for UNICODE mode and permit Unicode to be passed through in
+    everywhere a string may be passed in. This means that strings will be
+    passed through to Oracle using the value of the NLS_LANG environment
+    variable in Python 3.x as well. Doing this eliminated a bunch of problems
+    that were discovered by using UNICODE mode and also removed an unnecessary
+    restriction in Python 2.x that Unicode could not be used in connect strings
+    or SQL statements, for example.
+ 2) Added support for creating an empty object variable via a named type, the
+    first step to adding full object support.
+ 3) Added support for Python 3.2.
+ 4) Account for lib64 used on x86_64 systems. Thanks to Alex Wood for supplying
+    the patch.
+ 5) Clear up potential problems when calling cursor.close() ahead of the
+    cursor being freed by going out of scope.
+ 6) Avoid compilation difficulties on AIX5 as OCIPing does not appear to be
+    available on that platform under Oracle 10g Release 2. Thanks to
+    Pierre-Yves Fontaniere for the patch.
+ 7) Free temporary LOBs prior to each fetch in order to avoid leaking them.
+    Thanks to Uwe Hoffmann for the initial patch.
+
+Changes from 5.0.3 to 5.0.4
+ 1) Added support for Python 2.7.
+ 2) Added support for new parameter (port) for subscription() call which allows
+    the client to specify the listening port for callback notifications from
+    the database server. Thanks to Geoffrey Weber for the initial patch.
+ 3) Fixed compilation under Oracle 9i.
+ 4) Fixed a few error messages.
+
+Changes from 5.0.2 to 5.0.3
+ 1) Added support for 64-bit Windows.
+ 2) Added support for Python 3.1 and dropped support for Python 3.0.
+ 3) Added support for keyword arguments in cursor.callproc() and
+    cursor.callfunc().
+ 4) Added documentation for the UNICODE and FIXED_UNICODE variable types.
+ 5) Added extra link arguments required for Mac OS X as suggested by Jason
+    Woodward.
+ 6) Added additional error codes to the list of error codes that raise
+    OperationalError rather than DatabaseError.
+ 7) Fixed calculation of display size for strings with national database
+    character sets that are not the default AL16UTF16.
+ 8) Moved the resetting of the setinputsizes flag before the binding takes
+    place so that if an error takes place and a new statement is prepared
+    subsequently, spurious errors will not occur.
+ 9) Fixed compilation with Oracle 10g Release 1.
+10) Tweaked documentation based on feedback from a number of people.
+11) Added support for running the test suite using "python setup.py test"
+12) Added support for setting the CLIENT_IDENTIFIER value in the v$session
+    table for connections.
+13) Added exception when attempting to call executemany() with arrays which is
+    not supported by the OCI.
+14) Fixed bug when converting from decimal would result in OCI-22062 because
+    the locale decimal point was not a period. Thanks to Amaury Forgeot d'Arc
+    for the solution to this problem.
+
+Changes from 5.0.1 to 5.0.2
+ 1) Fix creation of temporary NCLOB values and the writing of NCLOB values in
+    non Unicode mode.
+ 2) Re-enabled parsing of non select statements as requested by Roy Terrill.
+ 3) Implemented a parse error offset as requested by Catherine Devlin.
+ 4) Removed lib subdirectory when forcing RPATH now that the library directory
+    is being calculated exactly in setup.py.
+ 5) Added an additional cast in order to support compiling by Microsoft
+    Visual C++ 2008 as requested by Marco de Paoli.
+ 6) Added additional include directory to setup.py in order to support
+    compiling by Microsoft Visual Studio was requested by Jason Coombs.
+ 7) Fixed a few documentation issues.
+
+Changes from 5.0 to 5.0.1
+ 1) Added support for database change notification available in Oracle 10g
+    Release 2 and higher.
+ 2) Fix bug where NCLOB data would be corrupted upon retrieval (non Unicode
+    mode) or would generate exception ORA-24806 (LOB form mismatch). Oracle
+    insists upon differentiating between CLOB and NCLOB no matter which
+    character set is being used for retrieval.
+ 3) Add new attributes size, bufferSize and numElements to variable objects,
+    deprecating allocelems (replaced by numElements) and maxlength (replaced
+    by bufferSize)
+ 4) Avoid increasing memory allocation for strings when using variable width
+    character sets and increasing the number of elements in a variable during
+    executemany().
+ 5) Tweaked code in order to ensure that cx_Oracle can compile with Python
+    3.0.1.
+
+Changes from 4.4.1 to 5.0
+ 1) Added support for Python 3.0 with much help from Amaury Forgeot d'Arc.
+ 2) Removed support for Python 2.3 and Oracle 8i.
+ 3) Added support for full unicode mode in Python 2.x where all strings are
+    passed in and returned as unicode (module must be built in this mode)
+    rather than encoded strings
+ 4) nchar and nvarchar columns now return unicode instead of encoded strings
+ 5) Added support for an output type handler and/or an input type handler to be
+    specified at the connection and cursor levels.
+ 6) Added support for specifying both input and output converters for variables
+ 7) Added support for specifying the array size of variables that are created
+    using the cursor.var() method
+ 8) Added support for events mode and database resident connection pooling
+    (DRCP) in Oracle 11g.
+ 9) Added support for changing the password during construction of a new
+    connection object as well as after the connection object has been created
+10) Added support for the interval day to second data type in Oracle,
+    represented as datetime.timedelta objects in Python.
+11) Added support for getting and setting the current_schema attribute for a
+    session
+12) Added support for proxy authentication in session pools as requested by
+    Michael Wegrzynek (and thanks for the initial patch as well).
+13) Modified connection.prepare() to return a boolean indicating if a
+    transaction was actually prepared in order to avoid the error ORA-24756
+    (transaction does not exist).
+14) Raise a cx_Oracle.Error instance rather than a string for column
+    truncation errors as requested by Helge Tesdal.
+15) Fixed handling of environment handles in session pools in order to allow
+    session pools to fetch objects without exceptions taking place.
+
+Changes from 4.4 to 4.4.1
+ 1) Make the bind variables and fetch variables accessible although they need
+    to be treated carefully since they are used internally; support added for
+    forward compatibility with version 5.x.
+ 2) Include the "cannot insert null value" in the list of errors that are
+    treated as integrity errors as requested by Matt Boersma.
+ 3) Use a cx_Oracle.Error instance rather than a string to hold the error when
+    truncation (ORA-1406) takes place as requested by Helge Tesdal.
+ 4) Added support for fixed char, old style varchar and timestamp attribute
+    values in objects.
+ 5) Tweaked setup.py to check for the Oracle version up front rather than
+    during the build in order to produce more meaningful errors and simplify
+    the code.
+ 6) In setup.py added proper detection for the instant client on Mac OS X as
+    recommended by Martijn Pieters.
+ 7) In setup.py, avoided resetting the extraLinkArgs on Mac OS X as doing so
+    prevents simple modification where desired as expressed by Christian
+    Zagrodnick.
+ 8) Added documentation on exception handling as requested by Andreas Mock, who
+    also graciously provided an initial patch.
+ 9) Modified documentation indicating that the password attribute on connection
+    objects can be written.
+10) Added documentation warning that parameters not passed in during subsequent
+    executions of a statement will retain their original values as requested by
+    Harald Armin Massa.
+11) Added comments indicating that an Oracle client is required since so many
+    people find this surprising.
+12) Removed all references to Oracle 8i from the documentation and version 5.x
+    will eliminate all vestiges of support for this version of the Oracle
+    client.
+13) Added additional link arguments for Cygwin as requested by Rob Gillen.
+
+Changes from 4.3.3 to 4.4
+ 1) Fix setup.py to handle the Oracle instant client and Oracle XE on both
+    Linux and Windows as pointed out by many. Thanks also to the many people
+    who also provided patches.
+ 2) Set the default array size to 50 instead of 1 as the DB API suggests
+    because the performance difference is so drastic and many people have
+    recommended that the default be changed.
+ 3) Added Py_BEGIN_ALLOW_THREADS and Py_END_ALLOW_THREADS around each blocking
+    call for LOBs as requested by Jason Conroy who also provided an initial
+    patch and performed a number of tests that demonstrate the new code is much
+    more responsive.
+ 4) Add support for acquiring cursor.description after a parse.
+ 5) Defer type assignment when performing executemany() until the last possible
+    moment if the value being bound in is null as suggested by Dragos Dociu.
+ 6) When dropping a connection from the pool, ignore any errors that occur
+    during the rollback; unfortunately, Oracle decides to commit data even when
+    dropping a connection from the pool instead of rolling it back so the
+    attempt still has to be made.
+ 7) Added support for setting CLIENT_DRIVER in V$SESSION_CONNECT_INFO in Oracle
+    11g and higher.
+ 8) Use cx_Oracle.InterfaceError rather than the builtin RuntimeError when
+    unable to create the Oracle environment object as requested by Luke Mewburn
+    since the error is specific to Oracle and someone attempting to catch any
+    exception cannot simply use cx_Oracle.Error.
+ 9) Translated some error codes to OperationalError as requested by Matthew
+    Harriger; translated if/elseif/else logic to switch statement to make it
+    more readable and to allow for additional translation if desired.
+10) Transformed documentation to new format using restructured text. Thanks to
+    Waldemar Osuch for contributing the initial draft of the new documentation.
+11) Allow the password to be overwritten by a new value as requested by Alex
+    VanderWoude; this value is retained as a convenience to the user and not
+    used by anything in the module; if changed externally it may be convenient
+    to keep this copy up to date.
+12) Cygwin is on Windows so should be treated in the same way as noted by
+    Matthew Cahn.
+13) Add support for using setuptools if so desired as requested by Shreya
+    Bhatt.
+14) Specify that the version of Oracle 10 that is now primarily used is 10.2,
+    not 10.1.
+
+Changes from 4.3.2 to 4.3.3
+ 1) Added method ping() on connections which can be used to test whether or not
+    a connection is still active (available in Oracle 10g R2).
+ 2) Added method cx_Oracle.clientversion() which returns a 5-tuple giving the
+    version of the client that is in use (available in Oracle 10g R2).
+ 3) Added methods startup() and shutdown() on connections which can be used to
+    startup and shutdown databases (available in Oracle 10g R2).
+ 4) Added support for Oracle 11g.
+ 5) Added samples directory which contains a handful of scripts containing
+    sample code for more advanced techniques. More will follow in future
+    releases.
+ 6) Prevent error "ORA-24333: zero iteration count" when calling executemany()
+    with zero rows as requested by Andreas Mock.
+ 7) Added methods __enter__() and __exit__() on connections to support using
+    connections as context managers in Python 2.5 and higher. The context
+    managed is the transaction state. Upon exit the transaction is either
+    rolled back or committed depending on whether an exception took place or
+    not.
+ 8) Make the search for the lib32 and lib64 directories automatic for all
+    platforms.
+ 9) Tweak the setup configuration script to include all of the metadata and
+    allow for building the module within another setup configuration script
+10) Include the Oracle version in addition to the Python version in the build
+    directories that are created and in the names of the binary packages that
+    are created.
+11) Remove unnecessary dependency on win32api to build module on Windows.
+
+Changes from 4.3.1 to 4.3.2
+ 1) Added methods open(), close(), isopen() and getchunksize() in order to
+    improve performance of reading/writing LOB values in chunks.
+ 2) Fixed support for native doubles and floats in Oracle 10g; added new type
+    NATIVE_FLOAT to allow specification of a variable of that specific type
+    where desired. Thanks to D.R. Boxhoorn for pointing out the fact that this
+    was not working properly when the arraysize was anything other than 1.
+ 3) When calling connection.begin(), only create a new tranasction handle if
+    one is not already associated with the connection. Thanks to Andreas Mock
+    for discovering this and for Amaury Forgeot d'Arc for diagnosing the
+    problem and pointing the way to a solution.
+ 4) Added attribute cursor.rowfactory which allows a method to be called for
+    each row that is returned; this is about 20% faster than calling the method
+    in Python using the idiom [method(*r) for r in cursor].
+ 5) Attempt to locate an Oracle installation by looking at the PATH if the
+    environment variable ORACLE_HOME is not set; this is of primary use on
+    Windows where this variable should not normally be set.
+ 6) Added support for autocommit mode as requested by Ian Kelly.
+ 7) Added support for connection.stmtcachesize which allows for both reading
+    and writing the size of the statement cache size. This parameter can make a
+    huge difference with the length of time taken to prepare statements. Added
+    support for setting the statement tag when preparing a statement. Both of
+    these were requested by Bjorn Sandberg who also provided an initial patch.
+ 8) When copying the value of a variable, copy the return code as well.
+
+Changes from 4.3 to 4.3.1
+ 1) Ensure that if the client buffer size exceeds 4000 bytes that the server
+    buffer size does not as strings may only contain 4000 bytes; this allows
+    handling of multibyte character sets on the server as well as the client.
+ 2) Added support for using buffer objects to populate binary data and made the
+    Binary() constructor the buffer type as requested by Ken Mason.
+ 3) Fix potential crash when using full optimization with some compilers.
+    Thanks to Aris Motas for noticing this and providing the initial patch and
+    to Amaury Forgeot d'Arc for providing an even simpler solution.
+ 4) Pass the correct charset form in to the write call in order to support
+    writing to national character set LOB values properly. Thanks to Ian Kelly
+    for noticing this discrepancy.
+
+Changes from 4.2.1 to 4.3
+ 1) Added preliminary support for fetching Oracle objects (SQL types) as
+    requested by Kristof Beyls (who kindly provided an initial patch).
+    Additional work needs to be done to support binding and updating objects
+    but the basic structure is now in place.
+ 2) Added connection.maxBytesPerCharacter which indicates the maximum number of
+    bytes each character can use; use this value to also determine the size of
+    local buffers in order to handle discrepancies between the client character
+    set and the server character set. Thanks to Andreas Mock for providing the
+    initial patch and working with me to resolve this issue.
+ 3) Added support for querying native floats in Oracle 10g as requested by
+    Danny Boxhoorn.
+ 4) Add support for temporary LOB variables created via PL/SQL instead of only
+    directly by cx_Oracle; thanks to Henning von Bargen for discovering this
+    problem.
+ 5) Added support for specifying variable types using the builtin types int,
+    float, str and datetime.date which allows for finer control of what type of
+    Python object is returned from cursor.callfunc() for example.
+ 6) Added support for passing booleans to callproc() and callfunc() as
+    requested by Anana Aiyer.
+ 7) Fixed support for 64-bit environments in Python 2.5.
+ 8) Thanks to Filip Ballegeer and a number of his co-workers, an intermittent
+    crash was tracked down; specifically, if a connection is closed, then the
+    call to OCIStmtRelease() will free memory twice. Preventing the call when
+    the connection is closed solves the problem.
+
+Changes from 4.2 to 4.2.1
+ 1) Added additional type (NCLOB) to handle CLOBs that use the national
+    character set as requested by Chris Dunscombe.
+ 2) Added support for returning cursors from functions as requested by Daniel
+    Steinmann.
+ 3) Added support for getting/setting the "get" mode on session pools as
+    requested by Anand Aiyer.
+ 4) Added support for binding subclassed cursors.
+ 5) Fixed binding of decimal objects with absolute values less than 0.1.
+
+Changes from 4.1.2 to 4.2
+ 1) Added support for parsing an Oracle statement as requested by Patrick
+    Blackwill.
+ 2) Added support for BFILEs at the request of Matthew Cahn.
+ 3) Added support for binding decimal.Decimal objects to cursors.
+ 4) Added support for reading from NCLOBs as requested by Chris Dunscombe.
+ 5) Added connection attributes encoding and nencoding which return the IANA
+    character set name for the character set and national character set in use
+    by the client.
+ 6) Rework module initialization to use the techniques recommended by the
+    Python documentation as one user was experiencing random segfaults due
+    to the use of the module dictionary after the initialization was complete.
+ 7) Removed support for the OPT_Threading attribute. Use the threaded keyword
+    when creating connections and session pools instead.
+ 8) Removed support for the OPT_NumbersAsStrings attribute. Use the
+    numbersAsStrings attribute on cursors instead.
+ 9) Use type long rather than type int in order to support long integers on
+    64-bit machines as reported by Uwe Hoffmann.
+10) Add cursor attribute "bindarraysize" which is defaulted to 1 and is used
+    to determine the size of the arrays created for bind variables.
+11) Added repr() methods to provide something a little more useful than the
+    standard type name and memory address.
+12) Added keyword argument support to the functions that imply such in the
+    documentation as requested by Harald Armin Massa.
+13) Treat an empty dictionary passed through to cursor.execute() as keyword
+    arguments the same as if no keyword arguments were specified at all, as
+    requested by Fabien Grumelard.
+14) Fixed memory leak when a LOB read would fail.
+15) Set the LDFLAGS value in the environment rather than directly in the
+    setup.py file in order to satisfy those who wish to enable the use of
+    debugging symbols.
+16) Use __DATE__ and __TIME__ to determine the date and time of the build
+    rather than passing it through directly.
+17) Use Oracle types and add casts to reduce warnings as requested by Amaury
+    Forgeot d'Arc.
+18) Fixed typo in error message.
+
+Changes from 4.1.1 to 4.1.2
+ 1) Restore support of Oracle 9i features when using the Oracle 10g client.
+
+Changes from 4.1 to 4.1.1
+ 1) Add support for dropping a connection from a session pool.
+ 2) Add support for write only attributes "module", "action" and "clientinfo"
+    which work only in Oracle 10g as requested by Egor Starostin.
+ 3) Add support for pickling database errors.
+ 4) Use the previously created bind variable as a template if available when
+    creating a new variable of a larger size. Thanks to Ted Skolnick for the
+    initial patch.
+ 5) Fixed tests to work properly in the Python 2.4 environment where dates and
+    timestamps are different Python types. Thanks to Henning von Bargen for
+    pointing this out.
+ 6) Added additional directories to search for include files and libraries in
+    order to better support the Oracle 10g instant client.
+ 7) Set the internal fetch number to 0 in order to satisfy very picky source
+    analysis tools as requested by Amaury Fogeot d'Arc.
+ 8) Improve the documentation for building and installing the module from
+    source as some people are unaware of the standard methods for building
+    Python modules using distutils.
+ 9) Added note in the documentation indicating that the arraysize attribute
+    can drastically affect performance of queries since this seems to be a
+    common misunderstanding of first time users of cx_Oracle.
+10) Add a comment indicating that on HP-UX Itanium with Oracle 10g the library
+    ttsh10 must alos be linked against. Thanks to Bernard Delmee for the
+    information.
+
+Changes from 4.1 beta 1 to 4.1
+ 1) Fixed bug where subclasses of Cursor do not pass the connection in the
+    constructor causing a segfault.
+ 2) DDL statements must be reparsed before execution as noted by Mihai
+    Ibanescu.
+ 3) Add support for setting input sizes by position.
+ 4) Fixed problem with catching an exception during execute and then still
+    attempting to perform a fetch afterwards as noted by Leith Parkin.
+ 5) Rename the types so that they can be pickled and unpickled. Thanks to Harri
+    Pasanen for pointing out the problem.
+ 6) Handle invalid NLS_LANG setting properly (Oracle seems to like to provide a
+    handle back even though it is invalid) and determine the number of bytes
+    per character in order to allow for proper support in the future of
+    multibyte and variable width character sets.
+ 7) Remove date checking from the native case since Python already checks that
+    dates are valid; enhance error message when invalid dates are encountered
+    so that additional processing can be done.
+ 8) Fix bug executing SQL using numeric parameter names with predefined
+    variables (such as what takes place when calling stored procedures with out
+    parameters).
+ 9) Add support for reading CLOB values using multibyte or variable length
+    character sets.
+
+Changes from 4.0.1 to 4.1 beta 1
+ 1) Added support for Python 2.4. In Python 2.4, the datetime module is used
+    for both binding and fetching of date and timestamp data. In Python 2.3,
+    objects from the datetime module can be bound but the internal datetime
+    objects will be returned from queries.
+ 2) Added pickling support for LOB and datetime data.
+ 3) Fully qualified the table name that was missing in an alter table
+    statement in the setup test script as noted by Marc Gehling.
+ 4) Added a section allowing for the setting of the RPATH linker directive in
+    setup.py as requested by Iustin Pop.
+ 5) Added code to raise a programming error exception when an attempt is made
+    to access a LOB locator variable in a subsequent fetch.
+ 6) The username, password and dsn (tnsentry) are stored on the connection
+    object when specified, regardless of whether or not a standard connection
+    takes place.
+ 7) Added additional module level constant called "LOB" as requested by Joseph
+    Canedo.
+ 8) Changed exception type to IntegrityError for constraint violations as
+    requested by Joseph Canedo.
+ 9) If scale and precision are not specified, an attempt is made to return a
+    long integer as requested by Joseph Canedo.
+10) Added workaround for Oracle bug which returns an invalid handle when the
+    prepare call fails. Thanks to alantam@hsbc.com for providing the code that
+    demonstrated the problem.
+11) The cusor method arravar() will now accept the actual list so that it is
+    not necessary to call cursor.arrayvar() followed immediately by
+    var.setvalue().
+12) Fixed bug where attempts to execute the statement "None" with bind
+    variables would cause a segmentation fault.
+13) Added support for binding by position (paramstyle = "numeric").
+14) Removed memory leak created by calls to OCIParamGet() which were not
+    mirrored by calls to OCIDescriptorFree(). Thanks to Mihai Ibanescu for
+    pointing this out and providing a patch.
+15) Added support for calling cursor.executemany() with statement None
+    implying that the previously prepared statement ought to be executed.
+    Thanks to Mihai Ibanescu for providing a patch.
+16) Added support for rebinding variables when a subsequent call to
+    cursor.executemany() uses a different number of rows. Thanks to Mihai
+    Ibanescu for supplying a patch.
+17) The microseconds are now displayed in datetime variables when nonzero
+    similar to method used in the datetime module.
+18) Added support for binary_float and binary_double columns in Oracle 10g.
+
+Changes from 4.0 to 4.0.1
+ 1) Fixed bugs on 64-bit platforms that caused segmentation faults and bus
+    errors in session pooling and determining the bind variables associated
+    with a statement.
+ 2) Modified test suite so that 64-bit platforms are tested properly.
+ 3) Added missing commit statements in the test setup scripts. Thanks to Keith
+    Lyon for pointing this out.
+ 4) Fix setup.py for Cygwin environments. Thanks to Doug Henderson for
+    providing the necessary fix.
+ 5) Added support for compiling cx_Oracle without thread support. Thanks to
+    Andre Reitz for pointing this out.
+ 6) Added support for a new keyword parameter called threaded on connections
+    and session pools. This parameter defaults to False and indicates whether
+    threaded mode ought to be used. It replaces the module level attribute
+    OPT_Threading although examining the attribute will be retained until the
+    next release at least.
+ 7) Added support for a new keyword parameter called twophase on connections.
+    This parameter defaults to False and indicates whether support for two
+    phase (distributed or global) transactions ought to be present. Note that
+    support for distributed transactions is buggy when crossing major version
+    boundaries (Oracle 8i to Oracle 9i for example).
+ 8) Ensure that the rowcount attribute is set properly when an exception is
+    raised during execution. Thanks to Gary Aviv for pointing out this problem
+    and its solution.
+
+Changes from 3.1 to 4.0
+ 1) Added support for subclassing connections, cursors and session pools. The
+    changes involved made it necessary to drop support for Python 2.1 and
+    earlier although a branch exists in CVS to allow for support of Python 2.1
+    and earlier if needed.
+ 2) Connections and session pools can now be created with keyword parameters,
+    not just sequential parameters.
+ 3) Queries now return integers whenever possible and long integers if the
+    number will overflow a simple integer. Floats are only returned when it is
+    known that the number is a floating point number or the integer conversion
+    fails.
+ 4) Added initial support for user callbacks on OCI functions. See the
+    documentation for more details.
+ 5) Add support for retrieving the bind variable names associated with a
+    cursor with a new method bindnames().
+ 6) Add support for temporary LOB variables. This means that setinputsizes()
+    can be used with the values CLOB and BLOB to create these temporary LOB
+    variables and allow for the equivalent of empty_clob() and empty_blob()
+    since otherwise Oracle will treat empty strings as NULL values.
+ 7) Automatically switch to long strings when the data size exceeds the
+    maximum string size that Oracle allows (4000 characters) and raise an
+    error if an attempt is made to set a string variable to a size that it
+    does not support. This avoids truncation errors as reported by Jon Franz.
+ 8) Add support for global (distributed) transactions and two phase commit.
+ 9) Force the NLS settings for the session so that test tables are populated
+    correctly in all circumstances; problems were noted by Ralf Braun and
+    Allan Poulsen.
+10) Display error messages using the environment handle when the error handle
+    has not yet been created; this provides better error messages during this
+    rather rare situation.
+11) Removed memory leak in callproc() that was reported by Todd Whiteman.
+12) Make consistent the calls to manipulate memory; otherwise segfaults can
+    occur when the pymalloc option is used, as reported by Matt Hoskins.
+13) Force a rollback when a session is released back to the session pool.
+    Apparently the connections are not as stateless as Oracle's documentation
+    suggests and this makes the logic consistent with normal connections.
+14) Removed module method attach(). This can be replaced with a call to
+    Connection(handle=) if needed.
+
+Changes from 3.0a to 3.1
+ 1) Added support for connecting with SYSDBA and SYSOPER access which is
+    needed for connecting as sys in Oracle 9i.
+ 2) Only check the dictionary size if the variable is not NULL; otherwise, an
+    error takes place which is not caught or cleared; this eliminates a
+    spurious "Objects/dictobject.c:1258: bad argument to internal function" in
+    Python 2.3.
+ 3) Add support for session pooling. This is only support for Oracle 9i but
+    is amazingly fast -- about 100 times faster than connecting.
+ 4) Add support for statement caching when pooling sessions, this reduces the
+    parse time considerably. Unfortunately, the Oracle OCI does not allow this
+    to be easily turned on for normal sessions.
+ 5) Add method trim() on CLOB and BLOB variables for trimming the size.
+ 6) Add support for externally identified users; to use this feature leave the
+    username and password fields empty when connecting.
+ 7) Add method cancel() on connection objects to cancel long running queries.
+    Note that this only works on non-Windows platforms.
+ 8) Add method callfunc() on cursor objects to allow calling a function
+    without using an anonymous PL/SQL block.
+ 9) Added documentation on objects that were not documented. At this point all
+    objects, methods and constants in cx_Oracle have been documented.
+10) Added support for timestamp columns in Oracle 9i.
+11) Added module level method makedsn() which creates a data source name given
+    the host, port and SID.
+12) Added constant "buildtime" which is the time when the module was built as
+    an additional means of identifying the build that is in use.
+13) Binding a value that is incompatible to the previous value that was bound
+    (data types do not match or array size is larger) will now result in a
+    new bind taking place. This is more consistent with the DB API although
+    it does imply a performance penalty when used.
+
+Changes from 3.0 to 3.0a
+ 1) Fixed bug where zero length PL/SQL arrays were being mishandled
+ 2) Fixed support for the data type "float" in Oracle; added one to the
+    display size to allow for the sign of the number, if necessary; changed
+    the display size of unconstrained numbers to 127, which is the largest
+    number that Oracle can handle
+ 3) Added support for retrieving the description of a bound cursor before
+    fetching it
+ 4) Fixed a couple of build issues on Mac OS X, AIX and Solaris (64-bit)
+ 5) Modified documentation slightly based on comments from several people
+ 6) Included files in MANIFEST that are needed to generate the binaries
+ 7) Modified test suite to work within the test environment at Computronix
+    as well as within the packages that are distributed
+
+Changes from 2.5a to 3.0
+ 1) Removed support for connection to Oracle7 databases; it is entirely
+    possible that it will still work but I no longer have any way of testing
+    and Oracle has dropped any meaningful support for Oracle7 anyway
+ 2) Fetching of strings is now done with predefined memory areas rather than
+    dynamic memory areas; dynamic fetching of strings was causing problems
+    with Oracle 9i in some instances and databases using a different character
+    set other than US ASCII
+ 3) Fixed bug where segfault would occur if the '/' character preceded the '@'
+    character in a connect string
+ 4) Added two new cursor methods var() and arrayvar() in order to eliminate
+    the need for setinputsizes() when defining PL/SQL arrays and as a generic
+    method of acquiring bind variables directly when needed
+ 5) Fixed support for binding cursors and added support for fetching cursors
+    (these are known as ref cursors in PL/SQL).
+ 6) Eliminated discrepancy between the array size used internally and the
+    array size specified by the interface user; this was done earlier to avoid
+    bus errors on 64-bit platforms but another way has been found to get
+    around that issue and a number of people were getting confused because of
+    the discrepancy
+ 7) Added support for the attribute "connection" on cursors, an optional
+    DB API extension
+ 8) Added support for passing a dictionary as the second parameter for the
+    cursor.execute() method in order to comply with the DB API more closely;
+    the method of passing parameters with keyword arguments is still supported
+    and is in fact preferred
+ 9) Added support for the attribute "statement" on cursors which is a
+    reference to the last SQL statement prepared or executed
+10) Added support for passing any sequence to callproc() rather than just
+    lists as before
+11) Fixed bug where segfault would occur if the array size was changed after
+    the cursor was executed but before it was fetched
+12) Ignore array size when performing executemany() and use the length of the
+    list of arguments instead
+13) Rollback when connection is closed or destroyed to follow DB API rather
+    than use the Oracle default (which is commit)
+14) Added check for array size too large causing an integer overflow
+15) Added support for iterators for Python 2.2 and above
+16) Added test suite based on PyUnitTest
+17) Added documentation in HTML format similar to the documentation for the
+    core Python library
+
+Changes from 2.5 to 2.5a
+ 1) Fix problem with Oracle 9i and retrieving strings; it seems that Oracle 9i
+    uses the correct method for dynamic callback but Oracle 8i will not work
+    with that method so an #ifdef was added to check for the existence of an
+    Oracle 9i feature; thanks to Paul Denize for discovering this problem
+
+Changes from 2.4 to 2.5
+ 1) Added flag OPT_NoOracle7 which, if set, assumes that connections are being
+    made to Oracle8 or higher databases; this allows for eliminating the
+    overhead in performing this check at connect time
+ 2) Added flag OPT_NumbersAsStrings which, if set, returns all numbers as
+    strings rather than integers or floats; this flag is used when defined
+    variables are created (during select statements only)
+ 3) Added flag OPT_Threading which, if set, uses OCI threading mode; there is a
+    significant performance degradation in this mode (about 15-20%) but it does
+    allow threads to share connections (threadsafety level 2 according to the
+    Python Database API 2.0); note that in order to support this, Oracle 8i or
+    higher is now required
+ 4) Added Py_BEGIN_ALLOW_THREADS and Py_END_ALLOW_THREADS pairs where
+    applicable to support threading during blocking OCI calls
+ 5) Added global method attach() to cx_Oracle to support attaching to an
+    existing database handle (as provided by PowerBuilder, for example)
+ 6) Eliminated the cursor method fetchbinds() which was used for returning the
+    list of bind variables after execution to get the values of out variables;
+    the cursor method setinputsizes() was modified to return the list of bind
+    variables and the cursor method execute() was modified to return the list
+    of defined variables in the case of a select statement being executed;
+    these variables have three methods available to them: getvalue([<pos>]) to
+    get the value of a variable, setvalue(<pos>, <value>) to set its value and
+    copy(<var>, <src_pos>, <targ_pos>) to copy the value from a variable in a
+    more efficient manner than setvalue(getvalue())
+ 7) Implemented cursor method executemany() which expects a list of
+    dictionaries for the arguments
+ 8) Implemented cursor method callproc()
+ 9) Added cursr method prepare() which parses (prepares) the statement for
+    execution; subsequent execute() or executemany() calls can pass None as the
+    statement which will imply use of the previously prepared statement; used
+    for high performance only
+10) Added cursor method fetchraw() which will perform a raw fetch of the cursor
+    returning the number of rows thus fetched; this is used to avoid the
+    overhead of generating result sets; used for high performance only
+11) Added cursor method executemanyprepared() which is identical to the method
+    executemany() except that it takes a single argument which is the number of
+    times to execute a previously prepared statement and it assumes that the
+    bind variables already have their values set; used for high performance
+    only
+12) Added support for rowid being returned in a select statement
+13) Added support for comparing dates returned by cx_Oracle
+14) Integrated patch from Andre Reitz to set the null ok flag in the
+    description attribute of the cursor
+15) Integrated patch from Andre Reitz to setup.py to support compilation with
+    Python 1.5
+16) Integrated patch from Benjamin Kearns to setup.py to support compilation
+    on Cygwin
+
+Changes from 2.3 to 2.4
+
+1) String variables can now be made any length (previously restricted to the
+   64K limit imposed by Oracle for default binding); use the type
+   cx_Oracle.LONG_STRING as the argument to setinputsizes() for binding in
+   string values larger than 4000 bytes.
+2) Raw and long raw columns are now supported; use the types cx_Oracle.BINARY
+   and cx_Oracle.LONG_BINARY as the argument to setinputsizes() for binding in
+   values of these types.
+3) Functions DateFromTicks(), TimeFromTicks() and TimestampFromTicks()
+   are now implemented.
+4) Function cursor.setoutputsize() implemented
+5) Added the ability to bind arrays as out parameters to procedures; use the
+   format [cx_Oracle.<DataType>, <NumElems>] as the input to the function
+   setinputsizes() for binding arrays
+6) Discovered from the Oracle 8.1.6 version of the documentation of the OCI
+   libraries, that the size of the memory location required for the precision
+   variable is larger than the printed documentation says; this was causing a
+   problem with the code on the Sun platform.
+7) Now support building RPMs for Linux.
+
+Changes from 2.2 to 2.3
+
+ 1) Incremental performance enhancements (dealing with reusing cursors and
+    bind handles)
+ 2) Ensured that arrays of integers with a single float in them are all
+    treated as floats, as suggested by Martin Koch.
+ 3) Fixed code dealing with scale and precision for both defining a numeric
+    variable and for providing the cursor description; this eliminates the
+    problem of an underflow error (OCI-22054) when retrieving data with
+    non-zero scale.
+
+Changes from 2.1 to 2.2
+
+ 1) Upgraded thread safety to level 1 (according to the Python DB API 2.0) as
+    an internal project required the ability to share the module between
+    threads.
+ 2) Added ability to bind ref cursors to PL/SQL blocks as requested by
+    Brad Powell.
+ 3) Added function write(Value, [Offset]) to LOB variables as requested by
+    Matthias Kirst.
+ 4) Procedure execute() on Cursor objects now permits a value None for the
+    statement which means that the previously prepared statement will be
+    executed and any input sizes set earlier will be retained. This was done to
+    improve the performance of scripts that execute one statement many times.
+ 5) Modified module global constants BINARY and DATETIME to point to the
+    external representations of those types so that the expression
+    type(var) == cx_Oracle.DATETIME will work as expected.
+ 6) Added global constant version to provide means of determining the current
+    version of the module.
+ 7) Modified error checking routine to distinguish between an Oracle error and
+    invalid handles.
+ 8) Added error checking to avoid setting the value of a bind variable to a
+    value that it cannot support and raised an exception to indicate this fact.
+ 9) Added extra compile arguments for the AIX platform as suggested by Jehwan
+    Ryu.
+10) Added section to the README to indicate the method for a binary
+    installation as suggested by Steve Holden.
+11) Added simple usage example as requested by many people.
+12) Added HISTORY file to the distribution.
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/IntervalVar.c b/desktop/core/ext-py/cx_Oracle-5.1.2/IntervalVar.c
new file mode 100644
index 0000000..9555424
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/IntervalVar.c
@@ -0,0 +1,160 @@
+//-----------------------------------------------------------------------------
+// IntervalVar.c
+//   Defines the routines for handling interval variables.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// Interval type
+//-----------------------------------------------------------------------------
+typedef struct {
+    Variable_HEAD
+    OCIInterval **data;
+} udt_IntervalVar;
+
+
+//-----------------------------------------------------------------------------
+// Declaration of interval variable functions.
+//-----------------------------------------------------------------------------
+static int IntervalVar_Initialize(udt_IntervalVar*, udt_Cursor*);
+static void IntervalVar_Finalize(udt_IntervalVar*);
+static int IntervalVar_SetValue(udt_IntervalVar*, unsigned, PyObject*);
+static PyObject *IntervalVar_GetValue(udt_IntervalVar*, unsigned);
+
+
+//-----------------------------------------------------------------------------
+// Python type declarations
+//-----------------------------------------------------------------------------
+static PyTypeObject g_IntervalVarType = {
+    PyVarObject_HEAD_INIT(NULL, 0)
+    "cx_Oracle.INTERVAL",               // tp_name
+    sizeof(udt_IntervalVar),            // tp_basicsize
+    0,                                  // tp_itemsize
+    0,                                  // tp_dealloc
+    0,                                  // tp_print
+    0,                                  // tp_getattr
+    0,                                  // tp_setattr
+    0,                                  // tp_compare
+    0,                                  // tp_repr
+    0,                                  // tp_as_number
+    0,                                  // tp_as_sequence
+    0,                                  // tp_as_mapping
+    0,                                  // tp_hash
+    0,                                  // tp_call
+    0,                                  // tp_str
+    0,                                  // tp_getattro
+    0,                                  // tp_setattro
+    0,                                  // tp_as_buffer
+    Py_TPFLAGS_DEFAULT,                 // tp_flags
+    0                                   // tp_doc
+};
+
+
+//-----------------------------------------------------------------------------
+// variable type declarations
+//-----------------------------------------------------------------------------
+static udt_VariableType vt_Interval = {
+    (InitializeProc) IntervalVar_Initialize,
+    (FinalizeProc) IntervalVar_Finalize,
+    (PreDefineProc) NULL,
+    (PostDefineProc) NULL,
+    (PreFetchProc) NULL,
+    (IsNullProc) NULL,
+    (SetValueProc) IntervalVar_SetValue,
+    (GetValueProc) IntervalVar_GetValue,
+    (GetBufferSizeProc) NULL,
+    &g_IntervalVarType,                 // Python type
+    SQLT_INTERVAL_DS,                   // Oracle type
+    SQLCS_IMPLICIT,                     // charset form
+    sizeof(OCIInterval*),               // element length (default)
+    0,                                  // is character data
+    0,                                  // is variable length
+    1,                                  // can be copied
+    1                                   // can be in array
+};
+
+
+//-----------------------------------------------------------------------------
+// IntervalVar_Initialize()
+//   Initialize the variable.
+//-----------------------------------------------------------------------------
+static int IntervalVar_Initialize(
+    udt_IntervalVar *var,                    // variable to initialize
+    udt_Cursor *cursor)                 // cursor created by
+{
+    sword status;
+    ub4 i;
+
+    // initialize the interval locators
+    for (i = 0; i < var->allocatedElements; i++) {
+        status = OCIDescriptorAlloc(var->environment->handle,
+                (dvoid**) &var->data[i], OCI_DTYPE_INTERVAL_DS, 0, 0);
+        if (Environment_CheckForError(var->environment, status,
+                "IntervalVar_Initialize()") < 0)
+            return -1;
+    }
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// IntervalVar_Finalize()
+//   Prepare for variable destruction.
+//-----------------------------------------------------------------------------
+static void IntervalVar_Finalize(
+    udt_IntervalVar *var)                    // variable to free
+{
+    ub4 i;
+
+    for (i = 0; i < var->allocatedElements; i++) {
+        if (var->data[i])
+            OCIDescriptorFree(var->data[i], OCI_DTYPE_INTERVAL_DS);
+    }
+}
+
+
+//-----------------------------------------------------------------------------
+// IntervalVar_SetValue()
+//   Set the value of the variable.
+//-----------------------------------------------------------------------------
+static int IntervalVar_SetValue(
+    udt_IntervalVar *var,               // variable to set value for
+    unsigned pos,                       // array position to set
+    PyObject *value)                    // value to set
+{
+    sb4 hours, minutes, seconds;
+    PyDateTime_Delta *delta;
+    sword status;
+
+    if (!PyDelta_Check(value)) {
+        PyErr_SetString(PyExc_TypeError, "expecting timedelta data");
+        return -1;
+    }
+
+    delta = (PyDateTime_Delta*) value;
+    hours = (sb4) delta->seconds / 3600;
+    seconds = delta->seconds - hours * 3600;
+    minutes = (sb4) seconds / 60;
+    seconds -= minutes * 60;
+    status = OCIIntervalSetDaySecond(var->environment->handle,
+            var->environment->errorHandle, delta->days, hours, minutes,
+            seconds, delta->microseconds, var->data[pos]);
+    if (Environment_CheckForError(var->environment, status,
+                "IntervalVar_SetValue()") < 0)
+        return -1;
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// IntervalVar_GetValue()
+//   Returns the value stored at the given array position.
+//-----------------------------------------------------------------------------
+static PyObject *IntervalVar_GetValue(
+    udt_IntervalVar *var,               // variable to determine value for
+    unsigned pos)                       // array position
+{
+    return OracleIntervalToPythonDelta(var->environment, var->data[pos]);
+}
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/LICENSE.txt b/desktop/core/ext-py/cx_Oracle-5.1.2/LICENSE.txt
new file mode 100644
index 0000000..33dfd43
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/LICENSE.txt
@@ -0,0 +1,36 @@
+Copyright  2007-2012, Anthony Tuininga.
+Copyright  2001-2007, Computronix (Canada) Ltd., Edmonton, Alberta, Canada.
+All rights reserved.
+
+License for cx_Oracle
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+    1. Redistributions of source code must retain the above copyright notice,
+       this list of conditions, and the disclaimer that follows.
+
+    2. Redistributions in binary form must reproduce the above copyright
+       notice, this list of conditions, and the following disclaimer in the
+       documentation and/or other materials provided with the distribution.
+
+    3. Neither the names of the copyright holders nor the names of any
+       contributors may be used to endorse or promote products derived from
+       this software without specific prior written permission.
+
+DISCLAIMER:
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS *AS IS*
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS
+OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGE.
+
+Computronix is a registered trademark of Computronix (Canada) Ltd.
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/LobVar.c b/desktop/core/ext-py/cx_Oracle-5.1.2/LobVar.c
new file mode 100644
index 0000000..7d52eab
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/LobVar.c
@@ -0,0 +1,428 @@
+//-----------------------------------------------------------------------------
+// LobVar.c
+//   Defines the routines for handling LOB variables.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// LOB type
+//-----------------------------------------------------------------------------
+typedef struct {
+    Variable_HEAD
+    OCILobLocator **data;
+    udt_Connection *connection;
+    int isFile;
+} udt_LobVar;
+
+//-----------------------------------------------------------------------------
+// Declaration of LOB variable functions.
+//-----------------------------------------------------------------------------
+static int LobVar_Initialize(udt_LobVar*, udt_Cursor*);
+static int LobVar_PreFetch(udt_LobVar*);
+static void LobVar_Finalize(udt_LobVar*);
+static PyObject *LobVar_GetValue(udt_LobVar*, unsigned);
+static int LobVar_SetValue(udt_LobVar*, unsigned, PyObject*);
+static int LobVar_Write(udt_LobVar*, unsigned, PyObject*, ub4, ub4*);
+
+//-----------------------------------------------------------------------------
+// Python type declarations
+//-----------------------------------------------------------------------------
+static PyTypeObject g_CLOBVarType = {
+    PyVarObject_HEAD_INIT(NULL, 0)
+    "cx_Oracle.CLOB",                   // tp_name
+    sizeof(udt_LobVar),                 // tp_basicsize
+    0,                                  // tp_itemsize
+    0,                                  // tp_dealloc
+    0,                                  // tp_print
+    0,                                  // tp_getattr
+    0,                                  // tp_setattr
+    0,                                  // tp_compare
+    0,                                  // tp_repr
+    0,                                  // tp_as_number
+    0,                                  // tp_as_sequence
+    0,                                  // tp_as_mapping
+    0,                                  // tp_hash
+    0,                                  // tp_call
+    0,                                  // tp_str
+    0,                                  // tp_getattro
+    0,                                  // tp_setattro
+    0,                                  // tp_as_buffer
+    Py_TPFLAGS_DEFAULT,                 // tp_flags
+    0                                   // tp_doc
+};
+
+
+static PyTypeObject g_NCLOBVarType = {
+    PyVarObject_HEAD_INIT(NULL, 0)
+    "cx_Oracle.NCLOB",                  // tp_name
+    sizeof(udt_LobVar),                 // tp_basicsize
+    0,                                  // tp_itemsize
+    0,                                  // tp_dealloc
+    0,                                  // tp_print
+    0,                                  // tp_getattr
+    0,                                  // tp_setattr
+    0,                                  // tp_compare
+    0,                                  // tp_repr
+    0,                                  // tp_as_number
+    0,                                  // tp_as_sequence
+    0,                                  // tp_as_mapping
+    0,                                  // tp_hash
+    0,                                  // tp_call
+    0,                                  // tp_str
+    0,                                  // tp_getattro
+    0,                                  // tp_setattro
+    0,                                  // tp_as_buffer
+    Py_TPFLAGS_DEFAULT,                 // tp_flags
+    0                                   // tp_doc
+};
+
+
+static PyTypeObject g_BLOBVarType = {
+    PyVarObject_HEAD_INIT(NULL, 0)
+    "cx_Oracle.BLOB",                   // tp_name
+    sizeof(udt_LobVar),                 // tp_basicsize
+    0,                                  // tp_itemsize
+    0,                                  // tp_dealloc
+    0,                                  // tp_print
+    0,                                  // tp_getattr
+    0,                                  // tp_setattr
+    0,                                  // tp_compare
+    0,                                  // tp_repr
+    0,                                  // tp_as_number
+    0,                                  // tp_as_sequence
+    0,                                  // tp_as_mapping
+    0,                                  // tp_hash
+    0,                                  // tp_call
+    0,                                  // tp_str
+    0,                                  // tp_getattro
+    0,                                  // tp_setattro
+    0,                                  // tp_as_buffer
+    Py_TPFLAGS_DEFAULT,                 // tp_flags
+    0                                   // tp_doc
+};
+
+
+static PyTypeObject g_BFILEVarType = {
+    PyVarObject_HEAD_INIT(NULL, 0)
+    "cx_Oracle.BFILE",                  // tp_name
+    sizeof(udt_LobVar),                 // tp_basicsize
+    0,                                  // tp_itemsize
+    0,                                  // tp_dealloc
+    0,                                  // tp_print
+    0,                                  // tp_getattr
+    0,                                  // tp_setattr
+    0,                                  // tp_compare
+    0,                                  // tp_repr
+    0,                                  // tp_as_number
+    0,                                  // tp_as_sequence
+    0,                                  // tp_as_mapping
+    0,                                  // tp_hash
+    0,                                  // tp_call
+    0,                                  // tp_str
+    0,                                  // tp_getattro
+    0,                                  // tp_setattro
+    0,                                  // tp_as_buffer
+    Py_TPFLAGS_DEFAULT,                 // tp_flags
+    0                                   // tp_doc
+};
+
+
+//-----------------------------------------------------------------------------
+// variable type declarations
+//-----------------------------------------------------------------------------
+static udt_VariableType vt_CLOB = {
+    (InitializeProc) LobVar_Initialize,
+    (FinalizeProc) LobVar_Finalize,
+    (PreDefineProc) NULL,
+    (PostDefineProc) NULL,
+    (PreFetchProc) LobVar_PreFetch,
+    (IsNullProc) NULL,
+    (SetValueProc) LobVar_SetValue,
+    (GetValueProc) LobVar_GetValue,
+    (GetBufferSizeProc) NULL,
+    &g_CLOBVarType,                     // Python type
+    SQLT_CLOB,                          // Oracle type
+    SQLCS_IMPLICIT,                     // charset form
+    sizeof(OCILobLocator*),             // element length
+    1,                                  // is character data
+    0,                                  // is variable length
+    0,                                  // can be copied
+    0                                   // can be in array
+};
+
+
+static udt_VariableType vt_NCLOB = {
+    (InitializeProc) LobVar_Initialize,
+    (FinalizeProc) LobVar_Finalize,
+    (PreDefineProc) NULL,
+    (PostDefineProc) NULL,
+    (PreFetchProc) LobVar_PreFetch,
+    (IsNullProc) NULL,
+    (SetValueProc) LobVar_SetValue,
+    (GetValueProc) LobVar_GetValue,
+    (GetBufferSizeProc) NULL,
+    &g_NCLOBVarType,                    // Python type
+    SQLT_CLOB,                          // Oracle type
+    SQLCS_NCHAR,                        // charset form
+    sizeof(OCILobLocator*),             // element length
+    1,                                  // is character data
+    0,                                  // is variable length
+    0,                                  // can be copied
+    0                                   // can be in array
+};
+
+
+static udt_VariableType vt_BLOB = {
+    (InitializeProc) LobVar_Initialize,
+    (FinalizeProc) LobVar_Finalize,
+    (PreDefineProc) NULL,
+    (PostDefineProc) NULL,
+    (PreFetchProc) LobVar_PreFetch,
+    (IsNullProc) NULL,
+    (SetValueProc) LobVar_SetValue,
+    (GetValueProc) LobVar_GetValue,
+    (GetBufferSizeProc) NULL,
+    &g_BLOBVarType,                     // Python type
+    SQLT_BLOB,                          // Oracle type
+    SQLCS_IMPLICIT,                     // charset form
+    sizeof(OCILobLocator*),             // element length
+    0,                                  // is character data
+    0,                                  // is variable length
+    0,                                  // can be copied
+    0                                   // can be in array
+};
+
+
+static udt_VariableType vt_BFILE = {
+    (InitializeProc) LobVar_Initialize,
+    (FinalizeProc) LobVar_Finalize,
+    (PreDefineProc) NULL,
+    (PostDefineProc) NULL,
+    (PreFetchProc) LobVar_PreFetch,
+    (IsNullProc) NULL,
+    (SetValueProc) LobVar_SetValue,
+    (GetValueProc) LobVar_GetValue,
+    (GetBufferSizeProc) NULL,
+    &g_BFILEVarType,                    // Python type
+    SQLT_BFILE,                         // Oracle type
+    SQLCS_IMPLICIT,                     // charset form
+    sizeof(OCILobLocator*),             // element length
+    0,                                  // is character data
+    0,                                  // is variable length
+    0,                                  // can be copied
+    0                                   // can be in array
+};
+
+
+#include "ExternalLobVar.c"
+
+
+//-----------------------------------------------------------------------------
+// LobVar_Initialize()
+//   Initialize the variable.
+//-----------------------------------------------------------------------------
+static int LobVar_Initialize(
+    udt_LobVar *var,                    // variable to initialize
+    udt_Cursor *cursor)                 // cursor created by
+{
+    sword status;
+    ub4 i;
+
+    // initialize members
+    Py_INCREF(cursor->connection);
+    var->connection = cursor->connection;
+    var->isFile = (var->type == &vt_BFILE);
+
+    // initialize the LOB locators
+    for (i = 0; i < var->allocatedElements; i++) {
+        status = OCIDescriptorAlloc(var->environment->handle,
+                (dvoid**) &var->data[i], OCI_DTYPE_LOB, 0, 0);
+        if (Environment_CheckForError(var->environment, status,
+                "LobVar_Initialize()") < 0)
+            return -1;
+    }
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// LobVar_PreFetch()
+//   Free temporary LOBs prior to fetch.
+//-----------------------------------------------------------------------------
+static int LobVar_PreFetch(
+    udt_LobVar *var)                    // variable to free
+{
+    boolean isTemporary;
+    sword status;
+    ub4 i;
+
+    for (i = 0; i < var->allocatedElements; i++) {
+        if (var->data[i]) {
+            status = OCILobIsTemporary(var->environment->handle,
+                    var->environment->errorHandle, var->data[i], &isTemporary);
+            if (Environment_CheckForError(var->environment, status,
+                    "LobVar_PreFetch(): is temporary LOB?") < 0)
+                return -1;
+            if (isTemporary) {
+                Py_BEGIN_ALLOW_THREADS
+                status = OCILobFreeTemporary(var->connection->handle,
+                        var->environment->errorHandle, var->data[i]);
+                Py_END_ALLOW_THREADS
+                if (Environment_CheckForError(var->environment, status,
+                        "LobVar_PreFetch(): free temporary LOB") < 0)
+                    return -1;
+            }
+        }
+    }
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// LobVar_Finalize()
+//   Prepare for variable destruction.
+//-----------------------------------------------------------------------------
+static void LobVar_Finalize(
+    udt_LobVar *var)                    // variable to free
+{
+    boolean isTemporary;
+    ub4 i;
+
+    for (i = 0; i < var->allocatedElements; i++) {
+        if (var->data[i]) {
+            OCILobIsTemporary(var->environment->handle,
+                    var->environment->errorHandle, var->data[i], &isTemporary);
+            if (isTemporary) {
+                Py_BEGIN_ALLOW_THREADS
+                OCILobFreeTemporary(var->connection->handle,
+                        var->environment->errorHandle, var->data[i]);
+                Py_END_ALLOW_THREADS
+            }
+            OCIDescriptorFree(var->data[i], OCI_DTYPE_LOB);
+        }
+    }
+    Py_DECREF(var->connection);
+}
+
+
+//-----------------------------------------------------------------------------
+// LobVar_Write()
+//   Write data to the LOB variable.
+//-----------------------------------------------------------------------------
+static int LobVar_Write(
+    udt_LobVar *var,                    // variable to perform write against
+    unsigned position,                  // position to perform write against
+    PyObject *dataObj,                  // data object to write into LOB
+    ub4 offset,                         // offset into variable
+    ub4 *amount)                        // amount to write
+{
+    udt_Buffer buffer;
+    sword status;
+
+    // verify the data type
+    if (var->type == &vt_BFILE) {
+        PyErr_SetString(PyExc_TypeError, "BFILEs are read only");
+        return -1;
+    } else if (var->type == &vt_BLOB) {
+        if (cxBuffer_FromObject(&buffer, dataObj,
+                var->environment->encoding) < 0)
+            return -1;
+        *amount = buffer.size;
+#if PY_MAJOR_VERSION < 3
+    } else if (var->type == &vt_NCLOB) {
+        if (cxBuffer_FromObject(&buffer, dataObj,
+                var->environment->nencoding) < 0)
+            return -1;
+        *amount = buffer.size;
+#endif
+    } else {
+        if (cxBuffer_FromObject(&buffer, dataObj,
+                var->environment->encoding) < 0)
+            return -1;
+        if (var->environment->fixedWidth
+                && var->environment->maxBytesPerCharacter > 1)
+            *amount = buffer.size / var->environment->maxBytesPerCharacter;
+        else *amount = buffer.size;
+    }
+
+    // nothing to do if no data to write
+    if (*amount == 0) {
+        cxBuffer_Clear(&buffer);
+        return 0;
+    }
+
+    Py_BEGIN_ALLOW_THREADS
+    status = OCILobWrite(var->connection->handle,
+            var->environment->errorHandle, var->data[position], amount, offset,
+            (void*) buffer.ptr, buffer.size, OCI_ONE_PIECE, NULL, NULL, 0,
+            var->type->charsetForm);
+    Py_END_ALLOW_THREADS
+    cxBuffer_Clear(&buffer);
+    if (Environment_CheckForError(var->environment, status,
+            "LobVar_Write()") < 0)
+        return -1;
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// LobVar_GetValue()
+//   Returns the value stored at the given array position.
+//-----------------------------------------------------------------------------
+static PyObject *LobVar_GetValue(
+    udt_LobVar *var,                    // variable to determine value for
+    unsigned pos)                       // array position
+{
+    return ExternalLobVar_New(var, pos);
+}
+
+
+//-----------------------------------------------------------------------------
+// LobVar_SetValue()
+//   Sets the value stored at the given array position.
+//-----------------------------------------------------------------------------
+static int LobVar_SetValue(
+    udt_LobVar *var,                    // variable to determine value for
+    unsigned position,                  // array position
+    PyObject *value)                    // value to set
+{
+    boolean isTemporary;
+    sword status;
+    ub1 lobType;
+    ub4 amount;
+
+    // make sure have temporary LOBs set up
+    status = OCILobIsTemporary(var->environment->handle,
+            var->environment->errorHandle, var->data[position], &isTemporary);
+    if (Environment_CheckForError(var->environment, status,
+            "LobVar_SetValue(): is temporary?") < 0)
+        return -1;
+    if (!isTemporary) {
+        if (var->type->oracleType == SQLT_BLOB)
+            lobType = OCI_TEMP_BLOB;
+        else lobType = OCI_TEMP_CLOB;
+        Py_BEGIN_ALLOW_THREADS
+        status = OCILobCreateTemporary(var->connection->handle,
+                var->environment->errorHandle, var->data[position],
+                OCI_DEFAULT, var->type->charsetForm, lobType, FALSE,
+                OCI_DURATION_SESSION);
+        Py_END_ALLOW_THREADS
+        if (Environment_CheckForError(var->environment, status,
+                "LobVar_SetValue(): create temporary") < 0)
+            return -1;
+    }
+
+    // trim the current value
+    Py_BEGIN_ALLOW_THREADS
+    status = OCILobTrim(var->connection->handle,
+            var->environment->errorHandle, var->data[position], 0);
+    Py_END_ALLOW_THREADS
+    if (Environment_CheckForError(var->environment, status,
+            "LobVar_SetValue(): trim") < 0)
+        return -1;
+
+    // set the current value
+    return LobVar_Write(var, position, value, 1, &amount);
+}
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/LongVar.c b/desktop/core/ext-py/cx_Oracle-5.1.2/LongVar.c
new file mode 100644
index 0000000..6a16f3f
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/LongVar.c
@@ -0,0 +1,237 @@
+//-----------------------------------------------------------------------------
+// LongVar.c
+//   Defines the routines specific to the long type.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// long type
+//-----------------------------------------------------------------------------
+typedef struct {
+    Variable_HEAD
+    char *data;
+} udt_LongVar;
+
+
+//-----------------------------------------------------------------------------
+// declaration of long variable functions.
+//-----------------------------------------------------------------------------
+static int LongVar_SetValue(udt_LongVar*, unsigned, PyObject*);
+static PyObject *LongVar_GetValue(udt_LongVar*, unsigned);
+static ub4 LongVar_GetBufferSize(udt_LongVar*);
+
+
+//-----------------------------------------------------------------------------
+// Python type declarations
+//-----------------------------------------------------------------------------
+static PyTypeObject g_LongStringVarType = {
+    PyVarObject_HEAD_INIT(NULL, 0)
+    "cx_Oracle.LONG_STRING",            // tp_name
+    sizeof(udt_LongVar),                // tp_basicsize
+    0,                                  // tp_itemsize
+    0,                                  // tp_dealloc
+    0,                                  // tp_print
+    0,                                  // tp_getattr
+    0,                                  // tp_setattr
+    0,                                  // tp_compare
+    0,                                  // tp_repr
+    0,                                  // tp_as_number
+    0,                                  // tp_as_sequence
+    0,                                  // tp_as_mapping
+    0,                                  // tp_hash
+    0,                                  // tp_call
+    0,                                  // tp_str
+    0,                                  // tp_getattro
+    0,                                  // tp_setattro
+    0,                                  // tp_as_buffer
+    Py_TPFLAGS_DEFAULT,                 // tp_flags
+    0                                   // tp_doc
+};
+
+
+#if PY_MAJOR_VERSION < 3
+static PyTypeObject g_LongUnicodeVarType = {
+    PyVarObject_HEAD_INIT(NULL, 0)
+    "cx_Oracle.LONG_UNICODE",           // tp_name
+    sizeof(udt_LongVar),                // tp_basicsize
+    0,                                  // tp_itemsize
+    0,                                  // tp_dealloc
+    0,                                  // tp_print
+    0,                                  // tp_getattr
+    0,                                  // tp_setattr
+    0,                                  // tp_compare
+    0,                                  // tp_repr
+    0,                                  // tp_as_number
+    0,                                  // tp_as_sequence
+    0,                                  // tp_as_mapping
+    0,                                  // tp_hash
+    0,                                  // tp_call
+    0,                                  // tp_str
+    0,                                  // tp_getattro
+    0,                                  // tp_setattro
+    0,                                  // tp_as_buffer
+    Py_TPFLAGS_DEFAULT,                 // tp_flags
+    0                                   // tp_doc
+};
+#endif
+
+
+static PyTypeObject g_LongBinaryVarType = {
+    PyVarObject_HEAD_INIT(NULL, 0)
+    "cx_Oracle.LONG_BINARY",            // tp_name
+    sizeof(udt_LongVar),                // tp_basicsize
+    0,                                  // tp_itemsize
+    0,                                  // tp_dealloc
+    0,                                  // tp_print
+    0,                                  // tp_getattr
+    0,                                  // tp_setattr
+    0,                                  // tp_compare
+    0,                                  // tp_repr
+    0,                                  // tp_as_number
+    0,                                  // tp_as_sequence
+    0,                                  // tp_as_mapping
+    0,                                  // tp_hash
+    0,                                  // tp_call
+    0,                                  // tp_str
+    0,                                  // tp_getattro
+    0,                                  // tp_setattro
+    0,                                  // tp_as_buffer
+    Py_TPFLAGS_DEFAULT,                 // tp_flags
+    0                                   // tp_doc
+};
+
+
+//-----------------------------------------------------------------------------
+// variable type declarations
+//-----------------------------------------------------------------------------
+static udt_VariableType vt_LongString = {
+    (InitializeProc) NULL,
+    (FinalizeProc) NULL,
+    (PreDefineProc) NULL,
+    (PostDefineProc) NULL,
+    (PreFetchProc) NULL,
+    (IsNullProc) NULL,
+    (SetValueProc) LongVar_SetValue,
+    (GetValueProc) LongVar_GetValue,
+    (GetBufferSizeProc) LongVar_GetBufferSize,
+    &g_LongStringVarType,               // Python type
+    SQLT_LVC,                           // Oracle type
+    SQLCS_IMPLICIT,                     // charset form
+    128 * 1024,                         // element length (default)
+    1,                                  // is character data
+    1,                                  // is variable length
+    1,                                  // can be copied
+    0                                   // can be in array
+};
+
+
+#if PY_MAJOR_VERSION < 3
+static udt_VariableType vt_LongNationalCharString = {
+    (InitializeProc) NULL,
+    (FinalizeProc) NULL,
+    (PreDefineProc) NULL,
+    (PostDefineProc) NULL,
+    (PreFetchProc) NULL,
+    (IsNullProc) NULL,
+    (SetValueProc) LongVar_SetValue,
+    (GetValueProc) LongVar_GetValue,
+    (GetBufferSizeProc) LongVar_GetBufferSize,
+    &g_LongUnicodeVarType,              // Python type
+    SQLT_LVC,                           // Oracle type
+    SQLCS_NCHAR,                        // charset form
+    128 * 1024,                         // element length (default)
+    1,                                  // is character data
+    1,                                  // is variable length
+    1,                                  // can be copied
+    0                                   // can be in array
+};
+#endif
+
+
+static udt_VariableType vt_LongBinary = {
+    (InitializeProc) NULL,
+    (FinalizeProc) NULL,
+    (PreDefineProc) NULL,
+    (PostDefineProc) NULL,
+    (PreFetchProc) NULL,
+    (IsNullProc) NULL,
+    (SetValueProc) LongVar_SetValue,
+    (GetValueProc) LongVar_GetValue,
+    (GetBufferSizeProc) LongVar_GetBufferSize,
+    &g_LongBinaryVarType,               // Python type
+    SQLT_LVB,                           // Oracle type
+    SQLCS_IMPLICIT,                     // charset form
+    128 * 1024,                         // element length (default)
+    0,                                  // is character data
+    1,                                  // is variable length
+    1,                                  // can be copied
+    0                                   // can be in array
+};
+
+
+//-----------------------------------------------------------------------------
+// LongVar_SetValue()
+//   Set the value of the variable.
+//-----------------------------------------------------------------------------
+static int LongVar_SetValue(
+    udt_LongVar *var,                   // variable to set value for
+    unsigned pos,                       // array position to set
+    PyObject *value)                    // value to set
+{
+    udt_Buffer buffer;
+    char *ptr;
+
+    // get the buffer data and size for binding
+    if (cxBuffer_FromObject(&buffer, value, var->environment->encoding) < 0)
+        return -1;
+
+    // verify there is enough space to store the value
+    if (buffer.numCharacters > var->size) {
+        if (Variable_Resize((udt_Variable*) var, buffer.numCharacters) < 0) {
+            cxBuffer_Clear(&buffer);
+            return -1;
+        }
+    }
+
+    // copy the string to the Oracle buffer
+    ptr = var->data + var->bufferSize * pos;
+    *((ub4 *) ptr) = (ub4) buffer.size;
+    if (buffer.size)
+        memcpy(ptr + sizeof(ub4), buffer.ptr, buffer.size);
+    cxBuffer_Clear(&buffer);
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// LongVar_GetValue()
+//   Returns the value stored at the given array position.
+//-----------------------------------------------------------------------------
+static PyObject *LongVar_GetValue(
+    udt_LongVar *var,                   // variable to determine value for
+    unsigned pos)                       // array position
+{
+    char *ptr;
+    ub4 size;
+
+    ptr = var->data + var->bufferSize * pos;
+    size = *((ub4 *) ptr);
+    ptr += sizeof(ub4);
+    if (var->type == &vt_LongBinary)
+        return PyBytes_FromStringAndSize(ptr, size);
+    return cxString_FromEncodedString(ptr, size, var->environment->encoding);
+}
+
+
+//-----------------------------------------------------------------------------
+// LongVar_GetBufferSize()
+//   Returns the size of the buffer to use for data of the given size.
+//-----------------------------------------------------------------------------
+static ub4 LongVar_GetBufferSize(
+    udt_LongVar *self)                  // variable to get buffer size
+{
+    if (!self->type->isCharacterData)
+        return self->size + sizeof(ub4);
+    return sizeof(ub4) + self->size * self->environment->maxBytesPerCharacter;
+}
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/MANIFEST.in b/desktop/core/ext-py/cx_Oracle-5.1.2/MANIFEST.in
new file mode 100644
index 0000000..1e2ebde
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/MANIFEST.in
@@ -0,0 +1,7 @@
+include MANIFEST.in
+include *.c
+include *.txt
+recursive-include html *.html *.js *.inv
+recursive-include html/_static *.png *.css *.js
+recursive-include samples *.py
+recursive-include test *.py *.sql
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/NumberVar.c b/desktop/core/ext-py/cx_Oracle-5.1.2/NumberVar.c
new file mode 100644
index 0000000..d46dcc8
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/NumberVar.c
@@ -0,0 +1,608 @@
+//-----------------------------------------------------------------------------
+// NumberVar.c
+//   Defines the routines for handling numeric variables.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// Number types
+//-----------------------------------------------------------------------------
+typedef struct {
+    Variable_HEAD
+    OCINumber *data;
+} udt_NumberVar;
+
+
+#ifdef SQLT_BFLOAT
+typedef struct {
+    Variable_HEAD
+    double *data;
+} udt_NativeFloatVar;
+#endif
+
+
+//-----------------------------------------------------------------------------
+// Declaration of number variable functions.
+//-----------------------------------------------------------------------------
+static int NumberVar_PreDefine(udt_NumberVar*, OCIParam*);
+static int NumberVar_SetValue(udt_NumberVar*, unsigned, PyObject*);
+static PyObject *NumberVar_GetValue(udt_NumberVar*, unsigned);
+#ifdef SQLT_BFLOAT
+static int NativeFloatVar_SetValue(udt_NativeFloatVar*, unsigned, PyObject*);
+static PyObject *NativeFloatVar_GetValue(udt_NativeFloatVar*, unsigned);
+#endif
+
+
+//-----------------------------------------------------------------------------
+// Python type declaration
+//-----------------------------------------------------------------------------
+static PyTypeObject g_NumberVarType = {
+    PyVarObject_HEAD_INIT(NULL, 0)
+    "cx_Oracle.NUMBER",                 // tp_name
+    sizeof(udt_NumberVar),              // tp_basicsize
+    0,                                  // tp_itemsize
+    0,                                  // tp_dealloc
+    0,                                  // tp_print
+    0,                                  // tp_getattr
+    0,                                  // tp_setattr
+    0,                                  // tp_compare
+    0,                                  // tp_repr
+    0,                                  // tp_as_number
+    0,                                  // tp_as_sequence
+    0,                                  // tp_as_mapping
+    0,                                  // tp_hash
+    0,                                  // tp_call
+    0,                                  // tp_str
+    0,                                  // tp_getattro
+    0,                                  // tp_setattro
+    0,                                  // tp_as_buffer
+    Py_TPFLAGS_DEFAULT,                 // tp_flags
+    0                                   // tp_doc
+};
+
+
+#ifdef SQLT_BFLOAT
+static PyTypeObject g_NativeFloatVarType = {
+    PyVarObject_HEAD_INIT(NULL, 0)
+    "cx_Oracle.NATIVE_FLOAT",           // tp_name
+    sizeof(udt_NativeFloatVar),         // tp_basicsize
+    0,                                  // tp_itemsize
+    0,                                  // tp_dealloc
+    0,                                  // tp_print
+    0,                                  // tp_getattr
+    0,                                  // tp_setattr
+    0,                                  // tp_compare
+    0,                                  // tp_repr
+    0,                                  // tp_as_number
+    0,                                  // tp_as_sequence
+    0,                                  // tp_as_mapping
+    0,                                  // tp_hash
+    0,                                  // tp_call
+    0,                                  // tp_str
+    0,                                  // tp_getattro
+    0,                                  // tp_setattro
+    0,                                  // tp_as_buffer
+    Py_TPFLAGS_DEFAULT,                 // tp_flags
+    0                                   // tp_doc
+};
+#endif
+
+
+//-----------------------------------------------------------------------------
+// variable type declarations
+//-----------------------------------------------------------------------------
+static udt_VariableType vt_Float = {
+    (InitializeProc) NULL,
+    (FinalizeProc) NULL,
+    (PreDefineProc) NumberVar_PreDefine,
+    (PostDefineProc) NULL,
+    (PreFetchProc) NULL,
+    (IsNullProc) NULL,
+    (SetValueProc) NumberVar_SetValue,
+    (GetValueProc) NumberVar_GetValue,
+    (GetBufferSizeProc) NULL,
+    &g_NumberVarType,                   // Python type
+    SQLT_VNU,                           // Oracle type
+    SQLCS_IMPLICIT,                     // charset form
+    sizeof(OCINumber),                  // element length
+    0,                                  // is character data
+    0,                                  // is variable length
+    1,                                  // can be copied
+    1                                   // can be in array
+};
+
+
+#ifdef SQLT_BFLOAT
+static udt_VariableType vt_NativeFloat = {
+    (InitializeProc) NULL,
+    (FinalizeProc) NULL,
+    (PreDefineProc) NULL,
+    (PostDefineProc) NULL,
+    (PreFetchProc) NULL,
+    (IsNullProc) NULL,
+    (SetValueProc) NativeFloatVar_SetValue,
+    (GetValueProc) NativeFloatVar_GetValue,
+    (GetBufferSizeProc) NULL,
+    &g_NativeFloatVarType,              // Python type
+    SQLT_BDOUBLE,                       // Oracle type
+    SQLCS_IMPLICIT,                     // charset form
+    sizeof(double),                     // element length
+    0,                                  // is character data
+    0,                                  // is variable length
+    1,                                  // can be copied
+    1                                   // can be in array
+};
+#endif
+
+
+#if PY_MAJOR_VERSION < 3
+static udt_VariableType vt_Integer = {
+    (InitializeProc) NULL,
+    (FinalizeProc) NULL,
+    (PreDefineProc) NumberVar_PreDefine,
+    (PostDefineProc) NULL,
+    (PreFetchProc) NULL,
+    (IsNullProc) NULL,
+    (SetValueProc) NumberVar_SetValue,
+    (GetValueProc) NumberVar_GetValue,
+    (GetBufferSizeProc) NULL,
+    &g_NumberVarType,                   // Python type
+    SQLT_VNU,                           // Oracle type
+    SQLCS_IMPLICIT,                     // charset form
+    sizeof(OCINumber),                  // element length
+    0,                                  // is character data
+    0,                                  // is variable length
+    1,                                  // can be copied
+    1                                   // can be in array
+};
+#endif
+
+
+static udt_VariableType vt_LongInteger = {
+    (InitializeProc) NULL,
+    (FinalizeProc) NULL,
+    (PreDefineProc) NumberVar_PreDefine,
+    (PostDefineProc) NULL,
+    (PreFetchProc) NULL,
+    (IsNullProc) NULL,
+    (SetValueProc) NumberVar_SetValue,
+    (GetValueProc) NumberVar_GetValue,
+    (GetBufferSizeProc) NULL,
+    &g_NumberVarType,                   // Python type
+    SQLT_VNU,                           // Oracle type
+    SQLCS_IMPLICIT,                     // charset form
+    sizeof(OCINumber),                  // element length
+    0,                                  // is character data
+    0,                                  // is variable length
+    1,                                  // can be copied
+    1                                   // can be in array
+};
+
+
+static udt_VariableType vt_NumberAsString = {
+    (InitializeProc) NULL,
+    (FinalizeProc) NULL,
+    (PreDefineProc) NumberVar_PreDefine,
+    (PostDefineProc) NULL,
+    (PreFetchProc) NULL,
+    (IsNullProc) NULL,
+    (SetValueProc) NumberVar_SetValue,
+    (GetValueProc) NumberVar_GetValue,
+    (GetBufferSizeProc) NULL,
+    &g_NumberVarType,                   // Python type
+    SQLT_VNU,                           // Oracle type
+    SQLCS_IMPLICIT,                     // charset form
+    sizeof(OCINumber),                  // element length
+    0,                                  // is character data
+    0,                                  // is variable length
+    1,                                  // can be copied
+    1                                   // can be in array
+};
+
+
+static udt_VariableType vt_Boolean = {
+    (InitializeProc) NULL,
+    (FinalizeProc) NULL,
+    (PreDefineProc) NumberVar_PreDefine,
+    (PostDefineProc) NULL,
+    (PreFetchProc) NULL,
+    (IsNullProc) NULL,
+    (SetValueProc) NumberVar_SetValue,
+    (GetValueProc) NumberVar_GetValue,
+    (GetBufferSizeProc) NULL,
+    &g_NumberVarType,                   // Python type
+    SQLT_VNU,                           // Oracle type
+    SQLCS_IMPLICIT,                     // charset form
+    sizeof(OCINumber),                  // element length
+    0,                                  // is character data
+    0,                                  // is variable length
+    1,                                  // can be copied
+    1                                   // can be in array
+};
+
+
+//-----------------------------------------------------------------------------
+// NumberVar_PreDefine()
+//   Set the type of value (integer, float or string) that will be returned
+// when values are fetched from this variable.
+//-----------------------------------------------------------------------------
+static int NumberVar_PreDefine(
+    udt_NumberVar *var,                 // variable to initialize
+    OCIParam *param)                    // parameter handle
+{
+    sb2 precision;
+    sword status;
+    sb1 scale;
+
+    // if the return type has not already been specified, check to see if the
+    // number can fit inside an integer by looking at the precision and scale
+    if (var->type == &vt_Float) {
+        scale = 0;
+        precision = 0;
+        status = OCIAttrGet(param, OCI_HTYPE_DESCRIBE, (dvoid*) &scale, 0,
+                OCI_ATTR_SCALE, var->environment->errorHandle);
+        if (Environment_CheckForError(var->environment, status,
+                "NumberVar_PreDefine(): scale") < 0)
+            return -1;
+        status = OCIAttrGet(param, OCI_HTYPE_DESCRIBE, (dvoid*) &precision, 0,
+                OCI_ATTR_PRECISION, var->environment->errorHandle);
+        if (Environment_CheckForError(var->environment, status,
+                "NumberVar_PreDefine(): precision") < 0)
+            return -1;
+        if (scale == 0 || (scale == -127 && precision == 0)) {
+            var->type = &vt_LongInteger;
+#if PY_MAJOR_VERSION < 3
+        if (precision > 0 && precision < 10)
+            var->type = &vt_Integer;
+#endif
+        }
+    }
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// NumberVar_SetValueFromBoolean()
+//   Set the value of the variable from a Python boolean.
+//-----------------------------------------------------------------------------
+static int NumberVar_SetValueFromBoolean(
+    udt_NumberVar *var,                 // variable to set value for
+    unsigned pos,                       // array position to set
+    PyObject *value)                    // value to set
+{
+    long integerValue;
+    sword status;
+
+    integerValue = (value == Py_True);
+    status = OCINumberFromInt(var->environment->errorHandle, &integerValue,
+            sizeof(long), OCI_NUMBER_SIGNED, &var->data[pos]);
+    return Environment_CheckForError(var->environment, status,
+            "NumberVar_SetValueFromBoolean()");
+}
+
+
+#if PY_MAJOR_VERSION < 3
+//-----------------------------------------------------------------------------
+// NumberVar_SetValueFromInteger()
+//   Set the value of the variable from a Python integer.
+//-----------------------------------------------------------------------------
+static int NumberVar_SetValueFromInteger(
+    udt_NumberVar *var,                 // variable to set value for
+    unsigned pos,                       // array position to set
+    PyObject *value)                    // value to set
+{
+    long integerValue;
+    sword status;
+
+    integerValue = PyInt_AS_LONG(value);
+    status = OCINumberFromInt(var->environment->errorHandle, &integerValue,
+            sizeof(long), OCI_NUMBER_SIGNED, &var->data[pos]);
+    return Environment_CheckForError(var->environment, status,
+            "NumberVar_SetValueFromInteger()");
+}
+#endif
+
+
+//-----------------------------------------------------------------------------
+// NumberVar_SetValueFromFloat()
+//   Set the value of the variable from a Python float.
+//-----------------------------------------------------------------------------
+static int NumberVar_SetValueFromFloat(
+    udt_NumberVar *var,                 // variable to set value for
+    unsigned pos,                       // array position to set
+    PyObject *value)                    // value to set
+{
+    double doubleValue;
+    sword status;
+
+    doubleValue = PyFloat_AS_DOUBLE(value);
+    status = OCINumberFromReal(var->environment->errorHandle, &doubleValue,
+            sizeof(double), &var->data[pos]);
+    return Environment_CheckForError(var->environment, status,
+            "NumberVar_SetValueFromFloat()");
+}
+
+
+//-----------------------------------------------------------------------------
+// NumberVar_SetValueFromLong()
+//   Set the value of the variable from a Python long.
+//-----------------------------------------------------------------------------
+static int NumberVar_SetValueFromLong(
+    udt_NumberVar *var,                 // variable to set value for
+    unsigned pos,                       // array position to set
+    PyObject *value)                    // value to set
+{
+    udt_Buffer textBuffer;
+    PyObject *textValue;
+    sword status;
+
+    textValue = PyObject_Str(value);
+    if (!textValue)
+        return -1;
+    if (cxBuffer_FromObject(&textBuffer, textValue,
+            var->environment->encoding) < 0)
+        return -1;
+    status = OCINumberFromText(var->environment->errorHandle,
+            (text*) textBuffer.ptr, textBuffer.size,
+            (text*) var->environment->numberFromStringFormatBuffer.ptr,
+            var->environment->numberFromStringFormatBuffer.size, NULL, 0,
+            &var->data[pos]);
+    cxBuffer_Clear(&textBuffer);
+    Py_DECREF(textValue);
+    return Environment_CheckForError(var->environment, status,
+            "NumberVar_SetValueFromLong()");
+}
+
+
+//-----------------------------------------------------------------------------
+// NumberVar_GetFormatAndTextFromDecimal()
+//   Return the number format and text to use for the Decimal object.
+//-----------------------------------------------------------------------------
+static int NumberVar_GetFormatAndTextFromDecimal(
+    PyObject *tupleValue,               // decimal as_tuple() value
+    PyObject **textObj,                 // text string for conversion
+    PyObject **formatObj)               // format for conversion
+{
+    long numDigits, scale, i, sign, length, digit;
+    char *textValue, *format, *textPtr, *formatPtr;
+    PyObject *digits;
+
+    // acquire basic information from the value tuple
+    sign = PyInt_AsLong(PyTuple_GET_ITEM(tupleValue, 0));
+    if (PyErr_Occurred())
+        return -1;
+    digits = PyTuple_GET_ITEM(tupleValue, 1);
+    scale = PyInt_AsLong(PyTuple_GET_ITEM(tupleValue, 2));
+    if (PyErr_Occurred())
+        return -1;
+    numDigits = PyTuple_GET_SIZE(digits);
+
+    // allocate memory for the string and format to use in conversion
+    length = numDigits + abs(scale) + 3;
+    textValue = textPtr = PyMem_Malloc(length);
+    if (!textValue) {
+        PyErr_NoMemory();
+        return -1;
+    }
+    format = formatPtr = PyMem_Malloc(length);
+    if (!format) {
+        PyMem_Free(textValue);
+        PyErr_NoMemory();
+        return -1;
+    }
+
+    // populate the string and format
+    if (sign)
+        *textPtr++ = '-';
+    for (i = 0; i < numDigits + scale; i++) {
+        *formatPtr++ = '9';
+        if (i < numDigits) {
+            digit = PyInt_AsLong(PyTuple_GetItem(digits, i));
+            if (PyErr_Occurred()) {
+                PyMem_Free(textValue);
+                return -1;
+            }
+        }
+        else digit = 0;
+        *textPtr++ = '0' + (char) digit;
+    }
+    if (scale < 0) {
+        *formatPtr++ = 'D';
+        *textPtr++ = '.';
+        for (i = scale; i < 0; i++) {
+            *formatPtr++ = '9';
+            if (numDigits + i < 0)
+                digit = 0;
+            else {
+                digit = PyInt_AsLong(PyTuple_GetItem(digits, numDigits + i));
+                if (PyErr_Occurred()) {
+                    PyMem_Free(textValue);
+                    return -1;
+                }
+            }
+            *textPtr++ = '0' + (char) digit;
+        }
+    }
+    *formatPtr = '\0';
+    *textPtr = '\0';
+    *textObj = cxString_FromAscii(textValue);
+    PyMem_Free(textValue);
+    if (!*textObj) {
+        PyMem_Free(format);
+        return -1;
+    }
+    *formatObj = cxString_FromAscii(format);
+    PyMem_Free(format);
+    if (!*formatObj) {
+        Py_DECREF(*textObj);
+        return -1;
+    }
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// NumberVar_SetValueFromDecimal()
+//   Set the value of the variable from a Python decimal.Decimal object.
+//-----------------------------------------------------------------------------
+static int NumberVar_SetValueFromDecimal(
+    udt_NumberVar *var,                 // variable to set value for
+    unsigned pos,                       // array position to set
+    PyObject *value)                    // value to set
+{
+    PyObject *textValue, *format, *tupleValue;
+    udt_Buffer textBuffer, formatBuffer;
+    sword status;
+
+    tupleValue = PyObject_CallMethod(value, "as_tuple", NULL);
+    if (!tupleValue)
+        return -1;
+    if (NumberVar_GetFormatAndTextFromDecimal(tupleValue, &textValue,
+            &format) < 0) {
+        Py_DECREF(tupleValue);
+        return -1;
+    }
+    Py_DECREF(tupleValue);
+    if (cxBuffer_FromObject(&textBuffer, textValue,
+            var->environment->encoding) < 0)
+        return -1;
+    if (cxBuffer_FromObject(&formatBuffer, format,
+            var->environment->encoding) < 0) {
+        cxBuffer_Clear(&textBuffer);
+        return -1;
+    }
+    status = OCINumberFromText(var->environment->errorHandle,
+            (text*) textBuffer.ptr, textBuffer.size, (text*) formatBuffer.ptr,
+            formatBuffer.size,
+            var->environment->nlsNumericCharactersBuffer.ptr,
+            var->environment->nlsNumericCharactersBuffer.size,
+            &var->data[pos]);
+    cxBuffer_Clear(&textBuffer);
+    cxBuffer_Clear(&formatBuffer);
+    Py_DECREF(textValue);
+    Py_DECREF(format);
+    return Environment_CheckForError(var->environment, status,
+            "NumberVar_SetValueFromDecimal()");
+}
+
+
+//-----------------------------------------------------------------------------
+// NumberVar_SetValue()
+//   Set the value of the variable.
+//-----------------------------------------------------------------------------
+static int NumberVar_SetValue(
+    udt_NumberVar *var,                 // variable to set value for
+    unsigned pos,                       // array position to set
+    PyObject *value)                    // value to set
+{
+#if PY_MAJOR_VERSION < 3
+    if (PyInt_Check(value))
+        return NumberVar_SetValueFromInteger(var, pos, value);
+#endif
+    if (PyLong_Check(value))
+        return NumberVar_SetValueFromLong(var, pos, value);
+    if (PyBool_Check(value))
+        return NumberVar_SetValueFromBoolean(var, pos, value);
+    if (PyFloat_Check(value))
+        return NumberVar_SetValueFromFloat(var, pos, value);
+    if (Py_TYPE(value) == g_DecimalType)
+        return NumberVar_SetValueFromDecimal(var, pos, value);
+    PyErr_SetString(PyExc_TypeError, "expecting numeric data");
+    return -1;
+}
+
+
+//-----------------------------------------------------------------------------
+// NumberVar_GetValue()
+//   Returns the value stored at the given array position.
+//-----------------------------------------------------------------------------
+static PyObject *NumberVar_GetValue(
+    udt_NumberVar *var,                 // variable to determine value for
+    unsigned pos)                       // array position
+{
+    PyObject *result, *stringObj;
+    char stringValue[200];
+    long integerValue;
+    ub4 stringLength;
+    sword status;
+
+#if PY_MAJOR_VERSION < 3
+    if (var->type == &vt_Integer || var->type == &vt_Boolean) {
+#else
+    if (var->type == &vt_Boolean) {
+#endif
+        status = OCINumberToInt(var->environment->errorHandle, &var->data[pos],
+                sizeof(long), OCI_NUMBER_SIGNED, (dvoid*) &integerValue);
+        if (Environment_CheckForError(var->environment, status,
+                "NumberVar_GetValue(): as integer") < 0)
+            return NULL;
+#if PY_MAJOR_VERSION < 3
+        if (var->type == &vt_Integer)
+            return PyInt_FromLong(integerValue);
+#endif
+        return PyBool_FromLong(integerValue);
+    }
+
+    if (var->type == &vt_NumberAsString || var->type == &vt_LongInteger) {
+        stringLength = sizeof(stringValue);
+        status = OCINumberToText(var->environment->errorHandle,
+                &var->data[pos],
+                (text*) var->environment->numberToStringFormatBuffer.ptr,
+                var->environment->numberToStringFormatBuffer.size, NULL, 0,
+                &stringLength, (unsigned char*) stringValue);
+        if (Environment_CheckForError(var->environment, status,
+                "NumberVar_GetValue(): as string") < 0)
+            return NULL;
+        stringObj = cxString_FromEncodedString(stringValue, stringLength,
+                var->environment->encoding);
+        if (!stringObj)
+            return NULL;
+        if (var->type == &vt_NumberAsString)
+            return stringObj;
+#if PY_MAJOR_VERSION >= 3
+        result = PyNumber_Long(stringObj);
+#else
+        result = PyNumber_Int(stringObj);
+#endif
+        Py_DECREF(stringObj);
+        if (result || !PyErr_ExceptionMatches(PyExc_ValueError))
+            return result;
+        PyErr_Clear();
+    }
+
+    return OracleNumberToPythonFloat(var->environment, &var->data[pos]);
+}
+
+
+#ifdef SQLT_BFLOAT
+//-----------------------------------------------------------------------------
+// NativeFloatVar_GetValue()
+//   Returns the value stored at the given array position as a float.
+//-----------------------------------------------------------------------------
+static PyObject *NativeFloatVar_GetValue(
+    udt_NativeFloatVar *var,            // variable to determine value for
+    unsigned pos)                       // array position
+{
+    return PyFloat_FromDouble(var->data[pos]);
+}
+
+
+//-----------------------------------------------------------------------------
+// NativeFloatVar_SetValue()
+//   Set the value of the variable which should be a native double.
+//-----------------------------------------------------------------------------
+static int NativeFloatVar_SetValue(
+    udt_NativeFloatVar *var,            // variable to set value for
+    unsigned pos,                       // array position to set
+    PyObject *value)                    // value to set
+{
+    if (!PyFloat_Check(value)) {
+        PyErr_SetString(PyExc_TypeError, "expecting float");
+        return -1;
+    }
+    var->data[pos] = PyFloat_AS_DOUBLE(value);
+    return 0;
+}
+#endif
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/ObjectType.c b/desktop/core/ext-py/cx_Oracle-5.1.2/ObjectType.c
new file mode 100644
index 0000000..afb67d8
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/ObjectType.c
@@ -0,0 +1,609 @@
+//-----------------------------------------------------------------------------
+// ObjectType.c
+//   Defines the routines for handling Oracle type information.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// structures used for handling object types
+//-----------------------------------------------------------------------------
+typedef struct {
+    PyObject_HEAD
+    udt_Environment *environment;
+    OCIType *tdo;
+    PyObject *schema;
+    PyObject *name;
+    PyObject *attributes;
+    PyObject *attributesByName;
+    OCITypeCode collectionTypeCode;
+    OCITypeCode elementTypeCode;
+    PyObject *elementType;
+    int isCollection;
+} udt_ObjectType;
+
+typedef struct {
+    PyObject_HEAD
+    PyObject *name;
+    OCITypeCode typeCode;
+    udt_ObjectType *subType;
+} udt_ObjectAttribute;
+
+
+//-----------------------------------------------------------------------------
+// Declaration of type variable functions.
+//-----------------------------------------------------------------------------
+static udt_ObjectType *ObjectType_New(udt_Connection*, OCIParam*, ub4);
+static void ObjectType_Free(udt_ObjectType*);
+static PyObject *ObjectType_Repr(udt_ObjectType*);
+static udt_ObjectAttribute *ObjectAttribute_New(udt_Connection*, OCIParam*);
+static void ObjectAttribute_Free(udt_ObjectAttribute*);
+static PyObject *ObjectAttribute_Repr(udt_ObjectAttribute*);
+
+
+//-----------------------------------------------------------------------------
+// declaration of members for Python type "ObjectType"
+//-----------------------------------------------------------------------------
+static PyMemberDef g_ObjectTypeMembers[] = {
+    { "schema", T_OBJECT, offsetof(udt_ObjectType, schema), READONLY },
+    { "name", T_OBJECT, offsetof(udt_ObjectType, name), READONLY },
+    { "attributes", T_OBJECT, offsetof(udt_ObjectType, attributes), READONLY },
+    { NULL }
+};
+
+
+//-----------------------------------------------------------------------------
+// declaration of members for Python type "ObjectAttribute"
+//-----------------------------------------------------------------------------
+static PyMemberDef g_ObjectAttributeMembers[] = {
+    { "name", T_OBJECT, offsetof(udt_ObjectAttribute, name), READONLY },
+    { NULL }
+};
+
+
+//-----------------------------------------------------------------------------
+// Python type declarations
+//-----------------------------------------------------------------------------
+static PyTypeObject g_ObjectTypeType = {
+    PyVarObject_HEAD_INIT(NULL, 0)
+    "cx_Oracle.ObjectType",             // tp_name
+    sizeof(udt_ObjectType),             // tp_basicsize
+    0,                                  // tp_itemsize
+    (destructor) ObjectType_Free,       // tp_dealloc
+    0,                                  // tp_print
+    0,                                  // tp_getattr
+    0,                                  // tp_setattr
+    0,                                  // tp_compare
+    (reprfunc) ObjectType_Repr,         // tp_repr
+    0,                                  // tp_as_number
+    0,                                  // tp_as_sequence
+    0,                                  // tp_as_mapping
+    0,                                  // tp_hash
+    0,                                  // tp_call
+    0,                                  // tp_str
+    0,                                  // tp_getattro
+    0,                                  // tp_setattro
+    0,                                  // tp_as_buffer
+    Py_TPFLAGS_DEFAULT,                 // tp_flags
+    0,                                  // tp_doc
+    0,                                  // tp_traverse
+    0,                                  // tp_clear
+    0,                                  // tp_richcompare
+    0,                                  // tp_weaklistoffset
+    0,                                  // tp_iter
+    0,                                  // tp_iternext
+    0,                                  // tp_methods
+    g_ObjectTypeMembers,                // tp_members
+    0,                                  // tp_getset
+    0,                                  // tp_base
+    0,                                  // tp_dict
+    0,                                  // tp_descr_get
+    0,                                  // tp_descr_set
+    0,                                  // tp_dictoffset
+    0,                                  // tp_init
+    0,                                  // tp_alloc
+    0,                                  // tp_new
+    0,                                  // tp_free
+    0,                                  // tp_is_gc
+    0                                   // tp_bases
+};
+
+
+static PyTypeObject g_ObjectAttributeType = {
+    PyVarObject_HEAD_INIT(NULL, 0)
+    "cx_Oracle.ObjectAttribute",        // tp_name
+    sizeof(udt_ObjectAttribute),        // tp_basicsize
+    0,                                  // tp_itemsize
+    (destructor) ObjectAttribute_Free,  // tp_dealloc
+    0,                                  // tp_print
+    0,                                  // tp_getattr
+    0,                                  // tp_setattr
+    0,                                  // tp_compare
+    (reprfunc) ObjectAttribute_Repr,    // tp_repr
+    0,                                  // tp_as_number
+    0,                                  // tp_as_sequence
+    0,                                  // tp_as_mapping
+    0,                                  // tp_hash
+    0,                                  // tp_call
+    0,                                  // tp_str
+    0,                                  // tp_getattro
+    0,                                  // tp_setattro
+    0,                                  // tp_as_buffer
+    Py_TPFLAGS_DEFAULT,                 // tp_flags
+    0,                                  // tp_doc
+    0,                                  // tp_traverse
+    0,                                  // tp_clear
+    0,                                  // tp_richcompare
+    0,                                  // tp_weaklistoffset
+    0,                                  // tp_iter
+    0,                                  // tp_iternext
+    0,                                  // tp_methods
+    g_ObjectAttributeMembers,           // tp_members
+    0,                                  // tp_getset
+    0,                                  // tp_base
+    0,                                  // tp_dict
+    0,                                  // tp_descr_get
+    0,                                  // tp_descr_set
+    0,                                  // tp_dictoffset
+    0,                                  // tp_init
+    0,                                  // tp_alloc
+    0,                                  // tp_new
+    0,                                  // tp_free
+    0,                                  // tp_is_gc
+    0                                   // tp_bases
+};
+
+
+//-----------------------------------------------------------------------------
+// ObjectType_Describe()
+//   Describe the type and store information about it as needed.
+//-----------------------------------------------------------------------------
+static int ObjectType_Describe(
+    udt_ObjectType *self,               // type to populate
+    udt_Connection *connection,         // connection for type information
+    OCIDescribe *describeHandle)        // describe handle
+{
+    OCIParam *topLevelParam, *attributeListParam, *attributeParam;
+    udt_ObjectAttribute *attribute;
+    OCIParam *collectionParam;
+    OCITypeCode typeCode;
+    ub2 numAttributes;
+    sword status;
+    int i;
+
+    // describe the type
+    status = OCIDescribeAny(connection->handle, self->environment->errorHandle,
+            (dvoid*) self->tdo, 0, OCI_OTYPE_PTR, OCI_DEFAULT, OCI_PTYPE_TYPE,
+            describeHandle);
+    if (Environment_CheckForError(self->environment, status,
+            "ObjectType_Describe(): describe type") < 0)
+        return -1;
+
+    // get top level parameter descriptor
+    status = OCIAttrGet(describeHandle, OCI_HTYPE_DESCRIBE, &topLevelParam, 0,
+            OCI_ATTR_PARAM, self->environment->errorHandle);
+    if (Environment_CheckForError(self->environment, status,
+            "ObjectType_Describe(): get top level parameter descriptor") < 0)
+        return -1;
+
+    // determine type of type
+    status = OCIAttrGet(topLevelParam, OCI_DTYPE_PARAM, &typeCode, 0,
+            OCI_ATTR_TYPECODE, self->environment->errorHandle);
+    if (Environment_CheckForError(self->environment, status,
+            "ObjectType_Describe(): get type code") < 0)
+        return -1;
+
+    // if a collection, need to determine the sub type
+    if (typeCode == OCI_TYPECODE_NAMEDCOLLECTION) {
+        self->isCollection = 1;
+
+        // determine type of collection
+        status = OCIAttrGet(topLevelParam, OCI_DTYPE_PARAM,
+                &self->collectionTypeCode, 0, OCI_ATTR_COLLECTION_TYPECODE,
+                self->environment->errorHandle);
+        if (Environment_CheckForError(self->environment, status,
+                "ObjectType_Describe(): get collection type code") < 0)
+            return -1;
+
+        // acquire collection parameter descriptor
+        status = OCIAttrGet(topLevelParam, OCI_DTYPE_PARAM, &collectionParam,
+                0, OCI_ATTR_COLLECTION_ELEMENT,
+                self->environment->errorHandle);
+        if (Environment_CheckForError(self->environment, status,
+                "ObjectType_Describe(): get collection descriptor") < 0)
+            return -1;
+
+        // determine type of element
+        status = OCIAttrGet(collectionParam, OCI_DTYPE_PARAM,
+                &self->elementTypeCode, 0, OCI_ATTR_TYPECODE,
+                self->environment->errorHandle);
+        if (Environment_CheckForError(self->environment, status,
+                "ObjectType_Describe(): get element type code") < 0)
+            return -1;
+
+        // if element type is an object type get its type
+        if (self->elementTypeCode == OCI_TYPECODE_OBJECT) {
+            self->elementType = (PyObject*)
+                    ObjectType_New(connection, collectionParam,
+                            OCI_ATTR_TYPE_NAME);
+            if (!self->elementType)
+                return -1;
+        }
+
+    }
+
+    // determine the number of attributes
+    status = OCIAttrGet(topLevelParam, OCI_DTYPE_PARAM,
+            (dvoid*) &numAttributes, 0, OCI_ATTR_NUM_TYPE_ATTRS,
+            self->environment->errorHandle);
+    if (Environment_CheckForError(self->environment, status,
+            "ObjectType_Describe(): get number of attributes") < 0)
+        return -1;
+
+    // allocate the attribute list and dictionary
+    self->attributes = PyList_New(numAttributes);
+    if (!self->attributes)
+        return -1;
+    self->attributesByName = PyDict_New();
+    if (!self->attributesByName)
+        return -1;
+
+    // acquire the list parameter descriptor
+    status = OCIAttrGet(topLevelParam, OCI_DTYPE_PARAM,
+            (dvoid*) &attributeListParam, 0, OCI_ATTR_LIST_TYPE_ATTRS,
+            self->environment->errorHandle);
+    if (Environment_CheckForError(self->environment, status,
+            "ObjectType_Describe(): get list parameter descriptor") < 0)
+        return -1;
+
+    // create attribute information for each attribute
+    for (i = 0; i < numAttributes; i++) {
+        status = OCIParamGet(attributeListParam, OCI_DTYPE_PARAM,
+                self->environment->errorHandle, (dvoid**) &attributeParam,
+                (ub4) i + 1);
+        if (Environment_CheckForError(self->environment, status,
+                "ObjectType_Describe(): get attribute param descriptor") < 0)
+            return -1;
+        attribute = ObjectAttribute_New(connection, attributeParam);
+        if (!attribute)
+            return -1;
+        PyList_SET_ITEM(self->attributes, i, (PyObject*) attribute);
+        if (PyDict_SetItem(self->attributesByName, attribute->name,
+                (PyObject*) attribute) < 0)
+            return -1;
+    }
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// ObjectType_Initialize()
+//   Initialize the object type with the information that is required.
+//-----------------------------------------------------------------------------
+static int ObjectType_Initialize(
+    udt_ObjectType *self,               // type to initialize
+    udt_Connection *connection,         // connection for type information
+    OCIParam *param,                    // parameter descriptor
+    ub4 nameAttribute)                  // value for the name attribute
+{
+    OCIDescribe *describeHandle;
+    OCIRef *tdoReference;
+    sword status;
+    char *name;
+    ub4 size;
+
+    // determine the schema of the type
+    status = OCIAttrGet(param, OCI_HTYPE_DESCRIBE, (dvoid*) &name, &size,
+            OCI_ATTR_SCHEMA_NAME, self->environment->errorHandle);
+    if (Environment_CheckForError(self->environment, status,
+            "ObjectType_Initialize(): get schema name") < 0)
+        return -1;
+    self->schema = cxString_FromEncodedString(name, size,
+            self->environment->encoding);
+    if (!self->schema)
+        return -1;
+
+    // determine the name of the type
+    status = OCIAttrGet(param, OCI_HTYPE_DESCRIBE, (dvoid*) &name, &size,
+            nameAttribute, self->environment->errorHandle);
+    if (Environment_CheckForError(self->environment, status,
+            "ObjectType_Initialize(): get name") < 0)
+        return -1;
+    self->name = cxString_FromEncodedString(name, size,
+            self->environment->encoding);
+    if (!self->name)
+        return -1;
+
+    // retrieve TDO of the parameter
+    status = OCIAttrGet(param, OCI_HTYPE_DESCRIBE, (dvoid*) &tdoReference, 0,
+            OCI_ATTR_REF_TDO, self->environment->errorHandle);
+    if (Environment_CheckForError(self->environment, status,
+            "ObjectType_Initialize(): get TDO reference") < 0)
+        return -1;
+    status = OCIObjectPin(self->environment->handle,
+            self->environment->errorHandle, tdoReference, NULL, OCI_PIN_ANY,
+            OCI_DURATION_SESSION, OCI_LOCK_NONE, (dvoid**) &self->tdo);
+    if (Environment_CheckForError(self->environment, status,
+            "ObjectType_Initialize(): pin TDO reference") < 0)
+        return -1;
+
+    // acquire a describe handle
+    status = OCIHandleAlloc(self->environment->handle,
+            (dvoid**) &describeHandle, OCI_HTYPE_DESCRIBE, 0, 0);
+    if (Environment_CheckForError(self->environment, status,
+            "ObjectType_Initialize(): allocate describe handle") < 0)
+        return -1;
+
+    // describe the type
+    if (ObjectType_Describe(self, connection, describeHandle) < 0)
+        return -1;
+
+    // free the describe handle
+    status = OCIHandleFree(describeHandle, OCI_HTYPE_DESCRIBE);
+    if (Environment_CheckForError(self->environment, status,
+            "ObjectType_Initialize(): free describe handle") < 0)
+        return -1;
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// ObjectType_New()
+//   Allocate a new object type.
+//-----------------------------------------------------------------------------
+static udt_ObjectType *ObjectType_New(
+    udt_Connection *connection,         // connection for type information
+    OCIParam *param,                    // parameter descriptor
+    ub4 nameAttribute)                  // value for the name attribute
+{
+    udt_ObjectType *self;
+
+    self = (udt_ObjectType*) g_ObjectTypeType.tp_alloc(&g_ObjectTypeType, 0);
+    if (!self)
+        return NULL;
+    Py_INCREF(connection->environment);
+    self->environment = connection->environment;
+    self->tdo = NULL;
+    self->schema = NULL;
+    self->name = NULL;
+    self->attributes = NULL;
+    self->attributesByName = NULL;
+    self->elementType = NULL;
+    self->isCollection = 0;
+    if (ObjectType_Initialize(self, connection, param, nameAttribute) < 0) {
+        Py_DECREF(self);
+        return NULL;
+    }
+
+    return self;
+}
+
+
+//-----------------------------------------------------------------------------
+// ObjectType_NewByName()
+//   Create a new object type given its name.
+//-----------------------------------------------------------------------------
+static udt_ObjectType *ObjectType_NewByName(
+    udt_Connection *connection,         // connection for type information
+    PyObject *name)                     // name of object type to describe
+{
+    OCIDescribe *describeHandle;
+    udt_ObjectType *result;
+    udt_Buffer buffer;
+    OCIParam *param;
+    sword status;
+
+    // allocate describe handle
+    status = OCIHandleAlloc(connection->environment->handle,
+            (dvoid**) &describeHandle, OCI_HTYPE_DESCRIBE, 0, 0);
+    if (Environment_CheckForError(connection->environment, status,
+            "ObjectType_NewByName(): allocate describe handle") < 0)
+        return NULL;
+
+    // describe the object
+    if (cxBuffer_FromObject(&buffer, name,
+            connection->environment->encoding) < 0) {
+        OCIHandleFree(describeHandle, OCI_HTYPE_DESCRIBE);
+        return NULL;
+    }
+    status = OCIDescribeAny(connection->handle,
+            connection->environment->errorHandle, (dvoid*) buffer.ptr,
+            buffer.size, OCI_OTYPE_NAME, 0, OCI_PTYPE_TYPE, describeHandle);
+    cxBuffer_Clear(&buffer);
+    if (Environment_CheckForError(connection->environment, status,
+            "ObjectType_NewByName(): describe type") < 0) {
+        OCIHandleFree(describeHandle, OCI_HTYPE_DESCRIBE);
+        return NULL;
+    }
+
+    // get the parameter handle
+    status = OCIAttrGet(describeHandle, OCI_HTYPE_DESCRIBE, &param, 0,
+            OCI_ATTR_PARAM, connection->environment->errorHandle);
+    if (Environment_CheckForError(connection->environment, status,
+            "ObjectType_NewByName(): get parameter handle") < 0) {
+        OCIHandleFree(describeHandle, OCI_HTYPE_DESCRIBE);
+        return NULL;
+    }
+
+    // get object type
+    result = ObjectType_New(connection, param, OCI_ATTR_NAME);
+    if (!result) {
+        OCIHandleFree(describeHandle, OCI_HTYPE_DESCRIBE);
+        return NULL;
+    }
+
+    // free the describe handle
+    status = OCIHandleFree(describeHandle, OCI_HTYPE_DESCRIBE);
+    if (Environment_CheckForError(connection->environment, status,
+            "ObjectType_NewByName(): free describe handle") < 0)
+        return NULL;
+
+    return result;
+}
+
+
+//-----------------------------------------------------------------------------
+// ObjectType_Free()
+//   Free the memory associated with an object type.
+//-----------------------------------------------------------------------------
+static void ObjectType_Free(
+    udt_ObjectType *self)               // object type to free
+{
+    if (self->tdo)
+        OCIObjectUnpin(self->environment->handle,
+                self->environment->errorHandle, self->tdo);
+    Py_CLEAR(self->environment);
+    Py_CLEAR(self->schema);
+    Py_CLEAR(self->name);
+    Py_CLEAR(self->attributes);
+    Py_CLEAR(self->attributesByName);
+    Py_CLEAR(self->elementType);
+    Py_TYPE(self)->tp_free((PyObject*) self);
+}
+
+
+//-----------------------------------------------------------------------------
+// ObjectType_Repr()
+//   Return a string representation of the object type.
+//-----------------------------------------------------------------------------
+static PyObject *ObjectType_Repr(
+    udt_ObjectType *self)               // object type to return the string for
+{
+    PyObject *module, *name, *result, *format, *formatArgs;
+
+    if (GetModuleAndName(Py_TYPE(self), &module, &name) < 0)
+        return NULL;
+    format = cxString_FromAscii("<%s.%s %s.%s>");
+    if (!format) {
+        Py_DECREF(module);
+        Py_DECREF(name);
+        return NULL;
+    }
+    formatArgs = PyTuple_Pack(4, module, name, self->schema, self->name);
+    Py_DECREF(module);
+    Py_DECREF(name);
+    if (!formatArgs) {
+        Py_DECREF(format);
+        return NULL;
+    }
+    result = cxString_Format(format, formatArgs);
+    Py_DECREF(format);
+    Py_DECREF(formatArgs);
+    return result;
+}
+
+
+//-----------------------------------------------------------------------------
+// ObjectAttribute_Initialize()
+//   Initialize the new object attribute.
+//-----------------------------------------------------------------------------
+static int ObjectAttribute_Initialize(
+    udt_ObjectAttribute *self,          // object attribute to initialize
+    udt_Connection *connection,         // connection in use
+    OCIParam *param)                    // parameter descriptor
+{
+    sword status;
+    char *name;
+    ub4 size;
+
+    // determine the name of the attribute
+    status = OCIAttrGet(param, OCI_DTYPE_PARAM, (dvoid*) &name, &size,
+            OCI_ATTR_NAME, connection->environment->errorHandle);
+    if (Environment_CheckForError(connection->environment, status,
+            "ObjectAttribute_Initialize(): get name") < 0)
+        return -1;
+    self->name = cxString_FromEncodedString(name, size,
+            connection->environment->encoding);
+    if (!self->name)
+        return -1;
+
+    // determine the type of the attribute
+    status = OCIAttrGet(param, OCI_DTYPE_PARAM, (dvoid*) &self->typeCode, 0,
+            OCI_ATTR_TYPECODE, connection->environment->errorHandle);
+    if (Environment_CheckForError(connection->environment, status,
+            "ObjectAttribute_Initialize(): get type code") < 0)
+        return -1;
+
+    // if the type of the attribute is object, recurse
+    switch (self->typeCode) {
+        case OCI_TYPECODE_NAMEDCOLLECTION:
+        case OCI_TYPECODE_OBJECT:
+            self->subType = ObjectType_New(connection, param,
+                    OCI_ATTR_TYPE_NAME);
+            if (!self->subType)
+                return -1;
+            break;
+    };
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// ObjectAttribute_New()
+//   Allocate a new object attribute.
+//-----------------------------------------------------------------------------
+static udt_ObjectAttribute *ObjectAttribute_New(
+    udt_Connection *connection,         // connection information
+    OCIParam *param)                    // parameter descriptor
+{
+    udt_ObjectAttribute *self;
+
+    self = (udt_ObjectAttribute*)
+            g_ObjectAttributeType.tp_alloc(&g_ObjectAttributeType, 0);
+    if (!self)
+        return NULL;
+    self->name = NULL;
+    self->subType = NULL;
+    if (ObjectAttribute_Initialize(self, connection, param) < 0) {
+        Py_DECREF(self);
+        return NULL;
+    }
+
+    return self;
+}
+
+
+//-----------------------------------------------------------------------------
+// ObjectAttribute_Free()
+//   Free the memory associated with an object attribute.
+//-----------------------------------------------------------------------------
+static void ObjectAttribute_Free(
+    udt_ObjectAttribute *self)          // object attribute to free
+{
+    Py_CLEAR(self->name);
+    Py_CLEAR(self->subType);
+    Py_TYPE(self)->tp_free((PyObject*) self);
+}
+
+
+//-----------------------------------------------------------------------------
+// ObjectAttribute_Repr()
+//   Return a string representation of the object attribute.
+//-----------------------------------------------------------------------------
+static PyObject *ObjectAttribute_Repr(
+    udt_ObjectAttribute *self)          // attribute to return the string for
+{
+    PyObject *module, *name, *result, *format, *formatArgs;
+
+    if (GetModuleAndName(Py_TYPE(self), &module, &name) < 0)
+        return NULL;
+    format = cxString_FromAscii("<%s.%s %s>");
+    if (!format) {
+        Py_DECREF(module);
+        Py_DECREF(name);
+        return NULL;
+    }
+    formatArgs = PyTuple_Pack(3, module, name, self->name);
+    Py_DECREF(module);
+    Py_DECREF(name);
+    if (!formatArgs) {
+        Py_DECREF(format);
+        return NULL;
+    }
+    result = cxString_Format(format, formatArgs);
+    Py_DECREF(format);
+    Py_DECREF(formatArgs);
+    return result;
+}
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/ObjectVar.c b/desktop/core/ext-py/cx_Oracle-5.1.2/ObjectVar.c
new file mode 100644
index 0000000..5452f7f
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/ObjectVar.c
@@ -0,0 +1,226 @@
+//-----------------------------------------------------------------------------
+// ObjectVar.c
+//   Defines the routines for handling Oracle object variables.
+//-----------------------------------------------------------------------------
+
+#include "ObjectType.c"
+#include "ExternalObjectVar.c"
+
+//-----------------------------------------------------------------------------
+// Object type
+//-----------------------------------------------------------------------------
+typedef struct {
+    Variable_HEAD
+    dvoid **data;
+    dvoid **objectIndicator;
+    udt_Connection *connection;
+    udt_ObjectType *objectType;
+} udt_ObjectVar;
+
+//-----------------------------------------------------------------------------
+// Declaration of object variable functions.
+//-----------------------------------------------------------------------------
+static int ObjectVar_Initialize(udt_ObjectVar*, udt_Cursor*);
+static void ObjectVar_Finalize(udt_ObjectVar*);
+static PyObject *ObjectVar_GetValue(udt_ObjectVar*, unsigned);
+static int ObjectVar_PreDefine(udt_ObjectVar*, OCIParam*);
+static int ObjectVar_PostDefine(udt_ObjectVar*);
+static int ObjectVar_IsNull(udt_ObjectVar*, unsigned);
+
+//-----------------------------------------------------------------------------
+// declaration of members for Oracle objects
+//-----------------------------------------------------------------------------
+static PyMemberDef g_ObjectVarMembers[] = {
+    { "type", T_OBJECT, offsetof(udt_ObjectVar, objectType), READONLY },
+    { NULL }
+};
+
+
+//-----------------------------------------------------------------------------
+// Python type declarations
+//-----------------------------------------------------------------------------
+static PyTypeObject g_ObjectVarType = {
+    PyVarObject_HEAD_INIT(NULL, 0)
+    "cx_Oracle.OBJECTVAR",              // tp_name
+    sizeof(udt_ObjectVar),              // tp_basicsize
+    0,                                  // tp_itemsize
+    0,                                  // tp_dealloc
+    0,                                  // tp_print
+    0,                                  // tp_getattr
+    0,                                  // tp_setattr
+    0,                                  // tp_compare
+    0,                                  // tp_repr
+    0,                                  // tp_as_number
+    0,                                  // tp_as_sequence
+    0,                                  // tp_as_mapping
+    0,                                  // tp_hash
+    0,                                  // tp_call
+    0,                                  // tp_str
+    0,                                  // tp_getattro
+    0,                                  // tp_setattro
+    0,                                  // tp_as_buffer
+    Py_TPFLAGS_DEFAULT,                 // tp_flags
+    0,                                  // tp_doc
+    0,                                  // tp_traverse
+    0,                                  // tp_clear
+    0,                                  // tp_richcompare
+    0,                                  // tp_weaklistoffset
+    0,                                  // tp_iter
+    0,                                  // tp_iternext
+    0,                                  // tp_methods
+    g_ObjectVarMembers                 // tp_members
+};
+
+
+//-----------------------------------------------------------------------------
+// variable type declarations
+//-----------------------------------------------------------------------------
+static udt_VariableType vt_Object = {
+    (InitializeProc) ObjectVar_Initialize,
+    (FinalizeProc) ObjectVar_Finalize,
+    (PreDefineProc) ObjectVar_PreDefine,
+    (PostDefineProc) ObjectVar_PostDefine,
+    (PreFetchProc) NULL,
+    (IsNullProc) ObjectVar_IsNull,
+    (SetValueProc) NULL,
+    (GetValueProc) ObjectVar_GetValue,
+    (GetBufferSizeProc) NULL,
+    &g_ObjectVarType,                   // Python type
+    SQLT_NTY,                           // Oracle type
+    SQLCS_IMPLICIT,                     // charset form
+    sizeof(dvoid*),                     // element length
+    0,                                  // is character data
+    0,                                  // is variable length
+    0,                                  // can be copied
+    0                                   // can be in array
+};
+
+
+//-----------------------------------------------------------------------------
+// ObjectVar_Initialize()
+//   Initialize the variable.
+//-----------------------------------------------------------------------------
+static int ObjectVar_Initialize(
+    udt_ObjectVar *self,                // variable to initialize
+    udt_Cursor *cursor)                 // cursor to use
+{
+    int i;
+
+    Py_INCREF(cursor->connection);
+    self->connection = cursor->connection;
+    self->objectType = NULL;
+    self->objectIndicator =
+            PyMem_Malloc(self->allocatedElements * sizeof(dvoid*));
+    if (!self->objectIndicator) {
+        PyErr_NoMemory();
+        return -1;
+    }
+    for (i = 0; i < self->allocatedElements; i++) {
+        self->data[i] = NULL;
+        self->objectIndicator[i] = NULL;
+    }
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// ObjectVar_Finalize()
+//   Prepare for variable destruction.
+//-----------------------------------------------------------------------------
+static void ObjectVar_Finalize(
+    udt_ObjectVar *self)                // variable to free
+{
+    int i;
+
+    for (i = 0; i < self->allocatedElements; i++) {
+        if (self->data[i])
+            OCIObjectFree(self->environment->handle,
+                    self->environment->errorHandle, self->data[i],
+                    OCI_OBJECTFREE_FORCE);
+    }
+    Py_DECREF(self->connection);
+    Py_XDECREF(self->objectType);
+    if (self->objectIndicator)
+        PyMem_Free(self->objectIndicator);
+}
+
+
+//-----------------------------------------------------------------------------
+// ObjectVar_PreDefine()
+//   Performs additional steps required for defining objects.
+//-----------------------------------------------------------------------------
+static int ObjectVar_PreDefine(
+    udt_ObjectVar *self,                // variable to set up
+    OCIParam *param)                    // parameter being defined
+{
+    self->objectType = ObjectType_New(self->connection, param,
+            OCI_ATTR_TYPE_NAME);
+    if (!self->objectType)
+        return -1;
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// ObjectVar_PostDefine()
+//   Performs additional steps required for defining objects.
+//-----------------------------------------------------------------------------
+static int ObjectVar_PostDefine(
+    udt_ObjectVar *self)                // variable to set up
+{
+    sword status;
+
+    status = OCIDefineObject(self->defineHandle,
+            self->environment->errorHandle, self->objectType->tdo, self->data,
+            0, self->objectIndicator, 0);
+    return Environment_CheckForError(self->environment, status,
+            "ObjectVar_PostDefine(): define object");
+}
+
+
+//-----------------------------------------------------------------------------
+// ObjectVar_IsNull()
+//   Returns a boolean indicating if the variable is null or not.
+//-----------------------------------------------------------------------------
+static int ObjectVar_IsNull(
+    udt_ObjectVar *self,                // variable to set up
+    unsigned pos)                       // position to check
+{
+    if (!self->objectIndicator[pos])
+        return 1;
+    return (*((OCIInd*) self->objectIndicator[pos]) == OCI_IND_NULL);
+}
+
+
+//-----------------------------------------------------------------------------
+// ObjectVar_GetValue()
+//   Returns the value stored at the given array position.
+//-----------------------------------------------------------------------------
+static PyObject *ObjectVar_GetValue(
+    udt_ObjectVar *self,                // variable to determine value for
+    unsigned pos)                       // array position
+{
+    PyObject *var;
+
+    // only allowed to get the value once (for now)
+    if (!self->data[pos]) {
+        PyErr_SetString(g_ProgrammingErrorException,
+                "variable value can only be acquired once");
+        return NULL;
+    }
+
+    // for collections, return the list rather than the object
+    if (self->objectType->isCollection)
+        return ExternalObjectVar_ConvertCollection(self->environment,
+                self->data[pos], (PyObject*) self, self->objectType);
+
+    // for objects, return a representation of the object
+    var = ExternalObjectVar_New((PyObject*) self, self->objectType,
+            self->data[pos], self->objectIndicator[pos], 1);
+    if (!var)
+        return NULL;
+    self->data[pos] = NULL;
+    self->objectIndicator[pos] = NULL;
+    return var;
+}
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/PKG-INFO b/desktop/core/ext-py/cx_Oracle-5.1.2/PKG-INFO
new file mode 100644
index 0000000..ebb6cc9
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/PKG-INFO
@@ -0,0 +1,22 @@
+Metadata-Version: 1.0
+Name: cx_Oracle
+Version: 5.1.2
+Summary: Python interface to Oracle
+Home-page: http://cx-oracle.sourceforge.net
+Author: Anthony Tuininga
+Author-email: anthony.tuininga@gmail.com
+License: Python Software Foundation License
+Description: Python interface to Oracle conforming to the Python DB API 2.0 specification.
+        See http://www.python.org/topics/database/DatabaseAPI-2.0.html.
+Keywords: Oracle
+Platform: UNKNOWN
+Classifier: Development Status :: 6 - Mature
+Classifier: Intended Audience :: Developers
+Classifier: License :: OSI Approved :: Python Software Foundation License
+Classifier: Natural Language :: English
+Classifier: Operating System :: OS Independent
+Classifier: Programming Language :: C
+Classifier: Programming Language :: Python
+Classifier: Programming Language :: Python :: 2
+Classifier: Programming Language :: Python :: 3
+Classifier: Topic :: Database
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/README.txt b/desktop/core/ext-py/cx_Oracle-5.1.2/README.txt
new file mode 100644
index 0000000..5a8ece7
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/README.txt
@@ -0,0 +1,71 @@
+Open Source Python/Oracle Utility - cx_Oracle
+---------------------------------------------
+cx_Oracle is a Python extension module that allows access to Oracle and 
+conforms to the Python database API 2.0 specifications with a number of
+additions. The method cursor.nextset() and the time data type are not
+supported by Oracle and are therefore not implemented.
+
+See http://www.python.org/topics/database/DatabaseAPI-2.0.html for more
+information on the Python database API specification. See the included
+documentation for additional information.
+
+For feedback or patches, contact Anthony Tuininga at
+anthony.tuininga@gmail.com. For help or to ask questions, please use the
+mailing list at http://lists.sourceforge.net/lists/listinfo/cx-oracle-users.
+
+Please note that an Oracle client (or server) installation is required in order
+to use cx_Oracle. If you do not require the tools that come with a full client
+installation, it is recommended to install the Instant Client which is far
+easier to install.
+
+
+Binary Install
+--------------
+Place the file cx_Oracle.pyd or cx_Oracle.so anywhere on your Python path.
+
+
+Source Install
+--------------
+This module has been built with Oracle 9.2.0, 10.2.0, 11.1.0 on Linux,
+Solaris and Windows. Others have reported success with other platforms
+such as Mac OS X.
+
+Use the provided setup.py to build and install the module which makes use of 
+the distutils module. Note that on Windows, I have used mingw32 
+(http://www.mingw.org) and the module will not build with MSVC without 
+modification. The commands required to build and install the module are as 
+follows:
+
+	python setup.py build
+	python setup.py install
+
+See BUILD.txt for additional information.
+
+
+Usage Example
+-------------
+
+import cx_Oracle
+
+# connect via SQL*Net string or by each segment in a separate argument
+#connection = cx_Oracle.connect("user/password@TNS")
+connection = cx_Oracle.connect("user", "password", "TNS")
+
+cursor = connection.cursor()
+cursor.execute("""
+        select Col1, Col2, Col3
+        from SomeTable
+        where Col4 = :arg_1
+          and Col5 between :arg_2 and :arg_3""",
+        arg_1 = "VALUE",
+        arg_2 = 5,
+        arg_3 = 15)
+for column_1, column_2, column_3 in cursor:
+    print "Values:", column_1, column_2, column_3
+
+
+For more examples, please see the test suite in the test directory and the
+samples in the samples directory. You can also look at the scripts in the
+cx_OracleTools (http://cx-oracletools.sourceforge.net) and the modules in the
+cx_PyOracleLib (http://cx-pyoraclelib.sourceforge.net) projects.
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/SessionPool.c b/desktop/core/ext-py/cx_Oracle-5.1.2/SessionPool.c
new file mode 100644
index 0000000..6f08148
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/SessionPool.c
@@ -0,0 +1,533 @@
+//-----------------------------------------------------------------------------
+// SessionPool.c
+//   Handles session pooling (only available in Oracle 9i and up).
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// structure for the Python type "SessionPool"
+//-----------------------------------------------------------------------------
+typedef struct {
+    PyObject_HEAD
+    OCISPool *handle;
+    ub4 minSessions;
+    ub4 maxSessions;
+    ub4 sessionIncrement;
+    ub4 cacheSize;
+    int homogeneous;
+    PyObject *name;
+    PyObject *username;
+    PyObject *password;
+    PyObject *dsn;
+    udt_Environment *environment;
+    PyTypeObject *connectionType;
+} udt_SessionPool;
+
+//-----------------------------------------------------------------------------
+// constants for the OCI attributes
+//-----------------------------------------------------------------------------
+static ub4 gc_OpenAttribute = OCI_ATTR_SPOOL_OPEN_COUNT;
+static ub4 gc_BusyAttribute = OCI_ATTR_SPOOL_BUSY_COUNT;
+static ub4 gc_TimeoutAttribute = OCI_ATTR_SPOOL_TIMEOUT;
+static ub4 gc_GetModeAttribute = OCI_ATTR_SPOOL_GETMODE;
+
+//-----------------------------------------------------------------------------
+// functions for the Python type "SessionPool"
+//-----------------------------------------------------------------------------
+static PyObject *SessionPool_New(PyTypeObject*, PyObject*, PyObject*);
+static int SessionPool_Init(udt_SessionPool*, PyObject*, PyObject*);
+static void SessionPool_Free(udt_SessionPool*);
+static PyObject *SessionPool_Acquire(udt_SessionPool*, PyObject*, PyObject*);
+static PyObject *SessionPool_Drop(udt_SessionPool*, PyObject*);
+static PyObject *SessionPool_Release(udt_SessionPool*, PyObject*);
+static PyObject *SessionPool_GetOCIAttr(udt_SessionPool*, ub4*);
+static int SessionPool_SetOCIAttr(udt_SessionPool*, PyObject*, ub4*);
+
+
+//-----------------------------------------------------------------------------
+// declaration of methods for Python type "SessionPool"
+//-----------------------------------------------------------------------------
+static PyMethodDef g_SessionPoolMethods[] = {
+    { "acquire", (PyCFunction) SessionPool_Acquire,
+            METH_VARARGS | METH_KEYWORDS },
+    { "drop", (PyCFunction) SessionPool_Drop, METH_VARARGS },
+    { "release", (PyCFunction) SessionPool_Release, METH_VARARGS },
+    { NULL }
+};
+
+
+//-----------------------------------------------------------------------------
+// declaration of members for Python type "SessionPool"
+//-----------------------------------------------------------------------------
+static PyMemberDef g_SessionPoolMembers[] = {
+    { "username", T_OBJECT, offsetof(udt_SessionPool, username), READONLY },
+    { "password", T_OBJECT, offsetof(udt_SessionPool, password), 0 },
+    { "dsn", T_OBJECT, offsetof(udt_SessionPool, dsn), READONLY },
+    { "tnsentry", T_OBJECT, offsetof(udt_SessionPool, dsn), READONLY },
+    { "name", T_OBJECT, offsetof(udt_SessionPool, name), READONLY },
+    { "max", T_INT, offsetof(udt_SessionPool, maxSessions), READONLY },
+    { "min", T_INT, offsetof(udt_SessionPool, minSessions), READONLY },
+    { "increment", T_INT, offsetof(udt_SessionPool, sessionIncrement),
+            READONLY },
+    { "homogeneous", T_INT, offsetof(udt_SessionPool, homogeneous), READONLY },
+    { NULL }
+};
+
+
+//-----------------------------------------------------------------------------
+// declaration of calculated members for Python type "SessionPool"
+//-----------------------------------------------------------------------------
+static PyGetSetDef g_SessionPoolCalcMembers[] = {
+    { "opened", (getter) SessionPool_GetOCIAttr, 0, 0, &gc_OpenAttribute },
+    { "busy", (getter) SessionPool_GetOCIAttr, 0, 0, &gc_BusyAttribute },
+    { "timeout", (getter) SessionPool_GetOCIAttr,
+            (setter) SessionPool_SetOCIAttr, 0, &gc_TimeoutAttribute },
+    { "getmode", (getter) SessionPool_GetOCIAttr,
+            (setter) SessionPool_SetOCIAttr, 0, &gc_GetModeAttribute },
+    { NULL }
+};
+
+
+//-----------------------------------------------------------------------------
+// declaration of Python type "SessionPool"
+//-----------------------------------------------------------------------------
+static PyTypeObject g_SessionPoolType = {
+    PyVarObject_HEAD_INIT(NULL, 0)
+    "OracleSessionPool",                // tp_name
+    sizeof(udt_SessionPool),            // tp_basicsize
+    0,                                  // tp_itemsize
+    (destructor) SessionPool_Free,      // tp_dealloc
+    0,                                  // tp_print
+    0,                                  // tp_getattr
+    0,                                  // tp_setattr
+    0,                                  // tp_compare
+    0,                                  // tp_repr
+    0,                                  // tp_as_number
+    0,                                  // tp_as_sequence
+    0,                                  // tp_as_mapping
+    0,                                  // tp_hash
+    0,                                  // tp_call
+    0,                                  // tp_str
+    0,                                  // tp_getattro
+    0,                                  // tp_setattro
+    0,                                  // tp_as_buffer
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
+                                        // tp_flags
+    0,                                  // tp_doc
+    0,                                  // tp_traverse
+    0,                                  // tp_clear
+    0,                                  // tp_richcompare
+    0,                                  // tp_weaklistoffset
+    0,                                  // tp_iter
+    0,                                  // tp_iternext
+    g_SessionPoolMethods,               // tp_methods
+    g_SessionPoolMembers,               // tp_members
+    g_SessionPoolCalcMembers,           // tp_getset
+    0,                                  // tp_base
+    0,                                  // tp_dict
+    0,                                  // tp_descr_get
+    0,                                  // tp_descr_set
+    0,                                  // tp_dictoffset
+    (initproc) SessionPool_Init,        // tp_init
+    0,                                  // tp_alloc
+    (newfunc) SessionPool_New,          // tp_new
+    0,                                  // tp_free
+    0,                                  // tp_is_gc
+    0                                   // tp_bases
+};
+
+
+#include "Connection.c"
+
+
+//-----------------------------------------------------------------------------
+// SessionPool_New()
+//   Create a new session pool object.
+//-----------------------------------------------------------------------------
+static PyObject *SessionPool_New(
+    PyTypeObject *type,                 // type object
+    PyObject *args,                     // arguments
+    PyObject *keywordArgs)              // keyword arguments
+{
+    udt_SessionPool *newObject;
+
+    // create the object
+    newObject = (udt_SessionPool*) type->tp_alloc(type, 0);
+    if (!newObject)
+        return NULL;
+    newObject->environment = NULL;
+
+    return (PyObject*) newObject;
+}
+
+
+//-----------------------------------------------------------------------------
+// SessionPool_Init()
+//   Initialize the session pool object.
+//-----------------------------------------------------------------------------
+static int SessionPool_Init(
+    udt_SessionPool *self,              // session pool object
+    PyObject *args,                     // arguments
+    PyObject *keywordArgs)              // keyword arguments
+{
+    unsigned minSessions, maxSessions, sessionIncrement;
+    PyObject *threadedObj, *eventsObj, *homogeneousObj;
+    udt_Buffer username, password, dsn;
+    int threaded, events, homogeneous;
+    PyTypeObject *connectionType;
+    unsigned poolNameLength;
+    const char *poolName;
+    sword status;
+    ub4 poolMode;
+    ub1 getMode;
+
+    // define keyword arguments
+    static char *keywordList[] = { "user", "password", "dsn", "min", "max",
+            "increment", "connectiontype", "threaded", "getmode", "events",
+            "homogeneous", NULL };
+
+    // parse arguments and keywords
+    homogeneous = 1;
+    threaded = events = 0;
+    threadedObj = eventsObj = homogeneousObj = NULL;
+    connectionType = &g_ConnectionType;
+    getMode = OCI_SPOOL_ATTRVAL_NOWAIT;
+    if (!PyArg_ParseTupleAndKeywords(args, keywordArgs, "O!O!O!iii|OObOO",
+            keywordList, cxString_Type, &self->username,
+            cxString_Type, &self->password, cxString_Type, &self->dsn,
+            &minSessions, &maxSessions, &sessionIncrement, &connectionType,
+            &threadedObj, &getMode, &eventsObj, &homogeneousObj))
+        return -1;
+    if (!PyType_Check(connectionType)) {
+        PyErr_SetString(g_ProgrammingErrorException,
+                "connectiontype must be a type");
+        return -1;
+    }
+    if (!PyType_IsSubtype(connectionType, &g_ConnectionType)) {
+        PyErr_SetString(g_ProgrammingErrorException,
+                "connectiontype must be a subclass of Connection");
+        return -1;
+    }
+    if (threadedObj) {
+        threaded = PyObject_IsTrue(threadedObj);
+        if (threaded < 0)
+            return -1;
+    }
+    if (eventsObj) {
+        events = PyObject_IsTrue(eventsObj);
+        if (events < 0)
+            return -1;
+    }
+    if (homogeneousObj) {
+        homogeneous = PyObject_IsTrue(homogeneousObj);
+        if (homogeneous < 0)
+            return -1;
+    }
+
+    // initialize the object's members
+    Py_INCREF(connectionType);
+    self->connectionType = connectionType;
+    Py_INCREF(self->dsn);
+    Py_INCREF(self->username);
+    Py_INCREF(self->password);
+    self->minSessions = minSessions;
+    self->maxSessions = maxSessions;
+    self->sessionIncrement = sessionIncrement;
+    self->homogeneous = homogeneous;
+
+    // set up the environment
+    self->environment = Environment_NewFromScratch(threaded, events, NULL,
+            NULL);
+    if (!self->environment)
+        return -1;
+
+    // create the session pool handle
+    status = OCIHandleAlloc(self->environment->handle, (dvoid**) &self->handle,
+            OCI_HTYPE_SPOOL, 0, 0);
+    if (Environment_CheckForError(self->environment, status,
+            "SessionPool_New(): allocate handle") < 0)
+        return -1;
+
+    // prepare pool mode
+    poolMode = OCI_SPC_STMTCACHE;
+    if (self->homogeneous)
+        poolMode |= OCI_SPC_HOMOGENEOUS;
+
+    // create the session pool
+    if (cxBuffer_FromObject(&username, self->username,
+            self->environment->encoding) < 0)
+        return -1;
+    if (cxBuffer_FromObject(&password, self->password,
+            self->environment->encoding) < 0) {
+        cxBuffer_Clear(&username);
+        return -1;
+    }
+    if (cxBuffer_FromObject(&dsn, self->dsn,
+            self->environment->encoding) < 0) {
+        cxBuffer_Clear(&username);
+        cxBuffer_Clear(&password);
+        return -1;
+    }
+    Py_BEGIN_ALLOW_THREADS
+    status = OCISessionPoolCreate(self->environment->handle,
+            self->environment->errorHandle, self->handle,
+            (OraText**) &poolName, &poolNameLength, (OraText*) dsn.ptr,
+            dsn.size, minSessions, maxSessions, sessionIncrement,
+            (OraText*) username.ptr, username.size, (OraText*) password.ptr,
+            password.size, poolMode);
+    Py_END_ALLOW_THREADS
+    cxBuffer_Clear(&username);
+    cxBuffer_Clear(&password);
+    cxBuffer_Clear(&dsn);
+    if (Environment_CheckForError(self->environment, status,
+            "SessionPool_New(): create pool") < 0)
+        return -1;
+
+    // create the string for the pool name
+    self->name = cxString_FromEncodedString(poolName, poolNameLength,
+            self->environment->encoding);
+    if (!self->name)
+        return -1;
+
+    // set the mode on the pool
+    status = OCIAttrSet(self->handle, OCI_HTYPE_SPOOL, (dvoid*) &getMode, 0,
+            OCI_ATTR_SPOOL_GETMODE, self->environment->errorHandle);
+    if (Environment_CheckForError(self->environment, status,
+            "SessionPool_New(): set wait mode") < 0)
+        return -1;
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// SessionPool_Free()
+//   Deallocate the session pool.
+//-----------------------------------------------------------------------------
+static void SessionPool_Free(
+    udt_SessionPool *self)              // session pool
+{
+    if (self->handle) {
+        OCISessionPoolDestroy(self->handle, self->environment->errorHandle,
+                OCI_SPD_FORCE);
+        OCIHandleFree(self->handle, OCI_HTYPE_SPOOL);
+    }
+    Py_XDECREF(self->name);
+    Py_XDECREF(self->environment);
+    Py_XDECREF(self->username);
+    Py_XDECREF(self->password);
+    Py_XDECREF(self->dsn);
+    Py_TYPE(self)->tp_free((PyObject*) self);
+}
+
+
+//-----------------------------------------------------------------------------
+// SessionPool_IsConnected()
+//   Determines if the session pool object is connected to the database. If
+// not, a Python exception is raised.
+//-----------------------------------------------------------------------------
+static int SessionPool_IsConnected(
+    udt_SessionPool *self)              // session pool
+{
+    if (!self->handle) {
+        PyErr_SetString(g_InterfaceErrorException, "not connected");
+        return -1;
+    }
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// SessionPool_Acquire()
+//   Create a new connection within the session pool.
+//-----------------------------------------------------------------------------
+static PyObject *SessionPool_Acquire(
+    udt_SessionPool *self,              // session pool
+    PyObject *args,                     // arguments
+    PyObject *keywordArgs)              // keyword arguments
+{
+    static char *keywordList[] = { "user", "password", "cclass", "purity",
+            NULL };
+    PyObject *createKeywordArgs, *result, *cclassObj, *purityObj;
+    unsigned usernameLength, passwordLength;
+    char *username, *password;
+
+    // parse arguments
+    username = NULL;
+    password = NULL;
+    if (!PyArg_ParseTupleAndKeywords(args, keywordArgs, "|s#s#OO", keywordList,
+            &username, &usernameLength, &password, &passwordLength, &cclassObj,
+            &purityObj))
+        return NULL;
+    if (self->homogeneous && (username || password)) {
+        PyErr_SetString(g_ProgrammingErrorException,
+                "pool is homogeneous. Proxy authentication is not possible.");
+        return NULL;
+    }
+
+    // make sure session pool is connected
+    if (SessionPool_IsConnected(self) < 0)
+        return NULL;
+
+    // create arguments
+    if (keywordArgs)
+        createKeywordArgs = PyDict_Copy(keywordArgs);
+    else createKeywordArgs = PyDict_New();
+    if (!createKeywordArgs)
+        return NULL;
+    if (PyDict_SetItemString(createKeywordArgs, "pool",
+            (PyObject*) self) < 0) {
+        Py_DECREF(createKeywordArgs);
+        return NULL;
+    }
+
+    // create the connection object
+    result = PyObject_Call( (PyObject*) self->connectionType, args,
+            createKeywordArgs);
+    Py_DECREF(createKeywordArgs);
+
+    return result;
+}
+
+
+//-----------------------------------------------------------------------------
+// SessionPool_InternalRelease()
+//   Internal method used to release a connection back to the pool in order to
+// allow for the possibility of dropping the connection.
+//-----------------------------------------------------------------------------
+static PyObject *SessionPool_InternalRelease(
+    udt_SessionPool *self,              // session pool
+    PyObject *args,                     // arguments
+    ub4 mode)                           // OCI mode to use
+{
+    udt_Connection *connection;
+    sword status;
+
+    // connection is expected
+    if (!PyArg_ParseTuple(args, "O!", &g_ConnectionType, &connection))
+        return NULL;
+
+    // make sure session pool is connected
+    if (SessionPool_IsConnected(self) < 0)
+        return NULL;
+    if (connection->sessionPool != self) {
+        PyErr_SetString(g_ProgrammingErrorException,
+                "connection not acquired with this session pool");
+        return NULL;
+    }
+
+    // attempt a rollback but if dropping the connection from the pool
+    // ignore the error
+    Py_BEGIN_ALLOW_THREADS
+    status = OCITransRollback(connection->handle,
+            connection->environment->errorHandle, OCI_DEFAULT);
+    Py_END_ALLOW_THREADS
+    if (Environment_CheckForError(connection->environment, status,
+            "SessionPool_Release(): rollback") < 0) {
+        if (mode != OCI_SESSRLS_DROPSESS)
+            return NULL;
+        PyErr_Clear();
+    }
+
+    // release the connection
+    Py_BEGIN_ALLOW_THREADS
+    status = OCISessionRelease(connection->handle,
+            connection->environment->errorHandle, NULL, 0, mode);
+    Py_END_ALLOW_THREADS
+    if (Environment_CheckForError(connection->environment, status,
+            "SessionPool_Release(): release session") < 0)
+        return NULL;
+
+    // ensure that the connection behaves as closed
+    Py_DECREF(connection->sessionPool);
+    connection->sessionPool = NULL;
+    connection->handle = NULL;
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+
+//-----------------------------------------------------------------------------
+// SessionPool_Drop()
+//   Release a connection back to the session pool, dropping it so that a new
+// connection will be created if needed.
+//-----------------------------------------------------------------------------
+static PyObject *SessionPool_Drop(
+    udt_SessionPool *self,              // session pool
+    PyObject *args)                     // arguments
+{
+    return SessionPool_InternalRelease(self, args, OCI_SESSRLS_DROPSESS);
+}
+
+
+//-----------------------------------------------------------------------------
+// SessionPool_Release()
+//   Release a connection back to the session pool.
+//-----------------------------------------------------------------------------
+static PyObject *SessionPool_Release(
+    udt_SessionPool *self,              // session pool
+    PyObject *args)                     // arguments
+{
+    return SessionPool_InternalRelease(self, args, OCI_DEFAULT);
+}
+
+
+//-----------------------------------------------------------------------------
+// SessionPool_GetOCIAttr()
+//   Return the value for the OCI attribute.
+//-----------------------------------------------------------------------------
+static PyObject *SessionPool_GetOCIAttr(
+    udt_SessionPool *self,              // session pool
+    ub4 *attribute)                     // OCI attribute type
+{
+    sword status;
+    ub4 value;
+
+    // make sure session pool is connected
+    if (SessionPool_IsConnected(self) < 0)
+        return NULL;
+
+    // get the value from the OCI
+    status = OCIAttrGet(self->handle, OCI_HTYPE_SPOOL, &value, 0, *attribute,
+            self->environment->errorHandle);
+    if (Environment_CheckForError(self->environment, status,
+            "SessionPool_GetOCIAttr()") < 0)
+        return NULL;
+    if (*attribute == OCI_ATTR_SPOOL_GETMODE)
+        return PyInt_FromLong((ub1) value);
+    return PyInt_FromLong(value);
+}
+
+
+//-----------------------------------------------------------------------------
+// SessionPool_SetOCIAttr()
+//   Set the value of the OCI attribute.
+//-----------------------------------------------------------------------------
+static int SessionPool_SetOCIAttr(
+    udt_SessionPool *self,              // session pool
+    PyObject *value,                    // value to set
+    ub4 *attribute)                     // OCI attribute type
+{
+    ub4 ociValue;
+    sword status;
+
+    // make sure session pool is connected
+    if (SessionPool_IsConnected(self) < 0)
+        return -1;
+
+    // set the value in the OCI
+    if (!PyInt_Check(value)) {
+        PyErr_SetString(PyExc_TypeError, "value must be an integer");
+        return -1;
+    }
+    ociValue = PyInt_AsLong(value);
+    if (PyErr_Occurred())
+        return -1;
+    status = OCIAttrSet(self->handle, OCI_HTYPE_SPOOL, &ociValue, 0,
+            *attribute, self->environment->errorHandle);
+    if (Environment_CheckForError(self->environment, status,
+            "SessionPool_SetOCIAttr()") < 0)
+        return -1;
+    return 0;
+}
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/StringVar.c b/desktop/core/ext-py/cx_Oracle-5.1.2/StringVar.c
new file mode 100644
index 0000000..a0a790d
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/StringVar.c
@@ -0,0 +1,436 @@
+//-----------------------------------------------------------------------------
+// StringVar.c
+//   Defines the routines specific to the string type.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// String type
+//-----------------------------------------------------------------------------
+typedef struct {
+    Variable_HEAD
+    char *data;
+} udt_StringVar;
+
+
+//-----------------------------------------------------------------------------
+// Declaration of string variable functions.
+//-----------------------------------------------------------------------------
+static int StringVar_Initialize(udt_StringVar*, udt_Cursor*);
+static int StringVar_SetValue(udt_StringVar*, unsigned, PyObject*);
+static PyObject *StringVar_GetValue(udt_StringVar*, unsigned);
+#if PY_MAJOR_VERSION < 3
+static int StringVar_PostDefine(udt_StringVar*);
+#endif
+static ub4 StringVar_GetBufferSize(udt_StringVar*);
+
+//-----------------------------------------------------------------------------
+// Python type declarations
+//-----------------------------------------------------------------------------
+static PyTypeObject g_StringVarType = {
+    PyVarObject_HEAD_INIT(NULL, 0)
+    "cx_Oracle.STRING",                 // tp_name
+    sizeof(udt_StringVar),              // tp_basicsize
+    0,                                  // tp_itemsize
+    0,                                  // tp_dealloc
+    0,                                  // tp_print
+    0,                                  // tp_getattr
+    0,                                  // tp_setattr
+    0,                                  // tp_compare
+    0,                                  // tp_repr
+    0,                                  // tp_as_number
+    0,                                  // tp_as_sequence
+    0,                                  // tp_as_mapping
+    0,                                  // tp_hash
+    0,                                  // tp_call
+    0,                                  // tp_str
+    0,                                  // tp_getattro
+    0,                                  // tp_setattro
+    0,                                  // tp_as_buffer
+    Py_TPFLAGS_DEFAULT,                 // tp_flags
+    0                                   // tp_doc
+};
+
+
+#if PY_MAJOR_VERSION < 3
+static PyTypeObject g_UnicodeVarType = {
+    PyVarObject_HEAD_INIT(NULL, 0)
+    "cx_Oracle.UNICODE",                // tp_name
+    sizeof(udt_StringVar),              // tp_basicsize
+    0,                                  // tp_itemsize
+    0,                                  // tp_dealloc
+    0,                                  // tp_print
+    0,                                  // tp_getattr
+    0,                                  // tp_setattr
+    0,                                  // tp_compare
+    0,                                  // tp_repr
+    0,                                  // tp_as_number
+    0,                                  // tp_as_sequence
+    0,                                  // tp_as_mapping
+    0,                                  // tp_hash
+    0,                                  // tp_call
+    0,                                  // tp_str
+    0,                                  // tp_getattro
+    0,                                  // tp_setattro
+    0,                                  // tp_as_buffer
+    Py_TPFLAGS_DEFAULT,                 // tp_flags
+    0                                   // tp_doc
+};
+#endif
+
+
+static PyTypeObject g_FixedCharVarType = {
+    PyVarObject_HEAD_INIT(NULL, 0)
+    "cx_Oracle.FIXED_CHAR",             // tp_name
+    sizeof(udt_StringVar),              // tp_basicsize
+    0,                                  // tp_itemsize
+    0,                                  // tp_dealloc
+    0,                                  // tp_print
+    0,                                  // tp_getattr
+    0,                                  // tp_setattr
+    0,                                  // tp_compare
+    0,                                  // tp_repr
+    0,                                  // tp_as_number
+    0,                                  // tp_as_sequence
+    0,                                  // tp_as_mapping
+    0,                                  // tp_hash
+    0,                                  // tp_call
+    0,                                  // tp_str
+    0,                                  // tp_getattro
+    0,                                  // tp_setattro
+    0,                                  // tp_as_buffer
+    Py_TPFLAGS_DEFAULT,                 // tp_flags
+    0                                   // tp_doc
+};
+
+
+#if PY_MAJOR_VERSION < 3
+static PyTypeObject g_FixedUnicodeVarType = {
+    PyVarObject_HEAD_INIT(NULL, 0)
+    "cx_Oracle.FIXED_UNICODE",          // tp_name
+    sizeof(udt_StringVar),              // tp_basicsize
+    0,                                  // tp_itemsize
+    0,                                  // tp_dealloc
+    0,                                  // tp_print
+    0,                                  // tp_getattr
+    0,                                  // tp_setattr
+    0,                                  // tp_compare
+    0,                                  // tp_repr
+    0,                                  // tp_as_number
+    0,                                  // tp_as_sequence
+    0,                                  // tp_as_mapping
+    0,                                  // tp_hash
+    0,                                  // tp_call
+    0,                                  // tp_str
+    0,                                  // tp_getattro
+    0,                                  // tp_setattro
+    0,                                  // tp_as_buffer
+    Py_TPFLAGS_DEFAULT,                 // tp_flags
+    0                                   // tp_doc
+};
+#endif
+
+
+static PyTypeObject g_RowidVarType = {
+    PyVarObject_HEAD_INIT(NULL, 0)
+    "cx_Oracle.ROWID",                  // tp_name
+    sizeof(udt_StringVar),              // tp_basicsize
+    0,                                  // tp_itemsize
+    0,                                  // tp_dealloc
+    0,                                  // tp_print
+    0,                                  // tp_getattr
+    0,                                  // tp_setattr
+    0,                                  // tp_compare
+    0,                                  // tp_repr
+    0,                                  // tp_as_number
+    0,                                  // tp_as_sequence
+    0,                                  // tp_as_mapping
+    0,                                  // tp_hash
+    0,                                  // tp_call
+    0,                                  // tp_str
+    0,                                  // tp_getattro
+    0,                                  // tp_setattro
+    0,                                  // tp_as_buffer
+    Py_TPFLAGS_DEFAULT,                 // tp_flags
+    0                                   // tp_doc
+};
+
+
+static PyTypeObject g_BinaryVarType = {
+    PyVarObject_HEAD_INIT(NULL, 0)
+    "cx_Oracle.BINARY",                 // tp_name
+    sizeof(udt_StringVar),              // tp_basicsize
+    0,                                  // tp_itemsize
+    0,                                  // tp_dealloc
+    0,                                  // tp_print
+    0,                                  // tp_getattr
+    0,                                  // tp_setattr
+    0,                                  // tp_compare
+    0,                                  // tp_repr
+    0,                                  // tp_as_number
+    0,                                  // tp_as_sequence
+    0,                                  // tp_as_mapping
+    0,                                  // tp_hash
+    0,                                  // tp_call
+    0,                                  // tp_str
+    0,                                  // tp_getattro
+    0,                                  // tp_setattro
+    0,                                  // tp_as_buffer
+    Py_TPFLAGS_DEFAULT,                 // tp_flags
+    0                                   // tp_doc
+};
+
+
+//-----------------------------------------------------------------------------
+// variable type declarations
+//-----------------------------------------------------------------------------
+static udt_VariableType vt_String = {
+    (InitializeProc) StringVar_Initialize,
+    (FinalizeProc) NULL,
+    (PreDefineProc) NULL,
+    (PostDefineProc) NULL,
+    (PreFetchProc) NULL,
+    (IsNullProc) NULL,
+    (SetValueProc) StringVar_SetValue,
+    (GetValueProc) StringVar_GetValue,
+    (GetBufferSizeProc) StringVar_GetBufferSize,
+    &g_StringVarType,                   // Python type
+    SQLT_CHR,                           // Oracle type
+    SQLCS_IMPLICIT,                     // charset form
+    MAX_STRING_CHARS,                   // element length (default)
+    1,                                  // is character data
+    1,                                  // is variable length
+    1,                                  // can be copied
+    1                                   // can be in array
+};
+
+
+#if PY_MAJOR_VERSION < 3
+static udt_VariableType vt_NationalCharString = {
+    (InitializeProc) StringVar_Initialize,
+    (FinalizeProc) NULL,
+    (PreDefineProc) NULL,
+    (PostDefineProc) StringVar_PostDefine,
+    (PreFetchProc) NULL,
+    (IsNullProc) NULL,
+    (SetValueProc) StringVar_SetValue,
+    (GetValueProc) StringVar_GetValue,
+    (GetBufferSizeProc) StringVar_GetBufferSize,
+    &g_UnicodeVarType,                  // Python type
+    SQLT_CHR,                           // Oracle type
+    SQLCS_NCHAR,                        // charset form
+    MAX_STRING_CHARS,                   // element length (default)
+    1,                                  // is character data
+    1,                                  // is variable length
+    1,                                  // can be copied
+    1                                   // can be in array
+};
+#endif
+
+
+static udt_VariableType vt_FixedChar = {
+    (InitializeProc) StringVar_Initialize,
+    (FinalizeProc) NULL,
+    (PreDefineProc) NULL,
+    (PostDefineProc) NULL,
+    (PreFetchProc) NULL,
+    (IsNullProc) NULL,
+    (SetValueProc) StringVar_SetValue,
+    (GetValueProc) StringVar_GetValue,
+    (GetBufferSizeProc) StringVar_GetBufferSize,
+    &g_FixedCharVarType,                // Python type
+    SQLT_AFC,                           // Oracle type
+    SQLCS_IMPLICIT,                     // charset form
+    2000,                               // element length (default)
+    1,                                  // is character data
+    1,                                  // is variable length
+    1,                                  // can be copied
+    1                                   // can be in array
+};
+
+
+#if PY_MAJOR_VERSION < 3
+static udt_VariableType vt_FixedNationalChar = {
+    (InitializeProc) StringVar_Initialize,
+    (FinalizeProc) NULL,
+    (PreDefineProc) NULL,
+    (PostDefineProc) StringVar_PostDefine,
+    (PreFetchProc) NULL,
+    (IsNullProc) NULL,
+    (SetValueProc) StringVar_SetValue,
+    (GetValueProc) StringVar_GetValue,
+    (GetBufferSizeProc) StringVar_GetBufferSize,
+    &g_FixedUnicodeVarType,             // Python type
+    SQLT_AFC,                           // Oracle type
+    SQLCS_NCHAR,                        // charset form
+    2000,                               // element length (default)
+    1,                                  // is character data
+    1,                                  // is variable length
+    1,                                  // can be copied
+    1                                   // can be in array
+};
+#endif
+
+
+static udt_VariableType vt_Rowid = {
+    (InitializeProc) StringVar_Initialize,
+    (FinalizeProc) NULL,
+    (PreDefineProc) NULL,
+    (PostDefineProc) NULL,
+    (PreFetchProc) NULL,
+    (IsNullProc) NULL,
+    (SetValueProc) StringVar_SetValue,
+    (GetValueProc) StringVar_GetValue,
+    (GetBufferSizeProc) StringVar_GetBufferSize,
+    &g_RowidVarType,                    // Python type
+    SQLT_CHR,                           // Oracle type
+    SQLCS_IMPLICIT,                     // charset form
+    18,                                 // element length (default)
+    1,                                  // is character data
+    0,                                  // is variable length
+    1,                                  // can be copied
+    1                                   // can be in array
+};
+
+
+static udt_VariableType vt_Binary = {
+    (InitializeProc) StringVar_Initialize,
+    (FinalizeProc) NULL,
+    (PreDefineProc) NULL,
+    (PostDefineProc) NULL,
+    (PreFetchProc) NULL,
+    (IsNullProc) NULL,
+    (SetValueProc) StringVar_SetValue,
+    (GetValueProc) StringVar_GetValue,
+    (GetBufferSizeProc) NULL,
+    &g_BinaryVarType,                   // Python type
+    SQLT_BIN,                           // Oracle type
+    SQLCS_IMPLICIT,                     // charset form
+    MAX_BINARY_BYTES,                   // element length (default)
+    0,                                  // is character data
+    1,                                  // is variable length
+    1,                                  // can be copied
+    1                                   // can be in array
+};
+
+
+//-----------------------------------------------------------------------------
+// StringVar_Initialize()
+//   Initialize the variable.
+//-----------------------------------------------------------------------------
+static int StringVar_Initialize(
+    udt_StringVar *var,                 // variable to initialize
+    udt_Cursor *cursor)                 // cursor to use
+{
+    var->actualLength = (ub2*) PyMem_Malloc(var->allocatedElements *
+            sizeof(ub2));
+    if (!var->actualLength) {
+        PyErr_NoMemory();
+        return -1;
+    }
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// StringVar_SetValue()
+//   Set the value of the variable.
+//-----------------------------------------------------------------------------
+static int StringVar_SetValue(
+    udt_StringVar *var,                 // variable to set value for
+    unsigned pos,                       // array position to set
+    PyObject *value)                    // value to set
+{
+    udt_Buffer buffer;
+
+    // populate the buffer and confirm the maximum size is not exceeded
+    if (cxBuffer_FromObject(&buffer, value, var->environment->encoding) < 0)
+        return -1;
+    if (var->type->isCharacterData
+            && buffer.numCharacters > MAX_STRING_CHARS) {
+        cxBuffer_Clear(&buffer);
+        PyErr_SetString(PyExc_ValueError, "string data too large");
+        return -1;
+    } else if (!var->type->isCharacterData
+            && buffer.size > MAX_BINARY_BYTES) {
+        cxBuffer_Clear(&buffer);
+        PyErr_SetString(PyExc_ValueError, "binary data too large");
+        return -1;
+    }
+
+    // ensure that the buffer is large enough
+    if (buffer.size > var->bufferSize) {
+        if (Variable_Resize( (udt_Variable*) var, buffer.numCharacters) < 0) {
+            cxBuffer_Clear(&buffer);
+            return -1;
+        }
+    }
+
+    // keep a copy of the string
+    var->actualLength[pos] = (ub2) buffer.size;
+    if (buffer.size)
+        memcpy(var->data + var->bufferSize * pos, buffer.ptr, buffer.size);
+    cxBuffer_Clear(&buffer);
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// StringVar_GetValue()
+//   Returns the value stored at the given array position.
+//-----------------------------------------------------------------------------
+static PyObject *StringVar_GetValue(
+    udt_StringVar *var,                 // variable to determine value for
+    unsigned pos)                       // array position
+{
+    char *data;
+
+    data = var->data + pos * var->bufferSize;
+    if (var->type == &vt_Binary)
+        return PyBytes_FromStringAndSize(data, var->actualLength[pos]);
+#if PY_MAJOR_VERSION < 3
+    if (var->type == &vt_FixedNationalChar
+            || var->type == &vt_NationalCharString)
+        return PyUnicode_Decode(data, var->actualLength[pos],
+                var->environment->nencoding, NULL);
+#endif
+    return cxString_FromEncodedString(data, var->actualLength[pos],
+            var->environment->encoding);
+}
+
+
+#if PY_MAJOR_VERSION < 3
+//-----------------------------------------------------------------------------
+// StringVar_PostDefine()
+//   Set the character set information when values are fetched from this
+// variable.
+//-----------------------------------------------------------------------------
+static int StringVar_PostDefine(
+    udt_StringVar *var)                 // variable to initialize
+{
+    sword status;
+
+    status = OCIAttrSet(var->defineHandle, OCI_HTYPE_DEFINE,
+            &var->type->charsetForm, 0, OCI_ATTR_CHARSET_FORM,
+            var->environment->errorHandle);
+    if (Environment_CheckForError(var->environment, status,
+            "StringVar_PostDefine(): setting charset form") < 0)
+        return -1;
+
+    return 0;
+}
+#endif
+
+
+//-----------------------------------------------------------------------------
+// StringVar_GetBufferSize()
+//   Returns the buffer size to use for the variable.
+//-----------------------------------------------------------------------------
+static ub4 StringVar_GetBufferSize(
+    udt_StringVar* self)                // variable to get buffer size for
+{
+    if (self->type->isCharacterData)
+        return self->size * self->environment->maxBytesPerCharacter;
+    return self->size;
+}
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/Subscription.c b/desktop/core/ext-py/cx_Oracle-5.1.2/Subscription.c
new file mode 100644
index 0000000..05f8385
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/Subscription.c
@@ -0,0 +1,873 @@
+//-----------------------------------------------------------------------------
+// Subscription.c
+//   Defines the routines for handling Oracle subscription information.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// structures used for handling subscriptions
+//-----------------------------------------------------------------------------
+typedef struct {
+    PyObject_HEAD
+    OCISubscription *handle;
+    udt_Connection *connection;
+    PyObject *callback;
+    ub4 namespace;
+    ub4 protocol;
+    ub4 port;
+    ub4 timeout;
+    ub4 operations;
+    ub4 rowids;
+} udt_Subscription;
+
+typedef struct {
+    PyObject_HEAD
+    ub4 type;
+    PyObject *dbname;
+    PyObject *tables;
+} udt_Message;
+
+typedef struct {
+    PyObject_HEAD
+    PyObject *name;
+    PyObject *rows;
+    ub4 operation;
+} udt_MessageTable;
+
+typedef struct {
+    PyObject_HEAD
+    PyObject *rowid;
+    ub4 operation;
+} udt_MessageRow;
+
+
+//-----------------------------------------------------------------------------
+// Declaration of subscription functions
+//-----------------------------------------------------------------------------
+static void Subscription_Free(udt_Subscription*);
+static PyObject *Subscription_Repr(udt_Subscription*);
+static PyObject *Subscription_RegisterQuery(udt_Subscription*, PyObject*);
+static void Message_Free(udt_Message*);
+static void MessageTable_Free(udt_MessageTable*);
+static void MessageRow_Free(udt_MessageRow*);
+
+//-----------------------------------------------------------------------------
+// declaration of members for Python types
+//-----------------------------------------------------------------------------
+static PyMemberDef g_SubscriptionTypeMembers[] = {
+    { "callback", T_OBJECT, offsetof(udt_Subscription, callback), READONLY },
+    { "connection", T_OBJECT, offsetof(udt_Subscription, connection),
+            READONLY },
+    { "namespace", T_INT, offsetof(udt_Subscription, namespace), READONLY },
+    { "protocol", T_INT, offsetof(udt_Subscription, protocol), READONLY },
+    { "port", T_INT, offsetof(udt_Subscription, port), READONLY },
+    { "timeout", T_INT, offsetof(udt_Subscription, timeout), READONLY },
+    { "operations", T_INT, offsetof(udt_Subscription, operations), READONLY },
+    { "rowids", T_BOOL, offsetof(udt_Subscription, rowids), READONLY },
+    { NULL }
+};
+
+static PyMemberDef g_MessageTypeMembers[] = {
+    { "type", T_INT, offsetof(udt_Message, type), READONLY },
+    { "dbname", T_OBJECT, offsetof(udt_Message, dbname), READONLY },
+    { "tables", T_OBJECT, offsetof(udt_Message, tables), READONLY },
+    { NULL }
+};
+
+static PyMemberDef g_MessageTableTypeMembers[] = {
+    { "name", T_OBJECT, offsetof(udt_MessageTable, name), READONLY },
+    { "rows", T_OBJECT, offsetof(udt_MessageTable, rows), READONLY },
+    { "operation", T_INT, offsetof(udt_MessageTable, operation), READONLY },
+    { NULL }
+};
+
+static PyMemberDef g_MessageRowTypeMembers[] = {
+    { "rowid", T_OBJECT, offsetof(udt_MessageRow, rowid), READONLY },
+    { "operation", T_INT, offsetof(udt_MessageRow, operation), READONLY },
+    { NULL }
+};
+
+
+//-----------------------------------------------------------------------------
+// declaration of methods for Python types
+//-----------------------------------------------------------------------------
+static PyMethodDef g_SubscriptionTypeMethods[] = {
+    { "registerquery", (PyCFunction) Subscription_RegisterQuery,
+            METH_VARARGS },
+    { NULL, NULL }
+};
+
+
+//-----------------------------------------------------------------------------
+// Python type declarations
+//-----------------------------------------------------------------------------
+static PyTypeObject g_SubscriptionType = {
+    PyVarObject_HEAD_INIT(NULL, 0)
+    "cx_Oracle.Subscription",           // tp_name
+    sizeof(udt_Subscription),           // tp_basicsize
+    0,                                  // tp_itemsize
+    (destructor) Subscription_Free,     // tp_dealloc
+    0,                                  // tp_print
+    0,                                  // tp_getattr
+    0,                                  // tp_setattr
+    0,                                  // tp_compare
+    (reprfunc) Subscription_Repr,       // tp_repr
+    0,                                  // tp_as_number
+    0,                                  // tp_as_sequence
+    0,                                  // tp_as_mapping
+    0,                                  // tp_hash
+    0,                                  // tp_call
+    0,                                  // tp_str
+    0,                                  // tp_getattro
+    0,                                  // tp_setattro
+    0,                                  // tp_as_buffer
+    Py_TPFLAGS_DEFAULT,                 // tp_flags
+    0,                                  // tp_doc
+    0,                                  // tp_traverse
+    0,                                  // tp_clear
+    0,                                  // tp_richcompare
+    0,                                  // tp_weaklistoffset
+    0,                                  // tp_iter
+    0,                                  // tp_iternext
+    g_SubscriptionTypeMethods,          // tp_methods
+    g_SubscriptionTypeMembers,          // tp_members
+    0,                                  // tp_getset
+    0,                                  // tp_base
+    0,                                  // tp_dict
+    0,                                  // tp_descr_get
+    0,                                  // tp_descr_set
+    0,                                  // tp_dictoffset
+    0,                                  // tp_init
+    0,                                  // tp_alloc
+    0,                                  // tp_new
+    0,                                  // tp_free
+    0,                                  // tp_is_gc
+    0                                   // tp_bases
+};
+
+static PyTypeObject g_MessageType = {
+    PyVarObject_HEAD_INIT(NULL, 0)
+    "cx_Oracle.Message",                // tp_name
+    sizeof(udt_Message),                // tp_basicsize
+    0,                                  // tp_itemsize
+    (destructor) Message_Free,          // tp_dealloc
+    0,                                  // tp_print
+    0,                                  // tp_getattr
+    0,                                  // tp_setattr
+    0,                                  // tp_compare
+    0,                                  // tp_repr
+    0,                                  // tp_as_number
+    0,                                  // tp_as_sequence
+    0,                                  // tp_as_mapping
+    0,                                  // tp_hash
+    0,                                  // tp_call
+    0,                                  // tp_str
+    0,                                  // tp_getattro
+    0,                                  // tp_setattro
+    0,                                  // tp_as_buffer
+    Py_TPFLAGS_DEFAULT,                 // tp_flags
+    0,                                  // tp_doc
+    0,                                  // tp_traverse
+    0,                                  // tp_clear
+    0,                                  // tp_richcompare
+    0,                                  // tp_weaklistoffset
+    0,                                  // tp_iter
+    0,                                  // tp_iternext
+    0,                                  // tp_methods
+    g_MessageTypeMembers,               // tp_members
+    0,                                  // tp_getset
+    0,                                  // tp_base
+    0,                                  // tp_dict
+    0,                                  // tp_descr_get
+    0,                                  // tp_descr_set
+    0,                                  // tp_dictoffset
+    0,                                  // tp_init
+    0,                                  // tp_alloc
+    0,                                  // tp_new
+    0,                                  // tp_free
+    0,                                  // tp_is_gc
+    0                                   // tp_bases
+};
+
+static PyTypeObject g_MessageTableType = {
+    PyVarObject_HEAD_INIT(NULL, 0)
+    "cx_Oracle.MessageTable",           // tp_name
+    sizeof(udt_MessageTable),           // tp_basicsize
+    0,                                  // tp_itemsize
+    (destructor) MessageTable_Free,     // tp_dealloc
+    0,                                  // tp_print
+    0,                                  // tp_getattr
+    0,                                  // tp_setattr
+    0,                                  // tp_compare
+    0,                                  // tp_repr
+    0,                                  // tp_as_number
+    0,                                  // tp_as_sequence
+    0,                                  // tp_as_mapping
+    0,                                  // tp_hash
+    0,                                  // tp_call
+    0,                                  // tp_str
+    0,                                  // tp_getattro
+    0,                                  // tp_setattro
+    0,                                  // tp_as_buffer
+    Py_TPFLAGS_DEFAULT,                 // tp_flags
+    0,                                  // tp_doc
+    0,                                  // tp_traverse
+    0,                                  // tp_clear
+    0,                                  // tp_richcompare
+    0,                                  // tp_weaklistoffset
+    0,                                  // tp_iter
+    0,                                  // tp_iternext
+    0,                                  // tp_methods
+    g_MessageTableTypeMembers,          // tp_members
+    0,                                  // tp_getset
+    0,                                  // tp_base
+    0,                                  // tp_dict
+    0,                                  // tp_descr_get
+    0,                                  // tp_descr_set
+    0,                                  // tp_dictoffset
+    0,                                  // tp_init
+    0,                                  // tp_alloc
+    0,                                  // tp_new
+    0,                                  // tp_free
+    0,                                  // tp_is_gc
+    0                                   // tp_bases
+};
+
+
+static PyTypeObject g_MessageRowType = {
+    PyVarObject_HEAD_INIT(NULL, 0)
+    "cx_Oracle.MessageRow",             // tp_name
+    sizeof(udt_MessageRow),             // tp_basicsize
+    0,                                  // tp_itemsize
+    (destructor) MessageRow_Free,       // tp_dealloc
+    0,                                  // tp_print
+    0,                                  // tp_getattr
+    0,                                  // tp_setattr
+    0,                                  // tp_compare
+    0,                                  // tp_repr
+    0,                                  // tp_as_number
+    0,                                  // tp_as_sequence
+    0,                                  // tp_as_mapping
+    0,                                  // tp_hash
+    0,                                  // tp_call
+    0,                                  // tp_str
+    0,                                  // tp_getattro
+    0,                                  // tp_setattro
+    0,                                  // tp_as_buffer
+    Py_TPFLAGS_DEFAULT,                 // tp_flags
+    0,                                  // tp_doc
+    0,                                  // tp_traverse
+    0,                                  // tp_clear
+    0,                                  // tp_richcompare
+    0,                                  // tp_weaklistoffset
+    0,                                  // tp_iter
+    0,                                  // tp_iternext
+    0,                                  // tp_methods
+    g_MessageRowTypeMembers,            // tp_members
+    0,                                  // tp_getset
+    0,                                  // tp_base
+    0,                                  // tp_dict
+    0,                                  // tp_descr_get
+    0,                                  // tp_descr_set
+    0,                                  // tp_dictoffset
+    0,                                  // tp_init
+    0,                                  // tp_alloc
+    0,                                  // tp_new
+    0,                                  // tp_free
+    0,                                  // tp_is_gc
+    0                                   // tp_bases
+};
+
+
+//-----------------------------------------------------------------------------
+// MessageRow_Initialize()
+//   Initialize a new message row with the information from the descriptor.
+//-----------------------------------------------------------------------------
+static int MessageRow_Initialize(
+    udt_MessageRow *self,               // object to initialize
+    udt_Environment *env,               // environment to use
+    dvoid *descriptor)                  // descriptor to get information from
+{
+    ub4 rowidLength;
+    sword status;
+    char *rowid;
+
+    // determine operation
+    status = OCIAttrGet(descriptor, OCI_DTYPE_ROW_CHDES, &self->operation,
+            NULL, OCI_ATTR_CHDES_ROW_OPFLAGS, env->errorHandle);
+    if (Environment_CheckForError(env, status,
+            "MessageRow_Initialize(): get operation") < 0)
+        return -1;
+
+    // determine table name
+    status = OCIAttrGet(descriptor, OCI_DTYPE_ROW_CHDES, &rowid, &rowidLength,
+            OCI_ATTR_CHDES_ROW_ROWID, env->errorHandle);
+    if (Environment_CheckForError(env, status,
+            "MessageRow_Initialize(): get rowid") < 0)
+        return -1;
+    self->rowid = cxString_FromEncodedString(rowid, rowidLength,
+            env->encoding);
+    if (!self->rowid)
+        return -1;
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// MessageTable_Initialize()
+//   Initialize a new message table with the information from the descriptor.
+//-----------------------------------------------------------------------------
+static int MessageTable_Initialize(
+    udt_MessageTable *self,             // object to initialize
+    udt_Environment *env,               // environment to use
+    dvoid *descriptor)                  // descriptor to get information from
+{
+    dvoid **rowDescriptor, *indicator;
+    ub4 nameLength, i;
+    udt_MessageRow *row;
+    boolean exists;
+    OCIColl *rows;
+    sword status;
+    sb4 numRows;
+    char *name;
+
+    // determine operation
+    status = OCIAttrGet(descriptor, OCI_DTYPE_TABLE_CHDES, &self->operation,
+            NULL, OCI_ATTR_CHDES_TABLE_OPFLAGS, env->errorHandle);
+    if (Environment_CheckForError(env, status,
+            "MessageTable_Initialize(): get operation") < 0)
+        return -1;
+
+    // determine table name
+    status = OCIAttrGet(descriptor, OCI_DTYPE_TABLE_CHDES, &name, &nameLength,
+            OCI_ATTR_CHDES_TABLE_NAME, env->errorHandle);
+    if (Environment_CheckForError(env, status,
+            "MessageTable_Initialize(): get table name") < 0)
+        return -1;
+    self->name = cxString_FromEncodedString(name, nameLength, env->encoding);
+    if (!self->name)
+        return -1;
+
+    // if change invalidated all rows, nothing to do
+    if (self->operation & OCI_OPCODE_ALLROWS)
+        return 0;
+
+    // determine rows collection
+    status = OCIAttrGet(descriptor, OCI_DTYPE_TABLE_CHDES, &rows, NULL,
+            OCI_ATTR_CHDES_TABLE_ROW_CHANGES, env->errorHandle);
+    if (Environment_CheckForError(env, status,
+            "MessageTable_Initialize(): get rows collection") < 0)
+        return -1;
+
+    // determine number of rows in collection
+    status = OCICollSize(env->handle, env->errorHandle, rows, &numRows);
+    if (Environment_CheckForError(env, status,
+            "MessageTable_Initialize(): get size of rows collection") < 0)
+        return -1;
+
+    // populate the rows attribute
+    self->rows = PyList_New(numRows);
+    if (!self->rows)
+        return -1;
+    for (i = 0; i < numRows; i++) {
+        status = OCICollGetElem(env->handle, env->errorHandle, rows, i,
+                &exists, (dvoid*) &rowDescriptor, &indicator);
+        if (Environment_CheckForError(env, status,
+                "MessageTable_Initialize(): get element from collection") < 0)
+            return -1;
+        row = (udt_MessageRow*)
+                g_MessageRowType.tp_alloc(&g_MessageRowType, 0);
+        if (!row)
+            return -1;
+        PyList_SET_ITEM(self->rows, i, (PyObject*) row);
+        if (MessageRow_Initialize(row, env, *rowDescriptor) < 0)
+            return -1;
+    }
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// Message_Initialize()
+//   Initialize a new message with the information from the descriptor.
+//-----------------------------------------------------------------------------
+static int Message_Initialize(
+    udt_Message *self,                  // object to initialize
+    udt_Environment *env,               // environment to use
+    dvoid *descriptor)                  // descriptor to get information from
+{
+    dvoid **tableDescriptor, *indicator;
+    udt_MessageTable *table;
+    ub4 dbnameLength, i;
+    OCIColl *tables;
+    boolean exists;
+    sb4 numTables;
+    char *dbname;
+    sword status;
+
+    // determine type
+    status = OCIAttrGet(descriptor, OCI_DTYPE_CHDES, &self->type, NULL,
+            OCI_ATTR_CHDES_NFYTYPE, env->errorHandle);
+    if (Environment_CheckForError(env, status,
+            "Message_Initialize(): get type") < 0)
+        return -1;
+
+    // determine database name
+    status = OCIAttrGet(descriptor, OCI_DTYPE_CHDES, &dbname, &dbnameLength,
+            OCI_ATTR_CHDES_DBNAME, env->errorHandle);
+    if (Environment_CheckForError(env, status,
+            "Message_Initialize(): get database name") < 0)
+        return -1;
+    self->dbname = cxString_FromEncodedString(dbname, dbnameLength,
+            env->encoding);
+    if (!self->dbname)
+        return -1;
+
+    // determine table collection
+    status = OCIAttrGet(descriptor, OCI_DTYPE_CHDES, &tables, NULL,
+            OCI_ATTR_CHDES_TABLE_CHANGES, env->errorHandle);
+    if (Environment_CheckForError(env, status,
+            "Message_Initialize(): get tables collection") < 0)
+        return -1;
+
+    // determine number of tables
+    if (!tables)
+        numTables = 0;
+    else {
+        status = OCICollSize(env->handle, env->errorHandle, tables,
+                &numTables);
+        if (Environment_CheckForError(env, status,
+                "Message_Initialize(): get size of collection") < 0)
+            return -1;
+    }
+
+    // create list to hold results
+    self->tables = PyList_New(numTables);
+    if (!self->tables)
+        return -1;
+
+    // populate each entry with a message table instance
+    for (i = 0; i < numTables; i++) {
+        status = OCICollGetElem(env->handle, env->errorHandle, tables, i,
+                &exists, (dvoid*) &tableDescriptor, &indicator);
+        if (Environment_CheckForError(env, status,
+                "Message_Initialize(): get element from collection") < 0)
+            return -1;
+        table = (udt_MessageTable*)
+                g_MessageTableType.tp_alloc(&g_MessageTableType, 0);
+        if (!table)
+            return -1;
+        PyList_SET_ITEM(self->tables, i, (PyObject*) table);
+        if (MessageTable_Initialize(table, env, *tableDescriptor) < 0)
+            return -1;
+    }
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// Subscription_CallbackHandler()
+//   Routine that performs the actual call.
+//-----------------------------------------------------------------------------
+static int Subscription_CallbackHandler(
+    udt_Subscription *self,             // subscription object
+    udt_Environment *env,               // environment to use
+    dvoid *descriptor)                  // descriptor to get information from
+{
+    PyObject *result, *args;
+    udt_Message *message;
+
+    // create the message
+    message = (udt_Message*) g_MessageType.tp_alloc(&g_MessageType, 0);
+    if (!message)
+        return -1;
+    if (Message_Initialize(message, env, descriptor) < 0) {
+        Py_DECREF(message);
+        return -1;
+    }
+
+    // create the arguments for the call
+    args = PyTuple_Pack(1, message);
+    Py_DECREF(message);
+    if (!args)
+        return -1;
+
+    // make the actual call
+    result = PyObject_Call(self->callback, args, NULL);
+    Py_DECREF(args);
+    if (!result)
+        return -1;
+    Py_DECREF(result);
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// Subscription_Callback()
+//   Routine that is called when a callback needs to be invoked.
+//-----------------------------------------------------------------------------
+static void Subscription_Callback(
+    udt_Subscription *self,             // subscription object
+    OCISubscription *handle,            // subscription handle
+    dvoid *payload,                     // payload
+    ub4 *payloadLength,                 // payload length
+    dvoid *descriptor,                  // descriptor
+    ub4 mode)                           // mode used
+{
+#ifdef WITH_THREAD
+    PyGILState_STATE gstate = PyGILState_Ensure();
+#endif
+    udt_Environment *env;
+
+    // perform the call
+    env = Environment_NewFromScratch(0, 0, NULL, NULL);
+    if (!env)
+        PyErr_Print();
+    else {
+        if (Subscription_CallbackHandler(self, env, descriptor) < 0)
+            PyErr_Print();
+        Py_DECREF(env);
+    }
+
+    // restore thread state, if necessary
+#ifdef WITH_THREAD
+    PyGILState_Release(gstate);
+#endif
+}
+
+
+//-----------------------------------------------------------------------------
+// Subscription_Register()
+//   Register the subscription.
+//-----------------------------------------------------------------------------
+static int Subscription_Register(
+    udt_Subscription *self)             // subscription to register
+{
+    udt_Environment *env;
+    sword status;
+
+    // create the subscription handle
+    env = self->connection->environment;
+    status = OCIHandleAlloc(env->handle, (dvoid**) &self->handle,
+            OCI_HTYPE_SUBSCRIPTION, 0, 0);
+    if (Environment_CheckForError(env, status,
+            "Subscription_Register(): allocate handle") < 0)
+        return -1;
+
+    // set the namespace
+    status = OCIAttrSet(self->handle, OCI_HTYPE_SUBSCRIPTION,
+            (dvoid*) &self->namespace, sizeof(ub4), OCI_ATTR_SUBSCR_NAMESPACE,
+            env->errorHandle);
+    if (Environment_CheckForError(env, status,
+            "Subscription_Register(): set namespace") < 0)
+        return -1;
+
+    // set the protocol
+    status = OCIAttrSet(self->handle, OCI_HTYPE_SUBSCRIPTION,
+            (dvoid*) &self->protocol, sizeof(ub4), OCI_ATTR_SUBSCR_RECPTPROTO,
+            env->errorHandle);
+    if (Environment_CheckForError(env, status,
+            "Subscription_Register(): set protocol") < 0)
+        return -1;
+
+    // set the timeout
+    status = OCIAttrSet(self->handle, OCI_HTYPE_SUBSCRIPTION,
+            (dvoid*) &self->timeout, sizeof(ub4), OCI_ATTR_SUBSCR_TIMEOUT,
+            env->errorHandle);
+    if (Environment_CheckForError(env, status,
+            "Subscription_Register(): set timeout") < 0)
+        return -1;
+
+    // set the TCP port used on client to listen for callback from DB server
+    if (self->port > 0) {
+        status = OCIAttrSet(env->handle, OCI_HTYPE_ENV,
+                (dvoid*) &(self->port), (ub4) 0, OCI_ATTR_SUBSCR_PORTNO,
+                env->errorHandle);
+        if (Environment_CheckForError(env, status,
+                "Subscription_Register(): set port") < 0)
+            return -1;
+    }
+
+    // set the context for the callback
+    status = OCIAttrSet(self->handle, OCI_HTYPE_SUBSCRIPTION,
+            (dvoid*) self, 0, OCI_ATTR_SUBSCR_CTX, env->errorHandle);
+    if (Environment_CheckForError(env, status,
+                "Subscription_Register(): set context") < 0)
+        return -1;
+
+    // set the callback, if applicable
+    if (self->callback) {
+        status = OCIAttrSet(self->handle, OCI_HTYPE_SUBSCRIPTION,
+                (dvoid*) Subscription_Callback, 0, OCI_ATTR_SUBSCR_CALLBACK,
+                env->errorHandle);
+        if (Environment_CheckForError(env, status,
+                    "Subscription_Register(): set callback") < 0)
+            return -1;
+    }
+
+    // set whether or not rowids are desired
+    status = OCIAttrSet(self->handle, OCI_HTYPE_SUBSCRIPTION,
+            (dvoid*) &self->rowids, sizeof(ub4), OCI_ATTR_CHNF_ROWIDS,
+            env->errorHandle);
+    if (Environment_CheckForError(env, status,
+                "Subscription_Register(): set rowids") < 0)
+        return -1;
+
+    // set which operations are desired
+    status = OCIAttrSet(self->handle, OCI_HTYPE_SUBSCRIPTION,
+            (dvoid*) &self->operations, sizeof(ub4), OCI_ATTR_CHNF_OPERATIONS,
+            env->errorHandle);
+    if (Environment_CheckForError(env, status,
+                "Subscription_Register(): set operations") < 0)
+        return -1;
+
+    // register the subscription
+    Py_BEGIN_ALLOW_THREADS
+    status = OCISubscriptionRegister(self->connection->handle,
+            &self->handle, 1, env->errorHandle, OCI_DEFAULT);
+    Py_END_ALLOW_THREADS
+    if (Environment_CheckForError(env, status,
+                "Subscription_Register(): register") < 0)
+        return -1;
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// Subscription_New()
+//   Allocate a new subscription object.
+//-----------------------------------------------------------------------------
+static udt_Subscription *Subscription_New(
+    udt_Connection *connection,         // connection object
+    ub4 namespace,                      // namespace to use
+    ub4 protocol,                       // protocol to use
+    ub4 port,                           // client port for callbacks
+    PyObject *callback,                 // callback routine
+    ub4 timeout,                        // timeout (in seconds)
+    ub4 operations,                     // operations to notify
+    int rowids)                         // retrieve rowids?
+{
+    udt_Subscription *self;
+
+    self = (udt_Subscription*)
+            g_SubscriptionType.tp_alloc(&g_SubscriptionType, 0);
+    if (!self)
+        return NULL;
+    Py_INCREF(connection);
+    self->connection = connection;
+    Py_XINCREF(callback);
+    self->callback = callback;
+    self->namespace = namespace;
+    self->protocol = protocol;
+    self->port = port;
+    self->timeout = timeout;
+    self->rowids = rowids;
+    self->operations = operations;
+    self->handle = NULL;
+    if (Subscription_Register(self) < 0) {
+        Py_DECREF(self);
+        return NULL;
+    }
+
+    return self;
+}
+
+
+//-----------------------------------------------------------------------------
+// Subscription_Free()
+//   Free the memory associated with a subscription.
+//-----------------------------------------------------------------------------
+static void Subscription_Free(
+    udt_Subscription *self)               // subscription to free
+{
+    if (self->handle)
+        OCISubscriptionUnRegister(self->connection->handle,
+                self->handle, self->connection->environment->errorHandle,
+                OCI_DEFAULT);
+    Py_CLEAR(self->connection);
+    Py_CLEAR(self->callback);
+    Py_TYPE(self)->tp_free((PyObject*) self);
+}
+
+
+//-----------------------------------------------------------------------------
+// Subscription_Repr()
+//   Return a string representation of the subscription.
+//-----------------------------------------------------------------------------
+static PyObject *Subscription_Repr(
+    udt_Subscription *subscription)     // subscription to repr
+{
+    PyObject *connectionRepr, *module, *name, *result, *format, *formatArgs;
+
+    format = cxString_FromAscii("<%s.%s on %s>");
+    if (!format)
+        return NULL;
+    connectionRepr = PyObject_Repr((PyObject*) subscription->connection);
+    if (!connectionRepr) {
+        Py_DECREF(format);
+        return NULL;
+    }
+    if (GetModuleAndName(Py_TYPE(subscription), &module, &name) < 0) {
+        Py_DECREF(format);
+        Py_DECREF(connectionRepr);
+        return NULL;
+    }
+    formatArgs = PyTuple_Pack(3, module, name, connectionRepr);
+    Py_DECREF(module);
+    Py_DECREF(name);
+    Py_DECREF(connectionRepr);
+    if (!formatArgs) {
+        Py_DECREF(format);
+        return NULL;
+    }
+    result = cxString_Format(format, formatArgs);
+    Py_DECREF(format);
+    Py_DECREF(formatArgs);
+    return result;
+}
+
+
+//-----------------------------------------------------------------------------
+// Subscription_RegisterQuery()
+//   Register a query for database change notification.
+//-----------------------------------------------------------------------------
+static PyObject *Subscription_RegisterQuery(
+    udt_Subscription *self,             // subscription to use
+    PyObject *args)                     // arguments
+{
+    PyObject *statement, *executeArgs;
+    udt_Buffer statementBuffer;
+    udt_Environment *env;
+    udt_Cursor *cursor;
+    sword status;
+
+    // parse arguments
+    executeArgs = NULL;
+    if (!PyArg_ParseTuple(args, "O!|O", cxString_Type, &statement,
+            &executeArgs))
+        return NULL;
+    if (executeArgs) {
+        if (!PyDict_Check(executeArgs) && !PySequence_Check(executeArgs)) {
+            PyErr_SetString(PyExc_TypeError,
+                    "expecting a dictionary or sequence");
+            return NULL;
+        }
+    }
+
+    // create cursor to perform query
+    env = self->connection->environment;
+    cursor = (udt_Cursor*) Connection_NewCursor(self->connection, NULL);
+    if (!cursor)
+        return NULL;
+
+    // allocate the handle so the subscription handle can be set
+    if (Cursor_AllocateHandle(cursor) < 0) {
+        Py_DECREF(cursor);
+        return NULL;
+    }
+
+    // prepare the statement for execution
+    if (cxBuffer_FromObject(&statementBuffer, statement,
+            env->encoding) < 0) {
+        Py_DECREF(cursor);
+        return NULL;
+    }
+    status = OCIStmtPrepare(cursor->handle, env->errorHandle,
+            (text*) statementBuffer.ptr, statementBuffer.size, OCI_NTV_SYNTAX,
+            OCI_DEFAULT);
+    cxBuffer_Clear(&statementBuffer);
+    if (Environment_CheckForError(env, status,
+            "Subscription_RegisterQuery(): prepare statement") < 0) {
+        Py_DECREF(cursor);
+        return NULL;
+    }
+
+    // perform binds
+    if (executeArgs && Cursor_SetBindVariables(cursor, executeArgs, 1, 0,
+            0) < 0) {
+        Py_DECREF(cursor);
+        return NULL;
+    }
+    if (Cursor_PerformBind(cursor) < 0) {
+        Py_DECREF(cursor);
+        return NULL;
+    }
+
+    // parse the query in order to get the defined variables
+    Py_BEGIN_ALLOW_THREADS
+    status = OCIStmtExecute(self->connection->handle, cursor->handle,
+            env->errorHandle, 0, 0, 0, 0, OCI_DESCRIBE_ONLY);
+    Py_END_ALLOW_THREADS
+    if (Environment_CheckForError(env, status,
+            "Subscription_RegisterQuery(): parse statement") < 0) {
+        Py_DECREF(cursor);
+        return NULL;
+    }
+
+    // perform define as needed
+    if (Cursor_PerformDefine(cursor) < 0) {
+        Py_DECREF(cursor);
+        return NULL;
+    }
+
+    // set the subscription handle
+    status = OCIAttrSet(cursor->handle, OCI_HTYPE_STMT, self->handle, 0,
+            OCI_ATTR_CHNF_REGHANDLE, env->errorHandle);
+    if (Environment_CheckForError(env, status,
+                "Subscription_RegisterQuery(): set subscription handle") < 0) {
+        Py_DECREF(cursor);
+        return NULL;
+    }
+
+    // execute the query which registers it
+    if (Cursor_InternalExecute(cursor, 0) < 0) {
+        Py_DECREF(cursor);
+        return NULL;
+    }
+    Py_DECREF(cursor);
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+
+//-----------------------------------------------------------------------------
+// Message_Free()
+//   Free the memory associated with a message.
+//-----------------------------------------------------------------------------
+static void Message_Free(
+    udt_Message *self)                  // object to free
+{
+    Py_CLEAR(self->dbname);
+    Py_CLEAR(self->tables);
+    Py_TYPE(self)->tp_free((PyObject*) self);
+}
+
+
+//-----------------------------------------------------------------------------
+// MessageTable_Free()
+//   Free the memory associated with a table in a message.
+//-----------------------------------------------------------------------------
+static void MessageTable_Free(
+    udt_MessageTable *self)             // object to free
+{
+    Py_CLEAR(self->name);
+    Py_TYPE(self)->tp_free((PyObject*) self);
+}
+
+
+//-----------------------------------------------------------------------------
+// MessageRow_Free()
+//   Free the memory associated with a row in a message.
+//-----------------------------------------------------------------------------
+static void MessageRow_Free(
+    udt_MessageRow *self)               // object to free
+{
+    Py_CLEAR(self->rowid);
+    Py_TYPE(self)->tp_free((PyObject*) self);
+}
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/TimestampVar.c b/desktop/core/ext-py/cx_Oracle-5.1.2/TimestampVar.c
new file mode 100644
index 0000000..de625ec
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/TimestampVar.c
@@ -0,0 +1,171 @@
+//-----------------------------------------------------------------------------
+// TimestampVar.c
+//   Defines the routines for handling timestamp variables.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// Timestamp type
+//-----------------------------------------------------------------------------
+typedef struct {
+    Variable_HEAD
+    OCIDateTime **data;
+} udt_TimestampVar;
+
+
+//-----------------------------------------------------------------------------
+// Declaration of date/time variable functions.
+//-----------------------------------------------------------------------------
+static int TimestampVar_Initialize(udt_TimestampVar*, udt_Cursor*);
+static void TimestampVar_Finalize(udt_TimestampVar*);
+static int TimestampVar_SetValue(udt_TimestampVar*, unsigned, PyObject*);
+static PyObject *TimestampVar_GetValue(udt_TimestampVar*, unsigned);
+
+
+//-----------------------------------------------------------------------------
+// Python type declarations
+//-----------------------------------------------------------------------------
+static PyTypeObject g_TimestampVarType = {
+    PyVarObject_HEAD_INIT(NULL, 0)
+    "cx_Oracle.TIMESTAMP",              // tp_name
+    sizeof(udt_TimestampVar),           // tp_basicsize
+    0,                                  // tp_itemsize
+    0,                                  // tp_dealloc
+    0,                                  // tp_print
+    0,                                  // tp_getattr
+    0,                                  // tp_setattr
+    0,                                  // tp_compare
+    0,                                  // tp_repr
+    0,                                  // tp_as_number
+    0,                                  // tp_as_sequence
+    0,                                  // tp_as_mapping
+    0,                                  // tp_hash
+    0,                                  // tp_call
+    0,                                  // tp_str
+    0,                                  // tp_getattro
+    0,                                  // tp_setattro
+    0,                                  // tp_as_buffer
+    Py_TPFLAGS_DEFAULT,                 // tp_flags
+    0                                   // tp_doc
+};
+
+
+//-----------------------------------------------------------------------------
+// variable type declarations
+//-----------------------------------------------------------------------------
+static udt_VariableType vt_Timestamp = {
+    (InitializeProc) TimestampVar_Initialize,
+    (FinalizeProc) TimestampVar_Finalize,
+    (PreDefineProc) NULL,
+    (PostDefineProc) NULL,
+    (PreFetchProc) NULL,
+    (IsNullProc) NULL,
+    (SetValueProc) TimestampVar_SetValue,
+    (GetValueProc) TimestampVar_GetValue,
+    (GetBufferSizeProc) NULL,
+    &g_TimestampVarType,                // Python type
+    SQLT_TIMESTAMP,                     // Oracle type
+    SQLCS_IMPLICIT,                     // charset form
+    sizeof(OCIDateTime*),               // element length (default)
+    0,                                  // is character data
+    0,                                  // is variable length
+    1,                                  // can be copied
+    1                                   // can be in array
+};
+
+
+//-----------------------------------------------------------------------------
+// TimestampVar_Initialize()
+//   Initialize the variable.
+//-----------------------------------------------------------------------------
+static int TimestampVar_Initialize(
+    udt_TimestampVar *var,              // variable to initialize
+    udt_Cursor *cursor)                 // cursor variable associated with
+{
+    sword status;
+    ub4 i;
+
+    // initialize the LOB locators
+    for (i = 0; i < var->allocatedElements; i++) {
+        status = OCIDescriptorAlloc(var->environment->handle,
+                (dvoid**) &var->data[i], OCI_DTYPE_TIMESTAMP, 0, 0);
+        if (Environment_CheckForError(var->environment, status,
+                "TimestampVar_Initialize()") < 0)
+            return -1;
+    }
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// TimestampVar_Finalize()
+//   Prepare for variable destruction.
+//-----------------------------------------------------------------------------
+static void TimestampVar_Finalize(
+    udt_TimestampVar *var)              // variable to free
+{
+    ub4 i;
+
+    for (i = 0; i < var->allocatedElements; i++) {
+        if (var->data[i])
+            OCIDescriptorFree(var->data[i], OCI_DTYPE_TIMESTAMP);
+    }
+}
+
+
+//-----------------------------------------------------------------------------
+// TimestampVar_SetValue()
+//   Set the value of the variable.
+//-----------------------------------------------------------------------------
+static int TimestampVar_SetValue(
+    udt_TimestampVar *var,              // variable to set value for
+    unsigned pos,                       // array position to set
+    PyObject *value)                    // value to set
+{
+    sword status;
+    uword valid;
+
+    // make sure a timestamp is being bound
+    if (!PyDateTime_Check(value)) {
+        PyErr_SetString(PyExc_TypeError, "expecting timestamp data");
+        return -1;
+    }
+
+    // store a copy of the value
+    status = OCIDateTimeConstruct(var->environment->handle,
+            var->environment->errorHandle, var->data[pos],
+            (sb2) PyDateTime_GET_YEAR(value),
+            PyDateTime_GET_MONTH(value),
+            PyDateTime_GET_DAY(value),
+            PyDateTime_DATE_GET_HOUR(value),
+            PyDateTime_DATE_GET_MINUTE(value),
+            PyDateTime_DATE_GET_SECOND(value),
+            PyDateTime_DATE_GET_MICROSECOND(value) * 1000, NULL, 0);
+    if (Environment_CheckForError(var->environment, status,
+            "TimestampVar_SetValue(): create structure") < 0)
+        return -1;
+    status = OCIDateTimeCheck(var->environment->handle,
+            var->environment->errorHandle, var->data[pos], &valid);
+    if (Environment_CheckForError(var->environment, status,
+            "TimestampVar_SetValue()") < 0)
+        return -1;
+    if (valid != 0) {
+        PyErr_SetString(g_DataErrorException, "invalid date");
+        return -1;
+    }
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// TimestampVar_GetValue()
+//   Returns the value stored at the given array position.
+//-----------------------------------------------------------------------------
+static PyObject *TimestampVar_GetValue(
+    udt_TimestampVar *var,              // variable to determine value for
+    unsigned pos)                       // array position
+{
+    return OracleTimestampToPythonDate(var->environment, var->data[pos]);
+}
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/Transforms.c b/desktop/core/ext-py/cx_Oracle-5.1.2/Transforms.c
new file mode 100644
index 0000000..8410492
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/Transforms.c
@@ -0,0 +1,98 @@
+//-----------------------------------------------------------------------------
+// Transforms.c
+//   Provides methods for transforming Oracle data to Python objects or for
+// setting Oracle data from Python objects.
+//-----------------------------------------------------------------------------
+
+static udt_VariableType vt_Date;
+
+//-----------------------------------------------------------------------------
+// OracleDateToPythonDate()
+//   Return a Python date object given an Oracle date.
+//-----------------------------------------------------------------------------
+static PyObject *OracleDateToPythonDate(
+    udt_VariableType *varType,          // variable type
+    OCIDate* value)                     // value to convert
+{
+    ub1 hour, minute, second, month, day;
+    sb2 year;
+
+    OCIDateGetDate(value, &year, &month, &day);
+    OCIDateGetTime(value, &hour, &minute, &second);
+
+    if (varType == &vt_Date)
+        return PyDate_FromDate(year, month, day);
+    return PyDateTime_FromDateAndTime(year, month, day, hour, minute, second,
+            0);
+}
+
+
+//-----------------------------------------------------------------------------
+// OracleIntervalToPythonDelta()
+//   Return a Python delta object given an Oracle interval.
+//-----------------------------------------------------------------------------
+static PyObject *OracleIntervalToPythonDelta(
+    udt_Environment *environment,       // environment
+    OCIInterval *value)                 // value to convert
+{
+    sb4 days, hours, minutes, seconds, fseconds;
+    sword status;
+
+    status = OCIIntervalGetDaySecond(environment->handle,
+            environment->errorHandle, &days, &hours, &minutes, &seconds,
+            &fseconds, value);
+    if (Environment_CheckForError(environment, status,
+            "OracleIntervalToPythonDelta()") < 0)
+        return NULL;
+    seconds = hours * 60 * 60 + minutes * 60 + seconds;
+    return PyDelta_FromDSU(days, seconds, fseconds / 1000);
+}
+
+
+//-----------------------------------------------------------------------------
+// OracleTimestampToPythonDate()
+//   Return a Python date object given an Oracle timestamp.
+//-----------------------------------------------------------------------------
+static PyObject *OracleTimestampToPythonDate(
+    udt_Environment *environment,       // environment
+    OCIDateTime* value)                 // value to convert
+{
+    ub1 hour, minute, second, month, day;
+    sword status;
+    ub4 fsecond;
+    sb2 year;
+
+    status = OCIDateTimeGetDate(environment->handle, environment->errorHandle,
+            value, &year, &month, &day);
+    if (Environment_CheckForError(environment, status,
+            "OracleTimestampToPythonDate(): date portion") < 0)
+        return NULL;
+    status = OCIDateTimeGetTime(environment->handle, environment->errorHandle,
+            value, &hour, &minute, &second, &fsecond);
+    if (Environment_CheckForError(environment, status,
+            "OracleTimestampToPythonDate(): time portion") < 0)
+        return NULL;
+    return PyDateTime_FromDateAndTime(year, month, day, hour, minute, second,
+            fsecond / 1000);
+}
+
+
+//-----------------------------------------------------------------------------
+// OracleNumberToPythonFloat()
+//   Return a Python date object given an Oracle date.
+//-----------------------------------------------------------------------------
+static PyObject *OracleNumberToPythonFloat(
+    udt_Environment *environment,       // environment
+    OCINumber* value)                   // value to convert
+{
+    double doubleValue;
+    sword status;
+
+    status = OCINumberToReal(environment->errorHandle,
+            value, sizeof(double), (dvoid*) &doubleValue);
+    if (Environment_CheckForError(environment, status,
+            "OracleNumberToPythonFloat()") < 0)
+        return NULL;
+    return PyFloat_FromDouble(doubleValue);
+}
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/Variable.c b/desktop/core/ext-py/cx_Oracle-5.1.2/Variable.c
new file mode 100644
index 0000000..49632d5
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/Variable.c
@@ -0,0 +1,1524 @@
+//-----------------------------------------------------------------------------
+// Variable.c
+//   Defines Python types for Oracle variables.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// define structure common to all variables
+//-----------------------------------------------------------------------------
+struct _udt_VariableType;
+#define Variable_HEAD \
+    PyObject_HEAD \
+    OCIBind *bindHandle; \
+    OCIDefine *defineHandle; \
+    OCIStmt *boundCursorHandle; \
+    PyObject *boundName; \
+    PyObject *inConverter; \
+    PyObject *outConverter; \
+    ub4 boundPos; \
+    udt_Environment *environment; \
+    ub4 allocatedElements; \
+    ub4 actualElements; \
+    unsigned internalFetchNum; \
+    int isArray; \
+    int isAllocatedInternally; \
+    sb2 *indicator; \
+    ub2 *returnCode; \
+    ub2 *actualLength; \
+    ub4 size; \
+    ub4 bufferSize; \
+    struct _udt_VariableType *type;
+typedef struct {
+    Variable_HEAD
+    void *data;
+} udt_Variable;
+
+
+//-----------------------------------------------------------------------------
+// define function types for the common actions that take place on a variable
+//-----------------------------------------------------------------------------
+typedef int (*InitializeProc)(udt_Variable*, udt_Cursor*);
+typedef void (*FinalizeProc)(udt_Variable*);
+typedef int (*PreDefineProc)(udt_Variable*, OCIParam*);
+typedef int (*PostDefineProc)(udt_Variable*);
+typedef int (*PreFetchProc)(udt_Variable*);
+typedef int (*IsNullProc)(udt_Variable*, unsigned);
+typedef int (*SetValueProc)(udt_Variable*, unsigned, PyObject*);
+typedef PyObject * (*GetValueProc)(udt_Variable*, unsigned);
+typedef ub4  (*GetBufferSizeProc)(udt_Variable*);
+
+
+//-----------------------------------------------------------------------------
+// define structure for the common actions that take place on a variable
+//-----------------------------------------------------------------------------
+typedef struct _udt_VariableType {
+    InitializeProc initializeProc;
+    FinalizeProc finalizeProc;
+    PreDefineProc preDefineProc;
+    PostDefineProc postDefineProc;
+    PreFetchProc preFetchProc;
+    IsNullProc isNullProc;
+    SetValueProc setValueProc;
+    GetValueProc getValueProc;
+    GetBufferSizeProc getBufferSizeProc;
+    PyTypeObject *pythonType;
+    ub2 oracleType;
+    ub1 charsetForm;
+    ub4 size;
+    int isCharacterData;
+    int isVariableLength;
+    int canBeCopied;
+    int canBeInArray;
+} udt_VariableType;
+
+
+//-----------------------------------------------------------------------------
+// Declaration of common variable functions.
+//-----------------------------------------------------------------------------
+static void Variable_Free(udt_Variable *);
+static PyObject *Variable_Repr(udt_Variable *);
+static PyObject *Variable_ExternalCopy(udt_Variable *, PyObject *);
+static PyObject *Variable_ExternalSetValue(udt_Variable *, PyObject *);
+static PyObject *Variable_ExternalGetValue(udt_Variable *, PyObject *,
+        PyObject *);
+static int Variable_InternalBind(udt_Variable *);
+static int Variable_Resize(udt_Variable *, unsigned);
+
+
+//-----------------------------------------------------------------------------
+// declaration of members for variables
+//-----------------------------------------------------------------------------
+static PyMemberDef g_VariableMembers[] = {
+    { "bufferSize", T_INT, offsetof(udt_Variable, bufferSize), READONLY },
+    { "inconverter", T_OBJECT, offsetof(udt_Variable, inConverter), 0 },
+    { "numElements", T_INT, offsetof(udt_Variable, allocatedElements),
+            READONLY },
+    { "outconverter", T_OBJECT, offsetof(udt_Variable, outConverter), 0 },
+    { "size", T_INT, offsetof(udt_Variable, size), READONLY },
+    { "maxlength", T_INT, offsetof(udt_Variable, bufferSize), READONLY },
+    { "allocelems", T_INT, offsetof(udt_Variable, allocatedElements),
+            READONLY },
+    { NULL }
+};
+
+
+//-----------------------------------------------------------------------------
+// declaration of methods for variables
+//-----------------------------------------------------------------------------
+static PyMethodDef g_VariableMethods[] = {
+    { "copy", (PyCFunction) Variable_ExternalCopy, METH_VARARGS },
+    { "setvalue", (PyCFunction) Variable_ExternalSetValue, METH_VARARGS },
+    { "getvalue", (PyCFunction) Variable_ExternalGetValue,
+              METH_VARARGS  | METH_KEYWORDS },
+    { NULL }
+};
+
+
+//-----------------------------------------------------------------------------
+// The base variable type
+//-----------------------------------------------------------------------------
+static PyTypeObject g_BaseVarType = {
+    PyVarObject_HEAD_INIT(NULL, 0)
+    "cx_Oracle._BASEVARTYPE",           // tp_name
+    sizeof(udt_Variable),               // tp_basicsize
+    0,                                  // tp_itemsize
+    (destructor) Variable_Free,         // tp_dealloc
+    0,                                  // tp_print
+    0,                                  // tp_getattr
+    0,                                  // tp_setattr
+    0,                                  // tp_compare
+    (reprfunc) Variable_Repr,           // tp_repr
+    0,                                  // tp_as_number
+    0,                                  // tp_as_sequence
+    0,                                  // tp_as_mapping
+    0,                                  // tp_hash
+    0,                                  // tp_call
+    0,                                  // tp_str
+    0,                                  // tp_getattro
+    0,                                  // tp_setattro
+    0,                                  // tp_as_buffer
+    Py_TPFLAGS_DEFAULT,                 // tp_flags
+    0,                                  // tp_doc
+    0,                                  // tp_traverse
+    0,                                  // tp_clear
+    0,                                  // tp_richcompare
+    0,                                  // tp_weaklistoffset
+    0,                                  // tp_iter
+    0,                                  // tp_iternext
+    g_VariableMethods,                  // tp_methods
+    g_VariableMembers                   // tp_members
+};
+
+
+#include "Transforms.c"
+#include "StringVar.c"
+#include "LongVar.c"
+#include "NumberVar.c"
+#include "DateTimeVar.c"
+#include "TimestampVar.c"
+#include "LobVar.c"
+#include "CursorVar.c"
+#include "ObjectVar.c"
+#include "IntervalVar.c"
+
+
+//-----------------------------------------------------------------------------
+// Variable_AllocateData()
+//   Allocate the data for the variable.
+//-----------------------------------------------------------------------------
+static int Variable_AllocateData(
+    udt_Variable *self)                 // variable to allocate data for
+{
+    unsigned PY_LONG_LONG dataLength;
+
+    // set the buffer size for the variable
+    if (self->type->getBufferSizeProc)
+        self->bufferSize = (*self->type->getBufferSizeProc)(self);
+    else self->bufferSize = self->size;
+
+    // allocate the data as long as it is small enough
+    dataLength = (unsigned PY_LONG_LONG) self->allocatedElements *
+            (unsigned PY_LONG_LONG) self->bufferSize;
+    if (dataLength > INT_MAX) {
+        PyErr_SetString(PyExc_ValueError, "array size too large");
+        return -1;
+    }
+    self->data = PyMem_Malloc((size_t) dataLength);
+    if (!self->data) {
+        PyErr_NoMemory();
+        return -1;
+    }
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// Variable_New()
+//   Allocate a new variable.
+//-----------------------------------------------------------------------------
+static udt_Variable *Variable_New(
+    udt_Cursor *cursor,                 // cursor to associate variable with
+    unsigned numElements,               // number of elements to allocate
+    udt_VariableType *type,             // variable type
+    ub4 size)                           // used only for variable length types
+{
+    udt_Variable *self;
+    ub4 i;
+
+    // attempt to allocate the object
+    self = (udt_Variable*) type->pythonType->tp_alloc(type->pythonType, 0);
+    if (!self)
+        return NULL;
+
+    // perform basic initialization
+    Py_INCREF(cursor->connection->environment);
+    self->environment = cursor->connection->environment;
+    self->boundCursorHandle = NULL;
+    self->bindHandle = NULL;
+    self->defineHandle = NULL;
+    self->boundName = NULL;
+    self->inConverter = NULL;
+    self->outConverter = NULL;
+    self->boundPos = 0;
+    if (numElements < 1)
+        self->allocatedElements = 1;
+    else self->allocatedElements = numElements;
+    self->actualElements = 0;
+    self->internalFetchNum = 0;
+    self->isArray = 0;
+    self->isAllocatedInternally = 1;
+    self->type = type;
+    self->indicator = NULL;
+    self->data = NULL;
+    self->actualLength = NULL;
+    self->returnCode = NULL;
+
+    // set the maximum length of the variable, ensure that a minimum of
+    // 2 bytes is allocated to ensure that the array size check works
+    self->size = type->size;
+    if (type->isVariableLength) {
+        if (size < sizeof(ub2))
+            size = sizeof(ub2);
+        self->size = size;
+    }
+
+    // allocate the data for the variable
+    if (Variable_AllocateData(self) < 0) {
+        Py_DECREF(self);
+        return NULL;
+    }
+
+    // allocate the indicator for the variable
+    self->indicator = PyMem_Malloc(self->allocatedElements * sizeof(sb2));
+    if (!self->indicator) {
+        PyErr_NoMemory();
+        Py_DECREF(self);
+        return NULL;
+    }
+
+    // ensure that all variable values start out NULL
+    for (i = 0; i < self->allocatedElements; i++)
+        self->indicator[i] = OCI_IND_NULL;
+
+    // for variable length data, also allocate the return code
+    if (type->isVariableLength) {
+        self->returnCode = PyMem_Malloc(self->allocatedElements * sizeof(ub2));
+        if (!self->returnCode) {
+            PyErr_NoMemory();
+            Py_DECREF(self);
+            return NULL;
+        }
+    }
+
+    // perform extended initialization
+    if (self->type->initializeProc) {
+        if ((*self->type->initializeProc)(self, cursor) < 0) {
+            Py_DECREF(self);
+            return NULL;
+        }
+    }
+
+    return self;
+}
+
+
+//-----------------------------------------------------------------------------
+// Variable_Free()
+//   Free an existing variable.
+//-----------------------------------------------------------------------------
+static void Variable_Free(
+    udt_Variable *self)                 // variable to free
+{
+    if (self->isAllocatedInternally) {
+        if (self->type->finalizeProc)
+            (*self->type->finalizeProc)(self);
+        if (self->indicator)
+            PyMem_Free(self->indicator);
+        if (self->data)
+            PyMem_Free(self->data);
+        if (self->actualLength)
+            PyMem_Free(self->actualLength);
+        if (self->returnCode)
+            PyMem_Free(self->returnCode);
+    }
+    Py_CLEAR(self->environment);
+    Py_CLEAR(self->boundName);
+    Py_CLEAR(self->inConverter);
+    Py_CLEAR(self->outConverter);
+    Py_TYPE(self)->tp_free((PyObject*) self);
+}
+
+
+//-----------------------------------------------------------------------------
+// Variable_Resize()
+//   Resize the variable.
+//-----------------------------------------------------------------------------
+static int Variable_Resize(
+    udt_Variable *self,                 // variable to resize
+    unsigned size)                      // new size to use
+{
+    ub4 origBufferSize, i;
+    char *origData;
+
+    // allocate the data for the new array
+    origData = self->data;
+    origBufferSize = self->bufferSize;
+    self->size = size;
+    if (Variable_AllocateData(self) < 0)
+        return -1;
+
+    // copy the data from the original array to the new array
+    for (i = 0; i < self->allocatedElements; i++)
+        memcpy( (char*) self->data + self->bufferSize * i,
+                (void*) ( (char*) origData + origBufferSize * i ),
+                origBufferSize);
+    PyMem_Free(origData);
+
+    // force rebinding
+    if (self->boundName || self->boundPos > 0) {
+        if (Variable_InternalBind(self) < 0)
+            return -1;
+    }
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// Variable_Check()
+//   Returns a boolean indicating if the object is a variable.
+//-----------------------------------------------------------------------------
+static int Variable_Check(
+    PyObject *object)                   // Python object to check
+{
+    return (Py_TYPE(object) == &g_CursorVarType ||
+            Py_TYPE(object) == &g_DateTimeVarType ||
+            Py_TYPE(object) == &g_BFILEVarType ||
+            Py_TYPE(object) == &g_BLOBVarType ||
+            Py_TYPE(object) == &g_CLOBVarType ||
+            Py_TYPE(object) == &g_LongStringVarType ||
+            Py_TYPE(object) == &g_LongBinaryVarType ||
+            Py_TYPE(object) == &g_NumberVarType ||
+            Py_TYPE(object) == &g_StringVarType ||
+            Py_TYPE(object) == &g_FixedCharVarType ||
+            Py_TYPE(object) == &g_NCLOBVarType ||
+#if PY_MAJOR_VERSION < 3
+            Py_TYPE(object) == &g_UnicodeVarType ||
+            Py_TYPE(object) == &g_FixedUnicodeVarType ||
+            Py_TYPE(object) == &g_LongUnicodeVarType ||
+#endif
+            Py_TYPE(object) == &g_RowidVarType ||
+            Py_TYPE(object) == &g_BinaryVarType ||
+            Py_TYPE(object) == &g_TimestampVarType ||
+            Py_TYPE(object) == &g_IntervalVarType
+#ifdef SQLT_BFLOAT
+            || Py_TYPE(object) == &g_NativeFloatVarType
+#endif
+            );
+}
+
+
+//-----------------------------------------------------------------------------
+// Variable_TypeByPythonType()
+//   Return a variable type given a Python type object or NULL if the Python
+// type does not have a corresponding variable type.
+//-----------------------------------------------------------------------------
+static udt_VariableType *Variable_TypeByPythonType(
+    udt_Cursor* cursor,                 // cursor variable created for
+    PyObject* type)                     // Python type
+{
+    if (type == (PyObject*) &g_StringVarType)
+        return &vt_String;
+    if (type == (PyObject*) cxString_Type)
+        return &vt_String;
+    if (type == (PyObject*) &g_FixedCharVarType)
+        return &vt_FixedChar;
+#if PY_MAJOR_VERSION < 3
+    if (type == (PyObject*) &g_UnicodeVarType)
+        return &vt_NationalCharString;
+    if (type == (PyObject*) &PyUnicode_Type)
+        return &vt_NationalCharString;
+    if (type == (PyObject*) &g_FixedUnicodeVarType)
+        return &vt_FixedNationalChar;
+    if (type == (PyObject*) &g_LongUnicodeVarType)
+        return &vt_LongNationalCharString;
+#endif
+    if (type == (PyObject*) &g_NCLOBVarType)
+        return &vt_NCLOB;
+    if (type == (PyObject*) &g_RowidVarType)
+        return &vt_Rowid;
+    if (type == (PyObject*) &g_BinaryVarType)
+        return &vt_Binary;
+    if (type == (PyObject*) &cxBinary_Type)
+        return &vt_Binary;
+    if (type == (PyObject*) &g_LongStringVarType)
+        return &vt_LongString;
+    if (type == (PyObject*) &g_LongBinaryVarType)
+        return &vt_LongBinary;
+    if (type == (PyObject*) &g_BFILEVarType)
+        return &vt_BFILE;
+    if (type == (PyObject*) &g_BLOBVarType)
+        return &vt_BLOB;
+    if (type == (PyObject*) &g_CLOBVarType)
+        return &vt_CLOB;
+    if (type == (PyObject*) &g_NumberVarType) {
+        if (cursor->numbersAsStrings)
+            return &vt_NumberAsString;
+        return &vt_Float;
+    }
+    if (type == (PyObject*) &PyFloat_Type)
+        return &vt_Float;
+#if PY_MAJOR_VERSION < 3
+    if (type == (PyObject*) &PyInt_Type)
+        return &vt_Integer;
+#endif
+    if (type == (PyObject*) &PyLong_Type)
+        return &vt_LongInteger;
+    if (type == (PyObject*) &PyBool_Type)
+        return &vt_Boolean;
+    if (type == (PyObject*) &g_DateTimeVarType)
+        return &vt_DateTime;
+    if (type == (PyObject*) PyDateTimeAPI->DateType)
+        return &vt_Date;
+    if (type == (PyObject*) PyDateTimeAPI->DateTimeType)
+        return &vt_DateTime;
+    if (type == (PyObject*) &g_IntervalVarType)
+        return &vt_Interval;
+    if (type == (PyObject*) PyDateTimeAPI->DeltaType)
+        return &vt_Interval;
+    if (type == (PyObject*) &g_TimestampVarType)
+        return &vt_Timestamp;
+    if (type == (PyObject*) &g_CursorVarType)
+        return &vt_Cursor;
+#ifdef SQLT_BFLOAT
+    if (type == (PyObject*) &g_NativeFloatVarType)
+        return &vt_NativeFloat;
+#endif
+    if (type == (PyObject*) &g_ObjectVarType)
+        return &vt_Object;
+
+    PyErr_SetString(g_NotSupportedErrorException,
+            "Variable_TypeByPythonType(): unhandled data type");
+    return NULL;
+}
+
+
+//-----------------------------------------------------------------------------
+// Variable_TypeByValue()
+//   Return a variable type given a Python object or NULL if the Python
+// object does not have a corresponding variable type.
+//-----------------------------------------------------------------------------
+static udt_VariableType *Variable_TypeByValue(
+    PyObject* value,                    // Python type
+    ub4* size,                          // size to use (OUT)
+    unsigned *numElements)              // number of elements (OUT)
+{
+    udt_VariableType *varType;
+    PyObject *elementValue;
+    char buffer[200];
+    int i, result;
+
+    // handle scalars
+    if (value == Py_None) {
+        *size = 1;
+        return &vt_String;
+    }
+    if (cxString_Check(value)) {
+        *size = cxString_GetSize(value);
+        if (*size > MAX_STRING_CHARS)
+            return &vt_LongString;
+        return &vt_String;
+    }
+#if PY_MAJOR_VERSION < 3
+    if (PyUnicode_Check(value)) {
+        *size = PyUnicode_GET_SIZE(value);
+        if (*size > MAX_STRING_CHARS)
+            return &vt_LongNationalCharString;
+        return &vt_NationalCharString;
+    }
+    if (PyInt_Check(value))
+        return &vt_Integer;
+#else
+    if (PyBytes_Check(value)) {
+        *size = PyBytes_GET_SIZE(value);
+        if (*size > MAX_BINARY_BYTES)
+            return &vt_LongBinary;
+        return &vt_Binary;
+    }
+#endif
+    if (PyLong_Check(value))
+        return &vt_LongInteger;
+    if (PyFloat_Check(value))
+        return &vt_Float;
+    if (cxBinary_Check(value)) {
+        udt_Buffer temp;
+        if (cxBuffer_FromObject(&temp, value, NULL) < 0)
+            return NULL;
+        *size = temp.size;
+        cxBuffer_Clear(&temp);
+        if (*size > MAX_BINARY_BYTES)
+            return &vt_LongBinary;
+        return &vt_Binary;
+    }
+    if (PyBool_Check(value))
+        return &vt_Boolean;
+    if (PyDateTime_Check(value))
+        return &vt_DateTime;
+    if (PyDate_Check(value))
+        return &vt_DateTime;
+    if (PyDelta_Check(value))
+        return &vt_Interval;
+    result = PyObject_IsInstance(value, (PyObject*) &g_CursorType);
+    if (result < 0)
+        return NULL;
+    if (result)
+        return &vt_Cursor;
+    if (Py_TYPE(value) == g_DateTimeType)
+        return &vt_DateTime;
+    if (Py_TYPE(value) == g_DecimalType)
+        return &vt_NumberAsString;
+
+    // handle arrays
+    if (PyList_Check(value)) {
+        elementValue = Py_None;
+        for (i = 0; i < PyList_GET_SIZE(value); i++) {
+            elementValue = PyList_GET_ITEM(value, i);
+            if (elementValue != Py_None)
+                break;
+        }
+        varType = Variable_TypeByValue(elementValue, size, numElements);
+        if (!varType)
+            return NULL;
+        *numElements = PyList_GET_SIZE(value);
+        *size = varType->size;
+        return varType;
+    }
+
+    sprintf(buffer, "Variable_TypeByValue(): unhandled data type %.*s", 150,
+            Py_TYPE(value)->tp_name);
+    PyErr_SetString(g_NotSupportedErrorException, buffer);
+    return NULL;
+}
+
+
+//-----------------------------------------------------------------------------
+// Variable_TypeByOracleDataType()
+//   Return a variable type given an Oracle data type or NULL if the Oracle
+// data type does not have a corresponding variable type.
+//-----------------------------------------------------------------------------
+static udt_VariableType *Variable_TypeByOracleDataType (
+    ub2 oracleDataType,                 // Oracle data type
+    ub1 charsetForm)                    // character set form
+{
+    char buffer[100];
+
+    switch(oracleDataType) {
+        case SQLT_LNG:
+            return &vt_LongString;
+        case SQLT_AFC:
+#if PY_MAJOR_VERSION < 3
+            if (charsetForm == SQLCS_NCHAR)
+                return &vt_FixedNationalChar;
+#endif
+            return &vt_FixedChar;
+        case SQLT_CHR:
+#if PY_MAJOR_VERSION < 3
+            if (charsetForm == SQLCS_NCHAR)
+                return &vt_NationalCharString;
+#endif
+            return &vt_String;
+        case SQLT_RDD:
+            return &vt_Rowid;
+        case SQLT_BIN:
+            return &vt_Binary;
+        case SQLT_LBI:
+            return &vt_LongBinary;
+#ifdef SQLT_BFLOAT
+        case SQLT_BFLOAT:
+        case SQLT_IBFLOAT:
+        case SQLT_BDOUBLE:
+        case SQLT_IBDOUBLE:
+            return &vt_NativeFloat;
+#endif
+        case SQLT_NUM:
+        case SQLT_VNU:
+            return &vt_Float;
+        case SQLT_DAT:
+        case SQLT_ODT:
+            return &vt_DateTime;
+        case SQLT_DATE:
+        case SQLT_TIMESTAMP:
+        case SQLT_TIMESTAMP_TZ:
+        case SQLT_TIMESTAMP_LTZ:
+            return &vt_Timestamp;
+        case SQLT_INTERVAL_DS:
+            return &vt_Interval;
+        case SQLT_CLOB:
+            if (charsetForm == SQLCS_NCHAR)
+                return &vt_NCLOB;
+            return &vt_CLOB;
+        case SQLT_BLOB:
+            return &vt_BLOB;
+        case SQLT_BFILE:
+            return &vt_BFILE;
+        case SQLT_RSET:
+            return &vt_Cursor;
+        case SQLT_NTY:
+            return &vt_Object;
+    }
+
+    sprintf(buffer, "Variable_TypeByOracleDataType: unhandled data type %d",
+            oracleDataType);
+    PyErr_SetString(g_NotSupportedErrorException, buffer);
+    return NULL;
+}
+
+
+//-----------------------------------------------------------------------------
+// Variable_TypeByOracleDescriptor()
+//   Return a variable type given an Oracle descriptor.
+//-----------------------------------------------------------------------------
+static udt_VariableType *Variable_TypeByOracleDescriptor(
+    OCIParam *param,                    // parameter to get type from
+    udt_Environment *environment)       // environment to use
+{
+    ub1 charsetForm;
+    ub2 dataType;
+    sword status;
+
+    // retrieve datatype of the parameter
+    status = OCIAttrGet(param, OCI_HTYPE_DESCRIBE, (dvoid*) &dataType, 0,
+            OCI_ATTR_DATA_TYPE, environment->errorHandle);
+    if (Environment_CheckForError(environment, status,
+            "Variable_TypeByOracleDescriptor(): data type") < 0)
+        return NULL;
+
+    // retrieve character set form of the parameter
+    if (dataType != SQLT_CHR && dataType != SQLT_AFC &&
+            dataType != SQLT_CLOB) {
+        charsetForm = SQLCS_IMPLICIT;
+    } else {
+        status = OCIAttrGet(param, OCI_HTYPE_DESCRIBE, (dvoid*) &charsetForm,
+                0, OCI_ATTR_CHARSET_FORM, environment->errorHandle);
+        if (Environment_CheckForError(environment, status,
+                "Variable_TypeByOracleDescriptor(): charset form") < 0)
+            return NULL;
+    }
+
+    return Variable_TypeByOracleDataType(dataType, charsetForm);
+}
+
+
+//-----------------------------------------------------------------------------
+// Variable_MakeArray()
+//   Make the variable an array, ensuring that the type supports arrays.
+//-----------------------------------------------------------------------------
+static int Variable_MakeArray(
+    udt_Variable *var)                  // variable to make an array
+{
+    if (!var->type->canBeInArray) {
+        PyErr_SetString(g_NotSupportedErrorException,
+                "Variable_MakeArray(): type does not support arrays");
+        return -1;
+    }
+    var->isArray = 1;
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// Variable_DefaultNewByValue()
+//   Default method for determining the type of variable to use for the data.
+//-----------------------------------------------------------------------------
+static udt_Variable *Variable_DefaultNewByValue(
+    udt_Cursor *cursor,                 // cursor to associate variable with
+    PyObject *value,                    // Python value to associate
+    unsigned numElements)               // number of elements to allocate
+{
+    udt_VariableType *varType;
+    udt_Variable *var;
+    ub4 size = 0;
+
+    varType = Variable_TypeByValue(value, &size, &numElements);
+    if (!varType)
+        return NULL;
+    var = Variable_New(cursor, numElements, varType, size);
+    if (!var)
+        return NULL;
+    if (PyList_Check(value)) {
+        if (Variable_MakeArray(var) < 0) {
+            Py_DECREF(var);
+            return NULL;
+        }
+    }
+
+    return var;
+}
+
+
+//-----------------------------------------------------------------------------
+// Variable_NewByInputTypeHandler()
+//   Allocate a new variable by looking at the type of the data.
+//-----------------------------------------------------------------------------
+static udt_Variable *Variable_NewByInputTypeHandler(
+    udt_Cursor *cursor,                 // cursor to associate variable with
+    PyObject *inputTypeHandler,         // input type handler
+    PyObject *value,                    // Python value to associate
+    unsigned numElements)               // number of elements to allocate
+{
+    PyObject *var;
+
+    var = PyObject_CallFunction(inputTypeHandler, "OOi", cursor, value,
+            numElements);
+    if (!var)
+        return NULL;
+    if (var != Py_None) {
+        if (!Variable_Check(var)) {
+            Py_DECREF(var);
+            PyErr_SetString(PyExc_TypeError,
+                    "expecting variable from input type handler");
+            return NULL;
+        }
+        return (udt_Variable*) var;
+    }
+    Py_DECREF(var);
+    return Variable_DefaultNewByValue(cursor, value, numElements);
+}
+
+
+//-----------------------------------------------------------------------------
+// Variable_NewByValue()
+//   Allocate a new variable by looking at the type of the data.
+//-----------------------------------------------------------------------------
+static udt_Variable *Variable_NewByValue(
+    udt_Cursor *cursor,                 // cursor to associate variable with
+    PyObject *value,                    // Python value to associate
+    unsigned numElements)               // number of elements to allocate
+{
+    if (cursor->inputTypeHandler && cursor->inputTypeHandler != Py_None)
+        return Variable_NewByInputTypeHandler(cursor, cursor->inputTypeHandler,
+                value, numElements);
+    if (cursor->connection->inputTypeHandler &&
+            cursor->connection->inputTypeHandler != Py_None)
+        return Variable_NewByInputTypeHandler(cursor,
+                cursor->connection->inputTypeHandler, value, numElements);
+    return Variable_DefaultNewByValue(cursor, value, numElements);
+}
+
+
+//-----------------------------------------------------------------------------
+// Variable_NewArrayByType()
+//   Allocate a new PL/SQL array by looking at the Python data type.
+//-----------------------------------------------------------------------------
+static udt_Variable *Variable_NewArrayByType(
+    udt_Cursor *cursor,                 // cursor to bind variable to
+    PyObject *value)                    // value to bind
+{
+    PyObject *typeObj, *numElementsObj;
+    udt_VariableType *varType;
+    unsigned numElements;
+    udt_Variable *var;
+
+    if (PyList_GET_SIZE(value) != 2) {
+        PyErr_SetString(g_ProgrammingErrorException,
+                "expecting an array of two elements [type, numelems]");
+        return NULL;
+    }
+
+    typeObj = PyList_GET_ITEM(value, 0);
+    numElementsObj = PyList_GET_ITEM(value, 1);
+    if (!PyInt_Check(numElementsObj)) {
+        PyErr_SetString(g_ProgrammingErrorException,
+                "number of elements must be an integer");
+        return NULL;
+    }
+
+    varType = Variable_TypeByPythonType(cursor, typeObj);
+    if (!varType)
+        return NULL;
+
+    numElements = PyInt_AsLong(numElementsObj);
+    if (PyErr_Occurred())
+        return NULL;
+    var = Variable_New(cursor, numElements, varType, varType->size);
+    if (!var)
+        return NULL;
+    if (Variable_MakeArray(var) < 0) {
+        Py_DECREF(var);
+        return NULL;
+    }
+
+    return var;
+}
+
+
+//-----------------------------------------------------------------------------
+// Variable_NewByType()
+//   Allocate a new variable by looking at the Python data type.
+//-----------------------------------------------------------------------------
+static udt_Variable *Variable_NewByType(
+    udt_Cursor *cursor,                 // cursor to associate variable with
+    PyObject *value,                    // Python data type to associate
+    unsigned numElements)               // number of elements to allocate
+{
+    udt_VariableType *varType;
+    int size;
+
+    // passing an integer is assumed to be a string
+    if (PyInt_Check(value)) {
+        size = PyInt_AsLong(value);
+        if (PyErr_Occurred())
+            return NULL;
+        if (size > MAX_STRING_CHARS)
+            varType = &vt_LongString;
+        else varType = &vt_String;
+        return Variable_New(cursor, numElements, varType, size);
+    }
+
+    // passing an array of two elements to define an array
+    if (PyList_Check(value))
+        return Variable_NewArrayByType(cursor, value);
+
+    // handle directly bound variables
+    if (Variable_Check(value)) {
+        Py_INCREF(value);
+        return (udt_Variable*) value;
+    }
+
+    // everything else ought to be a Python type
+    varType = Variable_TypeByPythonType(cursor, value);
+    if (!varType)
+        return NULL;
+    return Variable_New(cursor, numElements, varType, varType->size);
+}
+
+
+//-----------------------------------------------------------------------------
+// Variable_NewByOutputTypeHandler()
+//   Create a new variable by calling the output type handler.
+//-----------------------------------------------------------------------------
+static udt_Variable *Variable_NewByOutputTypeHandler(
+    udt_Cursor *cursor,                 // cursor to associate variable with
+    OCIParam *param,                    // parameter descriptor
+    PyObject *outputTypeHandler,        // method to call to get type
+    udt_VariableType *varType,          // variable type already chosen
+    ub4 size,                           // maximum size of variable
+    unsigned numElements)               // number of elements
+{
+    udt_Variable *var;
+    PyObject *result;
+    ub4 nameLength;
+    sb2 precision;
+    sword status;
+    char *name;
+    sb1 scale;
+
+    // determine name of variable
+    status = OCIAttrGet(param, OCI_HTYPE_DESCRIBE, (dvoid*) &name,
+            &nameLength, OCI_ATTR_NAME, cursor->environment->errorHandle);
+    if (Environment_CheckForError(cursor->environment, status,
+            "Variable_NewByOutputTypeHandler(): get name") < 0)
+        return NULL;
+
+    // retrieve scale and precision of the parameter, if applicable
+    precision = scale = 0;
+    if (varType->pythonType == &g_NumberVarType) {
+        status = OCIAttrGet(param, OCI_HTYPE_DESCRIBE, (dvoid*) &scale, 0,
+                OCI_ATTR_SCALE, cursor->environment->errorHandle);
+        if (Environment_CheckForError(cursor->environment, status,
+                "Variable_NewByOutputTypeHandler(): get scale") < 0)
+            return NULL;
+        status = OCIAttrGet(param, OCI_HTYPE_DESCRIBE, (dvoid*) &precision, 0,
+                OCI_ATTR_PRECISION, cursor->environment->errorHandle);
+        if (Environment_CheckForError(cursor->environment, status,
+                "Variable_NewByOutputTypeHandler(): get precision") < 0)
+            return NULL;
+    }
+
+    // call method, passing parameters
+    result = PyObject_CallFunction(outputTypeHandler, "Os#Oiii", cursor, name,
+            nameLength, varType->pythonType, size, precision, scale);
+    if (!result)
+        return NULL;
+
+    // if result is None, assume default behavior
+    if (result == Py_None) {
+        Py_DECREF(result);
+        return Variable_New(cursor, numElements, varType, size);
+    }
+
+    // otherwise, verify that the result is an actual variable
+    if (!Variable_Check(result)) {
+        Py_DECREF(result);
+        PyErr_SetString(PyExc_TypeError,
+                "expecting variable from output type handler");
+        return NULL;
+    }
+
+    // verify that the array size is sufficient to handle the fetch
+    var = (udt_Variable*) result;
+    if (var->allocatedElements < cursor->fetchArraySize) {
+        Py_DECREF(result);
+        PyErr_SetString(PyExc_TypeError,
+                "expecting variable with array size large enough for fetch");
+        return NULL;
+    }
+
+    return var;
+}
+
+
+//-----------------------------------------------------------------------------
+// Variable_DefineHelper()
+//   Helper routine for Variable_Define() used so that constant calls to
+// OCIDescriptorFree() is not necessary.
+//-----------------------------------------------------------------------------
+static udt_Variable *Variable_DefineHelper(
+    udt_Cursor *cursor,                 // cursor in use
+    OCIParam *param,                    // parameter descriptor
+    unsigned position,                  // position in define list
+    unsigned numElements)               // number of elements to create
+{
+    udt_VariableType *varType;
+    ub2 sizeFromOracle;
+    udt_Variable *var;
+    sword status;
+    ub4 size;
+
+    // determine data type
+    varType = Variable_TypeByOracleDescriptor(param, cursor->environment);
+    if (!varType)
+        return NULL;
+    if (cursor->numbersAsStrings && varType == &vt_Float)
+        varType = &vt_NumberAsString;
+
+    // retrieve size of the parameter
+    size = varType->size;
+    if (varType->isVariableLength) {
+
+        // determine the maximum length from Oracle
+        status = OCIAttrGet(param, OCI_HTYPE_DESCRIBE,
+                (dvoid*) &sizeFromOracle, 0, OCI_ATTR_DATA_SIZE,
+                cursor->environment->errorHandle);
+        if (Environment_CheckForError(cursor->environment, status,
+                "Variable_Define(): data size") < 0)
+            return NULL;
+
+        // use the length from Oracle directly if available
+        if (sizeFromOracle)
+            size = sizeFromOracle;
+
+        // otherwise, use the value set with the setoutputsize() parameter
+        else if (cursor->outputSize >= 0) {
+            if (cursor->outputSizeColumn < 0 ||
+                    (int) position == cursor->outputSizeColumn)
+                size = cursor->outputSize;
+        }
+    }
+
+    // create a variable of the correct type
+    if (cursor->outputTypeHandler && cursor->outputTypeHandler != Py_None)
+        var = Variable_NewByOutputTypeHandler(cursor, param,
+                cursor->outputTypeHandler, varType, size, numElements);
+    else if (cursor->connection->outputTypeHandler &&
+            cursor->connection->outputTypeHandler != Py_None)
+        var = Variable_NewByOutputTypeHandler(cursor, param,
+                cursor->connection->outputTypeHandler, varType, size,
+                numElements);
+    else var = Variable_New(cursor, numElements, varType, size);
+    if (!var)
+        return NULL;
+
+    // call the procedure to set values prior to define
+    if (var->type->preDefineProc) {
+        if ((*var->type->preDefineProc)(var, param) < 0) {
+            Py_DECREF(var);
+            return NULL;
+        }
+    }
+
+    // perform the define
+    status = OCIDefineByPos(cursor->handle, &var->defineHandle,
+            var->environment->errorHandle, position, var->data,
+            var->bufferSize, var->type->oracleType, var->indicator,
+            var->actualLength, var->returnCode, OCI_DEFAULT);
+    if (Environment_CheckForError(var->environment, status,
+            "Variable_Define(): define") < 0) {
+        Py_DECREF(var);
+        return NULL;
+    }
+
+    // call the procedure to set values after define
+    if (var->type->postDefineProc) {
+        if ((*var->type->postDefineProc)(var) < 0) {
+            Py_DECREF(var);
+            return NULL;
+        }
+    }
+
+    return var;
+}
+
+
+//-----------------------------------------------------------------------------
+// Variable_Define()
+//   Allocate a variable and define it for the given statement.
+//-----------------------------------------------------------------------------
+static udt_Variable *Variable_Define(
+    udt_Cursor *cursor,                 // cursor to define for
+    unsigned numElements,               // number of elements to create
+    unsigned position)                  // position to define
+{
+    udt_Variable *var;
+    OCIParam *param;
+    sword status;
+
+    // retrieve parameter descriptor
+    status = OCIParamGet(cursor->handle, OCI_HTYPE_STMT,
+            cursor->environment->errorHandle, (void**) &param, position);
+    if (Environment_CheckForError(cursor->environment, status,
+            "Variable_Define(): parameter") < 0)
+        return NULL;
+
+    // call the helper to do the actual work
+    var = Variable_DefineHelper(cursor, param, position, numElements);
+    OCIDescriptorFree(param, OCI_DTYPE_PARAM);
+    return var;
+}
+
+
+//-----------------------------------------------------------------------------
+// Variable_InternalBind()
+//   Allocate a variable and bind it to the given statement.
+//-----------------------------------------------------------------------------
+static int Variable_InternalBind(
+    udt_Variable *var)                  // variable to bind
+{
+    sword status;
+
+    // perform the bind
+    if (var->boundName) {
+        udt_Buffer buffer;
+        if (cxBuffer_FromObject(&buffer, var->boundName,
+                var->environment->encoding) < 0)
+            return -1;
+        if (var->isArray) {
+            status = OCIBindByName(var->boundCursorHandle, &var->bindHandle,
+                    var->environment->errorHandle, (text*) buffer.ptr,
+                    buffer.size, var->data, var->bufferSize,
+                    var->type->oracleType, var->indicator, var->actualLength,
+                    var->returnCode, var->allocatedElements,
+                    &var->actualElements, OCI_DEFAULT);
+        } else {
+            status = OCIBindByName(var->boundCursorHandle, &var->bindHandle,
+                    var->environment->errorHandle, (text*) buffer.ptr,
+                    buffer.size, var->data, var->bufferSize,
+                    var->type->oracleType, var->indicator, var->actualLength,
+                    var->returnCode, 0, 0, OCI_DEFAULT);
+        }
+        cxBuffer_Clear(&buffer);
+    } else {
+        if (var->isArray) {
+            status = OCIBindByPos(var->boundCursorHandle, &var->bindHandle,
+                    var->environment->errorHandle, var->boundPos, var->data,
+                    var->bufferSize, var->type->oracleType, var->indicator,
+                    var->actualLength, var->returnCode, var->allocatedElements,
+                    &var->actualElements, OCI_DEFAULT);
+        } else {
+            status = OCIBindByPos(var->boundCursorHandle, &var->bindHandle,
+                    var->environment->errorHandle, var->boundPos, var->data,
+                    var->bufferSize, var->type->oracleType, var->indicator,
+                    var->actualLength, var->returnCode, 0, 0, OCI_DEFAULT);
+        }
+    }
+    if (Environment_CheckForError(var->environment, status,
+            "Variable_InternalBind()") < 0)
+        return -1;
+
+#if PY_MAJOR_VERSION < 3
+    // set the charset form and id if applicable
+    if (var->type->charsetForm != SQLCS_IMPLICIT) {
+        status = OCIAttrSet(var->bindHandle, OCI_HTYPE_BIND,
+                (dvoid*) &var->type->charsetForm, 0, OCI_ATTR_CHARSET_FORM,
+                var->environment->errorHandle);
+        if (Environment_CheckForError(var->environment, status,
+                "Variable_InternalBind(): set charset form") < 0)
+            return -1;
+        status = OCIAttrSet(var->bindHandle, OCI_HTYPE_BIND,
+                (dvoid*) &var->bufferSize, 0, OCI_ATTR_MAXDATA_SIZE,
+                var->environment->errorHandle);
+        if (Environment_CheckForError(var->environment, status,
+                "Variable_InternalBind(): set max data size") < 0)
+            return -1;
+    }
+#endif
+
+    // set the max data size for strings
+    if ((var->type == &vt_String || var->type == &vt_FixedChar)
+            && var->size > var->type->size) {
+        status = OCIAttrSet(var->bindHandle, OCI_HTYPE_BIND,
+                (dvoid*) &var->type->size, 0, OCI_ATTR_MAXDATA_SIZE,
+                var->environment->errorHandle);
+        if (Environment_CheckForError(var->environment, status,
+                "Variable_InternalBind(): set max data size") < 0)
+            return -1;
+    }
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// Variable_Bind()
+//   Allocate a variable and bind it to the given statement.
+//-----------------------------------------------------------------------------
+static int Variable_Bind(
+    udt_Variable *var,                  // variable to bind
+    udt_Cursor *cursor,                 // cursor to bind to
+    PyObject *name,                     // name to bind to
+    ub4 pos)                            // position to bind to
+{
+    // nothing to do if already bound
+    if (var->bindHandle && name == var->boundName && pos == var->boundPos)
+        return 0;
+
+    // set the instance variables specific for binding
+    var->boundPos = pos;
+    var->boundCursorHandle = cursor->handle;
+    Py_XDECREF(var->boundName);
+    Py_XINCREF(name);
+    var->boundName = name;
+
+    // perform the bind
+    return Variable_InternalBind(var);
+}
+
+
+//-----------------------------------------------------------------------------
+// Variable_VerifyFetch()
+//   Verifies that truncation or other problems did not take place on retrieve.
+//-----------------------------------------------------------------------------
+static int Variable_VerifyFetch(
+  udt_Variable *var,                    // variable to check fetch for
+  unsigned arrayPos)                    // array position
+{
+    char messageText[200];
+    udt_Error *error;
+
+    if (var->type->isVariableLength) {
+        if (var->returnCode[arrayPos] != 0) {
+            error = Error_New(var->environment, "Variable_VerifyFetch()", 0);
+            error->code = var->returnCode[arrayPos];
+            sprintf(messageText, 
+                    "column at array pos %d fetched with error: %d",
+                    arrayPos, var->returnCode[arrayPos]);
+            error->message = cxString_FromAscii(messageText);
+            if (!error->message)
+                Py_DECREF(error);
+            else PyErr_SetObject(g_DatabaseErrorException, (PyObject*) error);
+            return -1;
+        }
+    }
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// Variable_GetSingleValue()
+//   Return the value of the variable at the given position.
+//-----------------------------------------------------------------------------
+static PyObject *Variable_GetSingleValue(
+    udt_Variable *var,                  // variable to get the value for
+    unsigned arrayPos)                  // array position
+{
+    PyObject *value, *result;
+    int isNull;
+
+    // ensure we do not exceed the number of allocated elements
+    if (arrayPos >= var->allocatedElements) {
+        PyErr_SetString(PyExc_IndexError,
+                "Variable_GetSingleValue: array size exceeded");
+        return NULL;
+    }
+
+    // check for a NULL value
+    if (var->type->isNullProc)
+        isNull = (*var->type->isNullProc)(var, arrayPos);
+    else isNull = (var->indicator[arrayPos] == OCI_IND_NULL);
+    if (isNull) {
+        Py_INCREF(Py_None);
+        return Py_None;
+    }
+
+    // check for truncation or other problems on retrieve
+    if (Variable_VerifyFetch(var, arrayPos) < 0)
+        return NULL;
+
+    // calculate value to return
+    value = (*var->type->getValueProc)(var, arrayPos);
+    if (value && var->outConverter && var->outConverter != Py_None) {
+        result = PyObject_CallFunctionObjArgs(var->outConverter, value, NULL);
+        Py_DECREF(value);
+        return result;
+    }
+
+    return value;
+}
+
+
+//-----------------------------------------------------------------------------
+// Variable_GetArrayValue()
+//   Return the value of the variable as an array.
+//-----------------------------------------------------------------------------
+static PyObject *Variable_GetArrayValue(
+    udt_Variable *var,                  // variable to get the value for
+    ub4 numElements)                    // number of elements to include
+{
+    PyObject *value, *singleValue;
+    ub4 i;
+
+    value = PyList_New(numElements);
+    if (!value)
+        return NULL;
+
+    for (i = 0; i < numElements; i++) {
+        singleValue = Variable_GetSingleValue(var, i);
+        if (!singleValue) {
+            Py_DECREF(value);
+            return NULL;
+        }
+        PyList_SET_ITEM(value, i, singleValue);
+    }
+
+    return value;
+}
+
+
+//-----------------------------------------------------------------------------
+// Variable_GetValue()
+//   Return the value of the variable.
+//-----------------------------------------------------------------------------
+static PyObject *Variable_GetValue(
+    udt_Variable *var,                  // variable to get the value for
+    unsigned arrayPos)                  // array position
+{
+    if (var->isArray)
+        return Variable_GetArrayValue(var, var->actualElements);
+    return Variable_GetSingleValue(var, arrayPos);
+}
+
+
+//-----------------------------------------------------------------------------
+// Variable_SetSingleValue()
+//   Set a single value in the variable.
+//-----------------------------------------------------------------------------
+static int Variable_SetSingleValue(
+    udt_Variable *var,                  // variable to set value for
+    unsigned arrayPos,                  // array position
+    PyObject *value)                    // value to set
+{
+    PyObject *convertedValue = NULL;
+    int result;
+
+    // ensure we do not exceed the number of allocated elements
+    if (arrayPos >= var->allocatedElements) {
+        PyErr_SetString(PyExc_IndexError,
+                "Variable_SetSingleValue: array size exceeded");
+        return -1;
+    }
+
+    // convert value, if necessary
+    if (var->inConverter && var->inConverter != Py_None) {
+        convertedValue = PyObject_CallFunctionObjArgs(var->inConverter, value,
+                NULL);
+        if (!convertedValue)
+            return -1;
+        value = convertedValue;
+    }
+
+    // check for a NULL value
+    if (value == Py_None) {
+        var->indicator[arrayPos] = OCI_IND_NULL;
+        Py_XDECREF(convertedValue);
+        return 0;
+    }
+
+    var->indicator[arrayPos] = OCI_IND_NOTNULL;
+    if (var->type->isVariableLength)
+        var->returnCode[arrayPos] = 0;
+    result = (*var->type->setValueProc)(var, arrayPos, value);
+    Py_XDECREF(convertedValue);
+    return result;
+}
+
+
+//-----------------------------------------------------------------------------
+// Variable_SetArrayValue()
+//   Set all of the array values for the variable.
+//-----------------------------------------------------------------------------
+static int Variable_SetArrayValue(
+    udt_Variable *var,                  // variable to set value for
+    PyObject *value)                    // value to set
+{
+    unsigned numElements;
+    ub4 i;
+
+    // ensure we have an array to set
+    if (!PyList_Check(value)) {
+        PyErr_SetString(PyExc_TypeError, "expecting array data");
+        return -1;
+    }
+
+    // ensure we haven't exceeded the number of allocated elements
+    numElements = PyList_GET_SIZE(value);
+    if (numElements > var->allocatedElements) {
+        PyErr_SetString(PyExc_IndexError,
+                "Variable_SetArrayValue: array size exceeded");
+        return -1;
+    }
+
+    // set all of the values
+    var->actualElements = numElements;
+    for (i = 0; i < var->actualElements; i++) {
+        if (Variable_SetSingleValue(var, i, PyList_GET_ITEM(value, i)) < 0)
+            return -1;
+    }
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// Variable_SetValue()
+//   Set the value of the variable.
+//-----------------------------------------------------------------------------
+static int Variable_SetValue(
+    udt_Variable *var,                  // variable to set
+    unsigned arrayPos,                  // array position
+    PyObject *value)                    // value to set
+{
+    if (var->isArray) {
+        if (arrayPos > 0) {
+            PyErr_SetString(g_NotSupportedErrorException,
+                    "arrays of arrays are not supported by the OCI");
+            return -1;
+        }
+        return Variable_SetArrayValue(var, value);
+    }
+    return Variable_SetSingleValue(var, arrayPos, value);
+}
+
+
+//-----------------------------------------------------------------------------
+// Variable_ExternalCopy()
+//   Copy the contents of the source variable to the destination variable.
+//-----------------------------------------------------------------------------
+static PyObject *Variable_ExternalCopy(
+    udt_Variable *targetVar,            // variable to set
+    PyObject *args)                     // arguments
+{
+    unsigned sourcePos, targetPos;
+    udt_Variable *sourceVar;
+
+    // parse arguments; verify that copy is possible
+    if (!PyArg_ParseTuple(args, "Oii", &sourceVar, &sourcePos, &targetPos))
+        return NULL;
+    if (Py_TYPE(targetVar) != Py_TYPE(sourceVar)) {
+        PyErr_SetString(g_ProgrammingErrorException,
+                "source and target variable type must match");
+        return NULL;
+    }
+    if (!sourceVar->type->canBeCopied) {
+        PyErr_SetString(g_ProgrammingErrorException,
+                "variable does not support copying");
+        return NULL;
+    }
+
+    // ensure array positions are not violated
+    if (sourcePos >= sourceVar->allocatedElements) {
+        PyErr_SetString(PyExc_IndexError,
+                "Variable_ExternalCopy: source array size exceeded");
+        return NULL;
+    }
+    if (targetPos >= targetVar->allocatedElements) {
+        PyErr_SetString(PyExc_IndexError,
+                "Variable_ExternalCopy: target array size exceeded");
+        return NULL;
+    }
+
+    // ensure target can support amount data from the source
+    if (targetVar->bufferSize < sourceVar->bufferSize) {
+        PyErr_SetString(g_ProgrammingErrorException,
+                "target variable has insufficient space to copy source data");
+        return NULL;
+    }
+
+    // handle null case directly
+    if (sourceVar->indicator[sourcePos] == OCI_IND_NULL)
+        targetVar->indicator[targetPos] = OCI_IND_NULL;
+
+    // otherwise, copy data
+    else {
+        targetVar->indicator[targetPos] = OCI_IND_NOTNULL;
+        if (Variable_VerifyFetch(sourceVar, sourcePos) < 0)
+            return NULL;
+        if (targetVar->actualLength)
+            targetVar->actualLength[targetPos] =
+                    sourceVar->actualLength[sourcePos];
+        if (targetVar->returnCode)
+            targetVar->returnCode[targetPos] =
+                    sourceVar->returnCode[sourcePos];
+        memcpy( (char*) targetVar->data + targetPos * targetVar->bufferSize,
+                (char*) sourceVar->data + sourcePos * sourceVar->bufferSize,
+                sourceVar->bufferSize);
+    }
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+
+//-----------------------------------------------------------------------------
+// Variable_ExternalSetValue()
+//   Set the value of the variable at the given position.
+//-----------------------------------------------------------------------------
+static PyObject *Variable_ExternalSetValue(
+    udt_Variable *var,                  // variable to set
+    PyObject *args)                     // arguments
+{
+    PyObject *value;
+    unsigned pos;
+
+    if (!PyArg_ParseTuple(args, "iO", &pos, &value))
+      return NULL;
+    if (Variable_SetValue(var, pos, value) < 0)
+      return NULL;
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+
+//-----------------------------------------------------------------------------
+// Variable_ExternalGetValue()
+//   Return the value of the variable at the given position.
+//-----------------------------------------------------------------------------
+static PyObject *Variable_ExternalGetValue(
+    udt_Variable *var,                  // variable to set
+    PyObject *args,                     // arguments
+    PyObject *keywordArgs)              // keyword arguments
+{
+    static char *keywordList[] = { "pos", NULL };
+    unsigned pos = 0;
+
+    if (!PyArg_ParseTupleAndKeywords(args, keywordArgs, "|i", keywordList,
+            &pos))
+        return NULL;
+    return Variable_GetValue(var, pos);
+}
+
+
+//-----------------------------------------------------------------------------
+// Variable_Repr()
+//   Return a string representation of the variable.
+//-----------------------------------------------------------------------------
+static PyObject *Variable_Repr(
+    udt_Variable *var)                  // variable to return the string for
+{
+    PyObject *valueRepr, *value, *module, *name, *result, *format, *formatArgs;
+
+    if (var->isArray)
+        value = Variable_GetArrayValue(var, var->actualElements);
+    else if (var->allocatedElements == 1)
+        value = Variable_GetSingleValue(var, 0);
+    else value = Variable_GetArrayValue(var, var->allocatedElements);
+    if (!value)
+        return NULL;
+    valueRepr = PyObject_Repr(value);
+    Py_DECREF(value);
+    if (!valueRepr)
+        return NULL;
+    format = cxString_FromAscii("<%s.%s with value %s>");
+    if (!format) {
+        Py_DECREF(valueRepr);
+        return NULL;
+    }
+    if (GetModuleAndName(Py_TYPE(var), &module, &name) < 0) {
+        Py_DECREF(valueRepr);
+        Py_DECREF(format);
+        return NULL;
+    }
+    formatArgs = PyTuple_Pack(3, module, name, valueRepr);
+    Py_DECREF(module);
+    Py_DECREF(name);
+    Py_DECREF(valueRepr);
+    if (!formatArgs) {
+        Py_DECREF(format);
+        return NULL;
+    }
+    result = cxString_Format(format, formatArgs);
+    Py_DECREF(format);
+    Py_DECREF(formatArgs);
+    return result;
+}
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/cx_Oracle.c b/desktop/core/ext-py/cx_Oracle-5.1.2/cx_Oracle.c
new file mode 100644
index 0000000..6483462
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/cx_Oracle.c
@@ -0,0 +1,576 @@
+//-----------------------------------------------------------------------------
+// cx_Oracle.c
+//   Shared library for use by Python.
+//-----------------------------------------------------------------------------
+
+#include <Python.h>
+#include <datetime.h>
+#include <structmember.h>
+#include <time.h>
+#include <oci.h>
+#include <orid.h>
+#include <xa.h>
+
+// define what version of Oracle we are building
+#ifdef OCI_ATTR_MODULE
+#define ORACLE_10G
+#endif
+#ifdef OCI_MAJOR_VERSION
+#define ORACLE_10GR2
+#endif
+#ifdef OCI_ATTR_CONNECTION_CLASS
+#define ORACLE_11G
+#endif
+
+// PY_LONG_LONG was called LONG_LONG before Python 2.3
+#ifndef PY_LONG_LONG
+#define PY_LONG_LONG LONG_LONG
+#endif
+
+// define Py_ssize_t for versions before Python 2.5
+#if PY_VERSION_HEX < 0x02050000
+typedef int Py_ssize_t;
+#define PY_SSIZE_T_MAX INT_MAX
+#define PY_SSIZE_T_MIN INT_MIN
+#endif
+
+// define T_BOOL for versions before Python 2.5
+#ifndef T_BOOL
+#define T_BOOL                  T_INT
+#endif
+
+// define Py_TYPE for versions before Python 2.6
+#ifndef Py_TYPE
+#define Py_TYPE(ob)             (((PyObject*)(ob))->ob_type)
+#endif
+
+// define PyVarObject_HEAD_INIT for versions before Python 2.6
+#ifndef PyVarObject_HEAD_INIT
+#define PyVarObject_HEAD_INIT(type, size) \
+        PyObject_HEAD_INIT(type) size,
+#endif
+
+// define PyInt_* macros for Python 3.x
+#ifndef PyInt_Check
+#define PyInt_Check             PyLong_Check
+#define PyInt_FromLong          PyLong_FromLong
+#define PyInt_AsLong            PyLong_AsLong
+#define PyInt_Type              PyLong_Type
+#endif
+
+// use the bytes methods in cx_Oracle and define them as the equivalent string
+// type methods as is done in Python 2.6
+#ifndef PyBytes_Check
+    #define PyBytes_Type                PyString_Type
+    #define PyBytes_AS_STRING           PyString_AS_STRING
+    #define PyBytes_GET_SIZE            PyString_GET_SIZE
+    #define PyBytes_Check               PyString_Check
+    #define PyBytes_Format              PyString_Format
+    #define PyBytes_FromString          PyString_FromString
+    #define PyBytes_FromStringAndSize   PyString_FromStringAndSize
+#endif
+
+// define types and methods for strings and binary data
+#if PY_MAJOR_VERSION >= 3
+    #define cxBinary_Type               PyBytes_Type
+    #define cxBinary_Check              PyBytes_Check
+    #define cxString_Type               &PyUnicode_Type
+    #define cxString_Format             PyUnicode_Format
+    #define cxString_Check              PyUnicode_Check
+    #define cxString_GetSize            PyUnicode_GET_SIZE
+#else
+    #define cxBinary_Type               PyBuffer_Type
+    #define cxBinary_Check              PyBuffer_Check
+    #define cxString_Type               &PyBytes_Type
+    #define cxString_Format             PyBytes_Format
+    #define cxString_Check              PyBytes_Check
+    #define cxString_GetSize            PyBytes_GET_SIZE
+#endif
+
+// define string type and methods
+#if PY_MAJOR_VERSION >= 3
+    #define cxString_FromAscii(str) \
+        PyUnicode_DecodeASCII(str, strlen(str), NULL)
+    #define cxString_FromEncodedString(buffer, numBytes, encoding) \
+        PyUnicode_Decode(buffer, numBytes, encoding, NULL)
+#else
+    #define cxString_FromAscii(str) \
+        PyBytes_FromString(str)
+    #define cxString_FromEncodedString(buffer, numBytes, encoding) \
+        PyBytes_FromStringAndSize(buffer, numBytes)
+#endif
+
+// define base exception
+#if PY_MAJOR_VERSION >= 3
+#define CXORA_BASE_EXCEPTION    NULL
+#define CXORA_TYPE_ERROR        "expecting string or bytes object"
+#else
+#define CXORA_BASE_EXCEPTION    PyExc_StandardError
+#define CXORA_TYPE_ERROR        "expecting string, unicode or buffer object"
+#endif
+
+// define macro for adding OCI constants
+#define ADD_OCI_CONSTANT(x) \
+    if (PyModule_AddIntConstant(module, #x, OCI_ ##x) < 0) \
+        return NULL;
+
+// define macro for adding type objects
+#define ADD_TYPE_OBJECT(name, type) \
+    Py_INCREF(type); \
+    if (PyModule_AddObject(module, name, (PyObject*) type) < 0) \
+        return NULL;
+
+// define macros for making types ready
+#define MAKE_TYPE_READY(type) \
+    if (PyType_Ready(type) < 0) \
+        return NULL;
+#define MAKE_VARIABLE_TYPE_READY(type) \
+    (type)->tp_base = &g_BaseVarType;  \
+    MAKE_TYPE_READY(type)
+
+// define macros to get the build version as a string and the driver name
+#define xstr(s)                 str(s)
+#define str(s)                  #s
+#define BUILD_VERSION_STRING    xstr(BUILD_VERSION)
+#define DRIVER_NAME             "cx_Oracle-"BUILD_VERSION_STRING
+
+#include "Buffer.c"
+
+//-----------------------------------------------------------------------------
+// Globals
+//-----------------------------------------------------------------------------
+static PyObject *g_WarningException = NULL;
+static PyObject *g_ErrorException = NULL;
+static PyObject *g_InterfaceErrorException = NULL;
+static PyObject *g_DatabaseErrorException = NULL;
+static PyObject *g_DataErrorException = NULL;
+static PyObject *g_OperationalErrorException = NULL;
+static PyObject *g_IntegrityErrorException = NULL;
+static PyObject *g_InternalErrorException = NULL;
+static PyObject *g_ProgrammingErrorException = NULL;
+static PyObject *g_NotSupportedErrorException = NULL;
+static PyTypeObject *g_DateTimeType = NULL;
+static PyTypeObject *g_DecimalType = NULL;
+
+
+//-----------------------------------------------------------------------------
+// SetException()
+//   Create an exception and set it in the provided dictionary.
+//-----------------------------------------------------------------------------
+static int SetException(
+    PyObject *module,                   // module object
+    PyObject **exception,               // exception to create
+    char *name,                         // name of the exception
+    PyObject *baseException)            // exception to base exception on
+{
+    char buffer[100];
+
+    sprintf(buffer, "cx_Oracle.%s", name);
+    *exception = PyErr_NewException(buffer, baseException, NULL);
+    if (!*exception)
+        return -1;
+    return PyModule_AddObject(module, name, *exception);
+}
+
+
+//-----------------------------------------------------------------------------
+// GetModuleAndName()
+//   Return the module and name for the type.
+//-----------------------------------------------------------------------------
+static int GetModuleAndName(
+    PyTypeObject *type,                 // type to get module/name for
+    PyObject **module,                  // name of module
+    PyObject **name)                    // name of type
+{
+    *module = PyObject_GetAttrString( (PyObject*) type, "__module__");
+    if (!*module)
+        return -1;
+    *name = PyObject_GetAttrString( (PyObject*) type, "__name__");
+    if (!*name) {
+        Py_DECREF(*module);
+        return -1;
+    }
+    return 0;
+}
+
+
+#include "Environment.c"
+#include "SessionPool.c"
+
+
+//-----------------------------------------------------------------------------
+// MakeDSN()
+//   Make a data source name given the host port and SID.
+//-----------------------------------------------------------------------------
+static PyObject* MakeDSN(
+    PyObject* self,                     // passthrough argument
+    PyObject* args,                     // arguments to function
+    PyObject* keywordArgs)              // keyword arguments
+{
+    static char *keywordList[] = { "host", "port", "sid", "service_name",
+            NULL };
+    PyObject *hostObj, *portObj, *sidObj, *serviceNameObj, *connectDataObj;
+    PyObject *format, *result, *formatArgs;
+
+    // parse arguments
+    sidObj = serviceNameObj = NULL;
+    if (!PyArg_ParseTupleAndKeywords(args, keywordArgs, "OO|OO", keywordList,
+            &hostObj, &portObj, &sidObj, &serviceNameObj))
+        return NULL;
+    if (sidObj) {
+        connectDataObj = sidObj;
+        format = cxString_FromAscii("(DESCRIPTION=(ADDRESS_LIST=(ADDRESS="
+                "(PROTOCOL=TCP)(HOST=%s)(PORT=%s)))(CONNECT_DATA=(SID=%s)))");
+    } else {
+        connectDataObj = serviceNameObj;
+        format = cxString_FromAscii("(DESCRIPTION=(ADDRESS_LIST=(ADDRESS="
+                "(PROTOCOL=TCP)(HOST=%s)(PORT=%s)))(CONNECT_DATA="
+                "(SERVICE_NAME=%s)))");
+    }
+    if (!format)
+        return NULL;
+    formatArgs = PyTuple_Pack(3, hostObj, portObj, connectDataObj);
+    if (!formatArgs) {
+        Py_DECREF(format);
+        return NULL;
+    }
+    result = cxString_Format(format, formatArgs);
+    Py_DECREF(format);
+    Py_DECREF(formatArgs);
+    return result;
+}
+
+
+#ifdef ORACLE_10GR2
+//-----------------------------------------------------------------------------
+// ClientVersion()
+//   Return the version of the Oracle client being used as a 5-tuple.
+//-----------------------------------------------------------------------------
+static PyObject* ClientVersion(
+    PyObject* self,                     // passthrough argument
+    PyObject* args)                     // arguments to function
+{
+    sword majorVersion, minorVersion, updateNum, patchNum, portUpdateNum;
+
+    OCIClientVersion(&majorVersion, &minorVersion, &updateNum,
+            &patchNum, &portUpdateNum);
+    return Py_BuildValue("(iiiii)", majorVersion, minorVersion, updateNum,
+            patchNum, portUpdateNum);
+}
+#endif
+
+
+//-----------------------------------------------------------------------------
+// Time()
+//   Returns a time value suitable for binding.
+//-----------------------------------------------------------------------------
+static PyObject* Time(
+    PyObject* self,                     // passthrough argument
+    PyObject* args)                     // arguments to function
+{
+    PyErr_SetString(g_NotSupportedErrorException,
+            "Oracle does not support time only variables");
+    return NULL;
+}
+
+
+//-----------------------------------------------------------------------------
+// TimeFromTicks()
+//   Returns a time value suitable for binding.
+//-----------------------------------------------------------------------------
+static PyObject* TimeFromTicks(
+    PyObject* self,                     // passthrough argument
+    PyObject* args)                     // arguments to function
+{
+    PyErr_SetString(g_NotSupportedErrorException,
+            "Oracle does not support time only variables");
+    return NULL;
+}
+
+
+//-----------------------------------------------------------------------------
+// DateFromTicks()
+//   Returns a date value suitable for binding.
+//-----------------------------------------------------------------------------
+static PyObject* DateFromTicks(
+    PyObject* self,                     // passthrough argument
+    PyObject* args)                     // arguments to function
+{
+    return PyDate_FromTimestamp(args);
+}
+
+
+//-----------------------------------------------------------------------------
+// TimestampFromTicks()
+//   Returns a date value suitable for binding.
+//-----------------------------------------------------------------------------
+static PyObject* TimestampFromTicks(
+    PyObject* self,                     // passthrough argument
+    PyObject* args)                     // arguments to function
+{
+    return PyDateTime_FromTimestamp(args);
+}
+
+
+//-----------------------------------------------------------------------------
+//   Declaration of methods supported by this module
+//-----------------------------------------------------------------------------
+static PyMethodDef g_ModuleMethods[] = {
+    { "makedsn", (PyCFunction) MakeDSN, METH_VARARGS | METH_KEYWORDS },
+    { "Time", (PyCFunction) Time, METH_VARARGS },
+    { "DateFromTicks", (PyCFunction) DateFromTicks, METH_VARARGS },
+    { "TimeFromTicks", (PyCFunction) TimeFromTicks, METH_VARARGS },
+    { "TimestampFromTicks", (PyCFunction) TimestampFromTicks, METH_VARARGS },
+#ifdef ORACLE_10GR2
+    { "clientversion", (PyCFunction) ClientVersion, METH_NOARGS },
+#endif
+    { NULL }
+};
+
+
+#if PY_MAJOR_VERSION >= 3
+//-----------------------------------------------------------------------------
+//   Declaration of module definition for Python 3.x.
+//-----------------------------------------------------------------------------
+static struct PyModuleDef g_ModuleDef = {
+    PyModuleDef_HEAD_INIT,
+    "cx_Oracle",
+    NULL,
+    -1,
+    g_ModuleMethods,                       // methods
+    NULL,                                  // m_reload
+    NULL,                                  // traverse
+    NULL,                                  // clear
+    NULL                                   // free
+};
+#endif
+
+
+//-----------------------------------------------------------------------------
+// Module_Initialize()
+//   Initialization routine for the module.
+//-----------------------------------------------------------------------------
+static PyObject *Module_Initialize(void)
+{
+    PyObject *module;
+
+#ifdef WITH_THREAD
+    PyEval_InitThreads();
+#endif
+
+    // import the datetime module for datetime support
+    PyDateTime_IMPORT;
+    if (PyErr_Occurred())
+        return NULL;
+
+    // import the decimal module for decimal support
+    module = PyImport_ImportModule("decimal");
+    if (!module)
+        return NULL;
+    g_DecimalType = (PyTypeObject*) PyObject_GetAttrString(module, "Decimal");
+    if (!g_DecimalType)
+        return NULL;
+
+    // prepare the types for use by the module
+    MAKE_TYPE_READY(&g_ConnectionType);
+    MAKE_TYPE_READY(&g_CursorType);
+    MAKE_TYPE_READY(&g_ErrorType);
+    MAKE_TYPE_READY(&g_SessionPoolType);
+    MAKE_TYPE_READY(&g_EnvironmentType);
+    MAKE_TYPE_READY(&g_ObjectTypeType);
+    MAKE_TYPE_READY(&g_ObjectAttributeType);
+    MAKE_TYPE_READY(&g_ExternalLobVarType);
+    MAKE_TYPE_READY(&g_ExternalObjectVarType);
+#ifdef ORACLE_10GR2
+    MAKE_TYPE_READY(&g_SubscriptionType);
+    MAKE_TYPE_READY(&g_MessageType);
+    MAKE_TYPE_READY(&g_MessageTableType);
+    MAKE_TYPE_READY(&g_MessageRowType);
+#endif
+    MAKE_VARIABLE_TYPE_READY(&g_StringVarType);
+    MAKE_VARIABLE_TYPE_READY(&g_FixedCharVarType);
+    MAKE_VARIABLE_TYPE_READY(&g_RowidVarType);
+    MAKE_VARIABLE_TYPE_READY(&g_BinaryVarType);
+    MAKE_VARIABLE_TYPE_READY(&g_LongStringVarType);
+    MAKE_VARIABLE_TYPE_READY(&g_LongBinaryVarType);
+    MAKE_VARIABLE_TYPE_READY(&g_NumberVarType);
+    MAKE_VARIABLE_TYPE_READY(&g_DateTimeVarType);
+    MAKE_VARIABLE_TYPE_READY(&g_TimestampVarType);
+    MAKE_VARIABLE_TYPE_READY(&g_CLOBVarType);
+    MAKE_VARIABLE_TYPE_READY(&g_BLOBVarType);
+    MAKE_VARIABLE_TYPE_READY(&g_BFILEVarType);
+    MAKE_VARIABLE_TYPE_READY(&g_CursorVarType);
+    MAKE_VARIABLE_TYPE_READY(&g_ObjectVarType);
+#if PY_MAJOR_VERSION < 3
+    MAKE_VARIABLE_TYPE_READY(&g_UnicodeVarType);
+    MAKE_VARIABLE_TYPE_READY(&g_FixedUnicodeVarType);
+    MAKE_VARIABLE_TYPE_READY(&g_LongUnicodeVarType);
+#endif
+    MAKE_VARIABLE_TYPE_READY(&g_NCLOBVarType);
+#ifdef SQLT_BFLOAT
+    MAKE_VARIABLE_TYPE_READY(&g_NativeFloatVarType);
+#endif
+    MAKE_VARIABLE_TYPE_READY(&g_IntervalVarType);
+
+    // initialize module and retrieve the dictionary
+#if PY_MAJOR_VERSION >= 3
+    module = PyModule_Create(&g_ModuleDef);
+#else
+    module = Py_InitModule("cx_Oracle", g_ModuleMethods);
+#endif
+    if (!module)
+        return NULL;
+
+    // create exception object and add it to the dictionary
+    if (SetException(module, &g_WarningException,
+            "Warning", CXORA_BASE_EXCEPTION) < 0)
+        return NULL;
+    if (SetException(module, &g_ErrorException,
+            "Error", CXORA_BASE_EXCEPTION) < 0)
+        return NULL;
+    if (SetException(module, &g_InterfaceErrorException,
+            "InterfaceError", g_ErrorException) < 0)
+        return NULL;
+    if (SetException(module, &g_DatabaseErrorException,
+            "DatabaseError", g_ErrorException) < 0)
+        return NULL;
+    if (SetException(module, &g_DataErrorException,
+            "DataError", g_DatabaseErrorException) < 0)
+        return NULL;
+    if (SetException(module, &g_OperationalErrorException,
+            "OperationalError", g_DatabaseErrorException) < 0)
+        return NULL;
+    if (SetException(module, &g_IntegrityErrorException,
+            "IntegrityError", g_DatabaseErrorException) < 0)
+        return NULL;
+    if (SetException(module, &g_InternalErrorException,
+            "InternalError", g_DatabaseErrorException) < 0)
+        return NULL;
+    if (SetException(module, &g_ProgrammingErrorException,
+            "ProgrammingError", g_DatabaseErrorException) < 0)
+        return NULL;
+    if (SetException(module, &g_NotSupportedErrorException,
+            "NotSupportedError", g_DatabaseErrorException) < 0)
+        return NULL;
+
+    // set up the types that are available
+    ADD_TYPE_OBJECT("Binary", &cxBinary_Type)
+    ADD_TYPE_OBJECT("Connection", &g_ConnectionType)
+    ADD_TYPE_OBJECT("Cursor", &g_CursorType)
+    ADD_TYPE_OBJECT("Timestamp", PyDateTimeAPI->DateTimeType)
+    ADD_TYPE_OBJECT("Date", PyDateTimeAPI->DateType)
+    ADD_TYPE_OBJECT("SessionPool", &g_SessionPoolType)
+    ADD_TYPE_OBJECT("_Error", &g_ErrorType)
+
+    // the name "connect" is required by the DB API
+    ADD_TYPE_OBJECT("connect", &g_ConnectionType)
+
+    // create the basic data types for setting input sizes
+    ADD_TYPE_OBJECT("BINARY", &g_BinaryVarType)
+    ADD_TYPE_OBJECT("BFILE", &g_BFILEVarType)
+    ADD_TYPE_OBJECT("BLOB", &g_BLOBVarType)
+    ADD_TYPE_OBJECT("CLOB", &g_CLOBVarType)
+    ADD_TYPE_OBJECT("CURSOR", &g_CursorVarType)
+    ADD_TYPE_OBJECT("OBJECT", &g_ObjectVarType)
+    ADD_TYPE_OBJECT("DATETIME", &g_DateTimeVarType)
+    ADD_TYPE_OBJECT("FIXED_CHAR", &g_FixedCharVarType)
+#if PY_MAJOR_VERSION < 3
+    ADD_TYPE_OBJECT("FIXED_UNICODE", &g_FixedUnicodeVarType)
+    ADD_TYPE_OBJECT("UNICODE", &g_UnicodeVarType)
+    ADD_TYPE_OBJECT("LONG_UNICODE", &g_LongUnicodeVarType)
+#endif
+    ADD_TYPE_OBJECT("INTERVAL", &g_IntervalVarType)
+    ADD_TYPE_OBJECT("LOB", &g_ExternalLobVarType)
+    ADD_TYPE_OBJECT("LONG_BINARY", &g_LongBinaryVarType)
+    ADD_TYPE_OBJECT("LONG_STRING", &g_LongStringVarType)
+    ADD_TYPE_OBJECT("NCLOB", &g_NCLOBVarType)
+    ADD_TYPE_OBJECT("NUMBER", &g_NumberVarType)
+    ADD_TYPE_OBJECT("ROWID", &g_RowidVarType)
+    ADD_TYPE_OBJECT("STRING", &g_StringVarType)
+    ADD_TYPE_OBJECT("TIMESTAMP", &g_TimestampVarType)
+#ifdef SQLT_BFLOAT
+    ADD_TYPE_OBJECT("NATIVE_FLOAT", &g_NativeFloatVarType)
+#endif
+
+    // create constants required by Python DB API 2.0
+    if (PyModule_AddStringConstant(module, "apilevel", "2.0") < 0)
+        return NULL;
+    if (PyModule_AddIntConstant(module, "threadsafety", 2) < 0)
+        return NULL;
+    if (PyModule_AddStringConstant(module, "paramstyle", "named") < 0)
+        return NULL;
+
+    // add version and build time for easier support
+    if (PyModule_AddStringConstant(module, "version",
+            BUILD_VERSION_STRING) < 0)
+        return NULL;
+    if (PyModule_AddStringConstant(module, "buildtime",
+            __DATE__ " " __TIME__) < 0)
+        return NULL;
+
+    // add constants for registering callbacks
+    ADD_OCI_CONSTANT(SYSDBA)
+    ADD_OCI_CONSTANT(SYSOPER)
+    ADD_OCI_CONSTANT(FNCODE_BINDBYNAME)
+    ADD_OCI_CONSTANT(FNCODE_BINDBYPOS)
+    ADD_OCI_CONSTANT(FNCODE_DEFINEBYPOS)
+    ADD_OCI_CONSTANT(FNCODE_STMTEXECUTE)
+    ADD_OCI_CONSTANT(FNCODE_STMTFETCH)
+    ADD_OCI_CONSTANT(FNCODE_STMTPREPARE)
+    ADD_OCI_CONSTANT(UCBTYPE_ENTRY)
+    ADD_OCI_CONSTANT(UCBTYPE_EXIT)
+    ADD_OCI_CONSTANT(UCBTYPE_REPLACE)
+    ADD_OCI_CONSTANT(SPOOL_ATTRVAL_WAIT)
+    ADD_OCI_CONSTANT(SPOOL_ATTRVAL_NOWAIT)
+    ADD_OCI_CONSTANT(SPOOL_ATTRVAL_FORCEGET)
+#ifdef ORACLE_10GR2
+    ADD_OCI_CONSTANT(PRELIM_AUTH)
+    ADD_OCI_CONSTANT(DBSHUTDOWN_ABORT)
+    ADD_OCI_CONSTANT(DBSHUTDOWN_FINAL)
+    ADD_OCI_CONSTANT(DBSHUTDOWN_IMMEDIATE)
+    ADD_OCI_CONSTANT(DBSHUTDOWN_TRANSACTIONAL)
+    ADD_OCI_CONSTANT(DBSHUTDOWN_TRANSACTIONAL_LOCAL)
+    ADD_OCI_CONSTANT(EVENT_NONE)
+    ADD_OCI_CONSTANT(EVENT_STARTUP)
+    ADD_OCI_CONSTANT(EVENT_SHUTDOWN)
+    ADD_OCI_CONSTANT(EVENT_SHUTDOWN_ANY)
+    ADD_OCI_CONSTANT(EVENT_DEREG)
+    ADD_OCI_CONSTANT(EVENT_OBJCHANGE)
+    ADD_OCI_CONSTANT(OPCODE_ALLOPS)
+    ADD_OCI_CONSTANT(OPCODE_ALLROWS)
+    ADD_OCI_CONSTANT(OPCODE_INSERT)
+    ADD_OCI_CONSTANT(OPCODE_UPDATE)
+    ADD_OCI_CONSTANT(OPCODE_DELETE)
+    ADD_OCI_CONSTANT(OPCODE_ALTER)
+    ADD_OCI_CONSTANT(OPCODE_DROP)
+    ADD_OCI_CONSTANT(SUBSCR_NAMESPACE_DBCHANGE)
+    ADD_OCI_CONSTANT(SUBSCR_PROTO_OCI)
+    ADD_OCI_CONSTANT(SUBSCR_PROTO_MAIL)
+    ADD_OCI_CONSTANT(SUBSCR_PROTO_SERVER)
+    ADD_OCI_CONSTANT(SUBSCR_PROTO_HTTP)
+#endif
+#ifdef ORACLE_11G
+    ADD_OCI_CONSTANT(ATTR_PURITY_DEFAULT)
+    ADD_OCI_CONSTANT(ATTR_PURITY_NEW)
+    ADD_OCI_CONSTANT(ATTR_PURITY_SELF)
+#endif
+
+    return module;
+}
+
+
+//-----------------------------------------------------------------------------
+// Start routine for the module.
+//-----------------------------------------------------------------------------
+#if PY_MAJOR_VERSION >= 3
+PyMODINIT_FUNC PyInit_cx_Oracle(void)
+{
+    return Module_Initialize();
+}
+#else
+void initcx_Oracle(void)
+{
+    Module_Initialize();
+}
+#endif
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/basic.css b/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/basic.css
new file mode 100644
index 0000000..43e8baf
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/basic.css
@@ -0,0 +1,540 @@
+/*
+ * basic.css
+ * ~~~~~~~~~
+ *
+ * Sphinx stylesheet -- basic theme.
+ *
+ * :copyright: Copyright 2007-2011 by the Sphinx team, see AUTHORS.
+ * :license: BSD, see LICENSE for details.
+ *
+ */
+
+/* -- main layout ----------------------------------------------------------- */
+
+div.clearer {
+    clear: both;
+}
+
+/* -- relbar ---------------------------------------------------------------- */
+
+div.related {
+    width: 100%;
+    font-size: 90%;
+}
+
+div.related h3 {
+    display: none;
+}
+
+div.related ul {
+    margin: 0;
+    padding: 0 0 0 10px;
+    list-style: none;
+}
+
+div.related li {
+    display: inline;
+}
+
+div.related li.right {
+    float: right;
+    margin-right: 5px;
+}
+
+/* -- sidebar --------------------------------------------------------------- */
+
+div.sphinxsidebarwrapper {
+    padding: 10px 5px 0 10px;
+}
+
+div.sphinxsidebar {
+    float: left;
+    width: 230px;
+    margin-left: -100%;
+    font-size: 90%;
+}
+
+div.sphinxsidebar ul {
+    list-style: none;
+}
+
+div.sphinxsidebar ul ul,
+div.sphinxsidebar ul.want-points {
+    margin-left: 20px;
+    list-style: square;
+}
+
+div.sphinxsidebar ul ul {
+    margin-top: 0;
+    margin-bottom: 0;
+}
+
+div.sphinxsidebar form {
+    margin-top: 10px;
+}
+
+div.sphinxsidebar input {
+    border: 1px solid #98dbcc;
+    font-family: sans-serif;
+    font-size: 1em;
+}
+
+div.sphinxsidebar #searchbox input[type="text"] {
+    width: 170px;
+}
+
+div.sphinxsidebar #searchbox input[type="submit"] {
+    width: 30px;
+}
+
+img {
+    border: 0;
+}
+
+/* -- search page ----------------------------------------------------------- */
+
+ul.search {
+    margin: 10px 0 0 20px;
+    padding: 0;
+}
+
+ul.search li {
+    padding: 5px 0 5px 20px;
+    background-image: url(file.png);
+    background-repeat: no-repeat;
+    background-position: 0 7px;
+}
+
+ul.search li a {
+    font-weight: bold;
+}
+
+ul.search li div.context {
+    color: #888;
+    margin: 2px 0 0 30px;
+    text-align: left;
+}
+
+ul.keywordmatches li.goodmatch a {
+    font-weight: bold;
+}
+
+/* -- index page ------------------------------------------------------------ */
+
+table.contentstable {
+    width: 90%;
+}
+
+table.contentstable p.biglink {
+    line-height: 150%;
+}
+
+a.biglink {
+    font-size: 1.3em;
+}
+
+span.linkdescr {
+    font-style: italic;
+    padding-top: 5px;
+    font-size: 90%;
+}
+
+/* -- general index --------------------------------------------------------- */
+
+table.indextable {
+    width: 100%;
+}
+
+table.indextable td {
+    text-align: left;
+    vertical-align: top;
+}
+
+table.indextable dl, table.indextable dd {
+    margin-top: 0;
+    margin-bottom: 0;
+}
+
+table.indextable tr.pcap {
+    height: 10px;
+}
+
+table.indextable tr.cap {
+    margin-top: 10px;
+    background-color: #f2f2f2;
+}
+
+img.toggler {
+    margin-right: 3px;
+    margin-top: 3px;
+    cursor: pointer;
+}
+
+div.modindex-jumpbox {
+    border-top: 1px solid #ddd;
+    border-bottom: 1px solid #ddd;
+    margin: 1em 0 1em 0;
+    padding: 0.4em;
+}
+
+div.genindex-jumpbox {
+    border-top: 1px solid #ddd;
+    border-bottom: 1px solid #ddd;
+    margin: 1em 0 1em 0;
+    padding: 0.4em;
+}
+
+/* -- general body styles --------------------------------------------------- */
+
+a.headerlink {
+    visibility: hidden;
+}
+
+h1:hover > a.headerlink,
+h2:hover > a.headerlink,
+h3:hover > a.headerlink,
+h4:hover > a.headerlink,
+h5:hover > a.headerlink,
+h6:hover > a.headerlink,
+dt:hover > a.headerlink {
+    visibility: visible;
+}
+
+div.body p.caption {
+    text-align: inherit;
+}
+
+div.body td {
+    text-align: left;
+}
+
+.field-list ul {
+    padding-left: 1em;
+}
+
+.first {
+    margin-top: 0 !important;
+}
+
+p.rubric {
+    margin-top: 30px;
+    font-weight: bold;
+}
+
+img.align-left, .figure.align-left, object.align-left {
+    clear: left;
+    float: left;
+    margin-right: 1em;
+}
+
+img.align-right, .figure.align-right, object.align-right {
+    clear: right;
+    float: right;
+    margin-left: 1em;
+}
+
+img.align-center, .figure.align-center, object.align-center {
+  display: block;
+  margin-left: auto;
+  margin-right: auto;
+}
+
+.align-left {
+    text-align: left;
+}
+
+.align-center {
+    text-align: center;
+}
+
+.align-right {
+    text-align: right;
+}
+
+/* -- sidebars -------------------------------------------------------------- */
+
+div.sidebar {
+    margin: 0 0 0.5em 1em;
+    border: 1px solid #ddb;
+    padding: 7px 7px 0 7px;
+    background-color: #ffe;
+    width: 40%;
+    float: right;
+}
+
+p.sidebar-title {
+    font-weight: bold;
+}
+
+/* -- topics ---------------------------------------------------------------- */
+
+div.topic {
+    border: 1px solid #ccc;
+    padding: 7px 7px 0 7px;
+    margin: 10px 0 10px 0;
+}
+
+p.topic-title {
+    font-size: 1.1em;
+    font-weight: bold;
+    margin-top: 10px;
+}
+
+/* -- admonitions ----------------------------------------------------------- */
+
+div.admonition {
+    margin-top: 10px;
+    margin-bottom: 10px;
+    padding: 7px;
+}
+
+div.admonition dt {
+    font-weight: bold;
+}
+
+div.admonition dl {
+    margin-bottom: 0;
+}
+
+p.admonition-title {
+    margin: 0px 10px 5px 0px;
+    font-weight: bold;
+}
+
+div.body p.centered {
+    text-align: center;
+    margin-top: 25px;
+}
+
+/* -- tables ---------------------------------------------------------------- */
+
+table.docutils {
+    border: 0;
+    border-collapse: collapse;
+}
+
+table.docutils td, table.docutils th {
+    padding: 1px 8px 1px 5px;
+    border-top: 0;
+    border-left: 0;
+    border-right: 0;
+    border-bottom: 1px solid #aaa;
+}
+
+table.field-list td, table.field-list th {
+    border: 0 !important;
+}
+
+table.footnote td, table.footnote th {
+    border: 0 !important;
+}
+
+th {
+    text-align: left;
+    padding-right: 5px;
+}
+
+table.citation {
+    border-left: solid 1px gray;
+    margin-left: 1px;
+}
+
+table.citation td {
+    border-bottom: none;
+}
+
+/* -- other body styles ----------------------------------------------------- */
+
+ol.arabic {
+    list-style: decimal;
+}
+
+ol.loweralpha {
+    list-style: lower-alpha;
+}
+
+ol.upperalpha {
+    list-style: upper-alpha;
+}
+
+ol.lowerroman {
+    list-style: lower-roman;
+}
+
+ol.upperroman {
+    list-style: upper-roman;
+}
+
+dl {
+    margin-bottom: 15px;
+}
+
+dd p {
+    margin-top: 0px;
+}
+
+dd ul, dd table {
+    margin-bottom: 10px;
+}
+
+dd {
+    margin-top: 3px;
+    margin-bottom: 10px;
+    margin-left: 30px;
+}
+
+dt:target, .highlighted {
+    background-color: #fbe54e;
+}
+
+dl.glossary dt {
+    font-weight: bold;
+    font-size: 1.1em;
+}
+
+.field-list ul {
+    margin: 0;
+    padding-left: 1em;
+}
+
+.field-list p {
+    margin: 0;
+}
+
+.refcount {
+    color: #060;
+}
+
+.optional {
+    font-size: 1.3em;
+}
+
+.versionmodified {
+    font-style: italic;
+}
+
+.system-message {
+    background-color: #fda;
+    padding: 5px;
+    border: 3px solid red;
+}
+
+.footnote:target  {
+    background-color: #ffa;
+}
+
+.line-block {
+    display: block;
+    margin-top: 1em;
+    margin-bottom: 1em;
+}
+
+.line-block .line-block {
+    margin-top: 0;
+    margin-bottom: 0;
+    margin-left: 1.5em;
+}
+
+.guilabel, .menuselection {
+    font-family: sans-serif;
+}
+
+.accelerator {
+    text-decoration: underline;
+}
+
+.classifier {
+    font-style: oblique;
+}
+
+abbr, acronym {
+    border-bottom: dotted 1px;
+    cursor: help;
+}
+
+/* -- code displays --------------------------------------------------------- */
+
+pre {
+    overflow: auto;
+    overflow-y: hidden;  /* fixes display issues on Chrome browsers */
+}
+
+td.linenos pre {
+    padding: 5px 0px;
+    border: 0;
+    background-color: transparent;
+    color: #aaa;
+}
+
+table.highlighttable {
+    margin-left: 0.5em;
+}
+
+table.highlighttable td {
+    padding: 0 0.5em 0 0.5em;
+}
+
+tt.descname {
+    background-color: transparent;
+    font-weight: bold;
+    font-size: 1.2em;
+}
+
+tt.descclassname {
+    background-color: transparent;
+}
+
+tt.xref, a tt {
+    background-color: transparent;
+    font-weight: bold;
+}
+
+h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
+    background-color: transparent;
+}
+
+.viewcode-link {
+    float: right;
+}
+
+.viewcode-back {
+    float: right;
+    font-family: sans-serif;
+}
+
+div.viewcode-block:target {
+    margin: -1px -10px;
+    padding: 0 10px;
+}
+
+/* -- math display ---------------------------------------------------------- */
+
+img.math {
+    vertical-align: middle;
+}
+
+div.body div.math p {
+    text-align: center;
+}
+
+span.eqno {
+    float: right;
+}
+
+/* -- printout stylesheet --------------------------------------------------- */
+
+@media print {
+    div.document,
+    div.documentwrapper,
+    div.bodywrapper {
+        margin: 0 !important;
+        width: 100%;
+    }
+
+    div.sphinxsidebar,
+    div.related,
+    div.footer,
+    #top-link {
+        display: none;
+    }
+}
\ No newline at end of file
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/comment-bright.png b/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/comment-bright.png
new file mode 100644
index 0000000000000000000000000000000000000000..551517b8c83b76f734ff791f847829a760ad1903
GIT binary patch
literal 3500
zcmV;d4O8-oP)<h;3K|Lk000e1NJLTq000mG000mO1^@s6AM^iV000V4X+uL$P-t&-
zZ*ypGa3D!TLm+T+Z)Rz1WdHzp+MQEpR8#2|J@?-9LQ9B%luK_?6$l_wLW_VDktQl3
z2@pz%A)(n7QNa;KMFbnjpojyGj)066Q7jCK3fKqaA)=0hqlk*i`{8?|Yu3E?=FR@K
z*FNX0^PRKL2fzpnmPj*EHGmAMLLL#|gU7_i;p8qrfeIvW01ybXWFd3?BLM*Temp!Y
zBESc}00DT@3kU$fO`E_l9Ebl8>Oz@Z0f2-7z;ux~O9+4z06=<<LZ$#fMgf4Gm?l#I
zpacM5%VT2W08lLeU?+d((*S^-_?deF09%wH6#<};03Z`(h(rKrI{>WDR*FRcSTFz-
zW=q650N5=6FiBTtNC2?60Km==3$g$R3;-}uh=nNt1bYBr$Ri_o0EC$U6h`t_Jn<{8
z5a%iY0C<_QJh>z}MS)ugEpZ1|S1ukX&Pf+56gFW3VVXcL!g-k)GJ!M?;PcD?0HBc-
z5#WRK{dmp}uFlRjj<yb8E$Y7p{~}^y<NoE(t8hR70O53g(f%wivl@Uq27qn;q9yJG
zXkH7Tb@z*AvJXJD0HEpGSMzZAemp!yp^&-R+2!Qq*h<7gTVcvqeg0>{U%*%WZ25jX
z{P*?XzTzZ-GF^d31o+^>%=Ap99M6&ogks$0k4OBs3;+Bb(;~!4V!2o<6ys46agIcq
zjPo+3B8fthDa9qy|77CdEc*jK-!%ZRYCZvbku9iQV*~a}ClFY4z~c7+0P?$U!PF=S
z1Au6Q;m>#f??3%Vpd|o+W=WE9003S@Bra6Svp>fO002awfhw>;8}z{#EWidF!3EsG
z3;bX<ghC|5!a@*23S@vBa$qT}f<h>U&9EIRU@z1_9W=mEXoiz;4lcq~xDGvV5BgyU
zp1~-*fe8db$Osc*A=-!mVv1NJjtCc-h4>-CNCXm#Bp}I%6j35eku^v$Qi@a{RY)E3
zJ#qp$hg?Rwkvqr$GJ^buyhkyVfwECO)C{#lxu`c9ghrwZ&}4KmnvWKso6vH!8a<3Q
zq36)6Xb;+tK10Vaz~~qUGsJ8#F2=(`u{bOVlVi)VBCHIn#u~6ztOL7=^<&SmcLWlF
zMZgI*1b0FpVIDz9SWH+>*hr`#93(Um+6gxa1B6k+CnA%mOSC4s5&6UzVlpv@SV$}*
z))J2sFA#f(L&P^E5{W}HC%KRUNwK6<(h|}}(r!{C=`5+6G)NjFlgZj-YqAG9lq?`C
z$c5yc<iq4M<QwE6@>>d>VnA`E_*3F2Qp##d8RZb=H01_mm@+|Cqnc9PsG(F5HIG_C
zt)aG3uTh7n6Et<2In9F>NlT@zqLtGcXcuVrX|L#Xx)I%#9!{6gSJKPrN9dR61N3(c
z4Tcqi$B1Vr8Jidf7-t!G7_XR2rWw<V8OKyGH!<s&=a~<gZ&g?-wkmuTk;)2{N|h#+
z8!9hUsj8-`-l_{#^Hs}KkEvc$eXd4TGgITK3DlOWRjQp(>r)$3XQ?}=hpK0&Z&W{|
zep&sA23f;Q!%st`QJ}G3<GjWo3u76xcq}1n4XcKAfi=V?vCY|hb}GA={T;iDJ*ugp
zIYTo_Ggq@x^OR;k2jiG=_?&c33Fj!Mm-Bv#-W2aC;wc-ZG)%cMWn62jmY0@Tt4OO+
zt4Hg-Hm>cbou<7-yIK2z4nfCCCtN2-XOGSWo##{8Q{ATurxr~;I`ytDs%xbip}RzP
zziy}Qn4Z2~fSycmr`~zJ=lUFdFa1>gZThG6M+{g7vkW8#+YHVaJjFF}Z#*3@$J_By
zLtVo_L#1JrVVB{Ak-5=4qt!-@Mh}c>#$4kh<88)m#-k<%CLtzEP3leVno>=<rYWX7
zOgl`+&CJcB&DNPUn>{htGUuD;o7bD)w_sX$S}eAxwzy?UvgBH(S?;#HZiQMoS*2K2
zT3xe7t(~nU*1N5{rxB;QPLocnp4Ml>u<^FZwyC!nu;thW+pe~4wtZn|Vi#w(#jeBd
zlf9FDx_yoPJqHbk*$%56S{;6Kv~m<WRyy9A&YbQ)eZ};a=`Uwk&k)bpGvl@s%PGWZ
zol~3BM`ssjxpRZ_h>M9!g3B(KJ}#RZ#@)!h<Vtk)ab4kh()FF2vzx;0sN1jZHtuQe
zhuojcG@mJ+Su=Cc!^lJ6QRUG;3!jxRYu~JXPeV_EXSL@eFJmu}SFP8ux21Qg_hIiB
zKK4FxpW{B`JU8Al-dSJFH^8^Zx64n%Z=PR;-$Q>R|78Dq|Iq-afF%KE1Brn_fm;Im
z_<DRHzm7jT+hz8$+3i7$pt(U6L63s1g5|-jA!x|#kgXy2=a|ls&S?&XP=4sv&<A1W
zVT;3l3@3$$g;$0@j&O)r8qqPAHFwe6Lv!Cm`b3sQ-kWDJPdTqGN;N7zsxE3g+Bdp1
zx<AG)W?9VDSe;l&Y)c$DE-J1zZfw5a{O$9H;+^6P<9ipFFUVbRd7;k2^o6GusV)*M
zI+j38h)y_^@IeqNs1}SR@)LI@jtY6g9l~cKFVQy9h}c71DjrVqNGeTwlI)SZHF+e(
zGo>u$xr8UFki1L{Ox>G0o)(&RAZ;=|I=wN2l97;cLaHH6leTB-XXa*h%dBOEvi`+x
zi?=Txl?TadvyiL>SuF~-LZ;|cS}4~l2eM~nS7yJ>iOM;atDY;(?aZ^v+mJV$@1Ote
z62cPUlD4IWOIIx&SmwQ~YB{nzae3Pc;}r!fhE@iwJh+OsDs9zItL;~pu715HdQEGA
zUct(O!L<Qv>kCy1<%NCg+}G`0PgpNm-?d@-hMgNe6^V+j6x$b<6@S<$+<4_1hi}Ti
zncS4LsjI}fWY1>OX6feMEuLErma3QLmkw?X+1j)X-&VBk_4Y;EFPF_I+q;9dL%E~B
zJh;4Nr^(LEJ3myURP<E(R5tF?-L+xY_-@he8+*L=H0;&eTfF!EKFPk@RRL8^)n?UY
z`$_w=_dl+Qs_FQa`)ysVPHl1R#{<#>{Rblsw%57T)g973R8o)DE9*xN#~;4_o$q%o
z4K@u`jhx2fBXC4{<mvYb-}fF3I@)%Od#vFH(;s#nXB{tULYnfLMw?Tb`&(jLx=+kL
z(bnqTdi+P*9}k=~JXv{4^Hj-c+UbJRlV|eJjGdL8eSR+a++f?HwtMGe&fjVeZ|}Mg
zbm7uP|BL54ygSZZ^0;*JvfJeoSGZT2uR33C>U8Qn{*%*B$Ge=nny$HAYq{=vy|sI0
z_vss+H_qMky?OB#|JK!>IX&II^LlUh#rO5!7TtbwC;iULyV-Xq?ybB}ykGP{?LpZ?
z-G|jbTmIbG@7#ZCz;~eY(cDM(28Dyq{*m>M4?_iynUBkc4TkHUI6gT!;y-fz>HMcd
z&t%Ugo)`Y2{>!cx7B7DI)$7;J(U{Spm-3gBzioV_{p!H$8L!*M!p0uH$#^p{Ui4P`
z?ZJ24cOCDe-w#jZd?0@)|7iKK^;6KN`;!@ylm7$*nDhK&GcDTy000JJOGiWi{{a60
z|De66lK=n!32;bRa{vGf6951U69E94oEQKA00(qQO+^RV2niQ93PPz|JOBU!-bqA3
zR5;6pl1pe^WfX<Kz5jFWy@@exLEFUIU=wPB&uCjMh(#zyMT!)`VL_Y}A)sPOtDxY>
zkSdl!omi0~*ntl;2q{jA^;J@WT8O!=A(Gck8fa>hn{#u{`Ty<UmZ;$48*SK&#a@do
zTxVzB&kXn91MHApZ+y|w(yUuEv9>g)!KXI6l>4dj==iVKK6+%4zaRizy(5eryC3d2
z+5Y_D$4}k5v2=Siw{=O)SWY2HJwR3xX1*M*9G^XQ*TCNXF$Vj(kbMJXK0DaS_Sa^1
z?CEa!cFWDhcwxy%a?i@DN|G6-M#uuWU>lss@I>;$xmQ|`u3f;MQ|<i+pZFzHDa=;|
z5kbrooMO2V416$4J>pYuHxxvMeq4TW;>|7Z2*AsqT=`-1O~nTm6O&pNEK?^cf9CX=
zkq5|qAoE7<gSlXrhR#lIk9r2?Ha9f5_RCesJZPj+QjqAngNL9-76eTdm0)Hf-qX^#
zt+gfcDw~#4X?AfC7ds+_xacq^Xn+ub1&{bp&zq_g3|6vGQel0Rq`s777Og8PQ4EEm
z;v$G0bpwMeQ#1ky7!XWxYTk0mqQ&3+LheIVB)Tz<4W}Y;<cNz7mAU~dz8=MasVArz
z7Oq~c)n;}2;^@@))ar~YI7FQ|=d2Jzp%DsAP-+UqO^!GgM4hRsxme`Vbn^Yk>un3V
z^yy=@%6zqN^x`#qW+;e7j>th{6GV}sf*}g7{(R#T)yg-AZh0C&U;WA`AL$qz8()5^
zGFi2`g&L7!c?x+A2oOaG0c*Bg&YZt8cJ{jq_W{uTdA-<;`@iP$$=$H?gYIYc_q^*$
z#k(Key`d40R3?+GmgK8hHJcwiQ~r4By@w9*PuzR>x3#(F?YW_W5pPc(t(@-Y{psOt
zz2!UE_5S)bLF)<rmD^sL?0WXY#py@is+^|tc+=mv&+)&s9XQ{z^}x9<ibo0nY&!9u
a`ab|E?o=hKA+1LM0000<MNUMnLSTYql%5L!

literal 0
HcmV?d00001

diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/comment-close.png b/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/comment-close.png
new file mode 100644
index 0000000000000000000000000000000000000000..09b54be46da3f0d4a5061da289dc91d8a2cdbc9c
GIT binary patch
literal 3578
zcmV<W4F&RvP)<h;3K|Lk000e1NJLTq000mG000mO1^@s6AM^iV000V4X+uL$P-t&-
zZ*ypGa3D!TLm+T+Z)Rz1WdHzp+MQEpR8#2|J@?-9LQ9B%luK_?6$l_wLW_VDktQl3
z2@pz%A)(n7QNa;KMFbnjpojyGj)066Q7jCK3fKqaA)=0hqlk*i`{8?|Yu3E?=FR@K
z*FNX0^PRKL2fzpnmPj*EHGmAMLLL#|gU7_i;p8qrfeIvW01ybXWFd3?BLM*Temp!Y
zBESc}00DT@3kU$fO`E_l9Ebl8>Oz@Z0f2-7z;ux~O9+4z06=<<LZ$#fMgf4Gm?l#I
zpacM5%VT2W08lLeU?+d((*S^-_?deF09%wH6#<};03Z`(h(rKrI{>WDR*FRcSTFz-
zW=q650N5=6FiBTtNC2?60Km==3$g$R3;-}uh=nNt1bYBr$Ri_o0EC$U6h`t_Jn<{8
z5a%iY0C<_QJh>z}MS)ugEpZ1|S1ukX&Pf+56gFW3VVXcL!g-k)GJ!M?;PcD?0HBc-
z5#WRK{dmp}uFlRjj<yb8E$Y7p{~}^y<NoE(t8hR70O53g(f%wivl@Uq27qn;q9yJG
zXkH7Tb@z*AvJXJD0HEpGSMzZAemp!yp^&-R+2!Qq*h<7gTVcvqeg0>{U%*%WZ25jX
z{P*?XzTzZ-GF^d31o+^>%=Ap99M6&ogks$0k4OBs3;+Bb(;~!4V!2o<6ys46agIcq
zjPo+3B8fthDa9qy|77CdEc*jK-!%ZRYCZvbku9iQV*~a}ClFY4z~c7+0P?$U!PF=S
z1Au6Q;m>#f??3%Vpd|o+W=WE9003S@Bra6Svp>fO002awfhw>;8}z{#EWidF!3EsG
z3;bX<ghC|5!a@*23S@vBa$qT}f<h>U&9EIRU@z1_9W=mEXoiz;4lcq~xDGvV5BgyU
zp1~-*fe8db$Osc*A=-!mVv1NJjtCc-h4>-CNCXm#Bp}I%6j35eku^v$Qi@a{RY)E3
zJ#qp$hg?Rwkvqr$GJ^buyhkyVfwECO)C{#lxu`c9ghrwZ&}4KmnvWKso6vH!8a<3Q
zq36)6Xb;+tK10Vaz~~qUGsJ8#F2=(`u{bOVlVi)VBCHIn#u~6ztOL7=^<&SmcLWlF
zMZgI*1b0FpVIDz9SWH+>*hr`#93(Um+6gxa1B6k+CnA%mOSC4s5&6UzVlpv@SV$}*
z))J2sFA#f(L&P^E5{W}HC%KRUNwK6<(h|}}(r!{C=`5+6G)NjFlgZj-YqAG9lq?`C
z$c5yc<iq4M<QwE6@>>d>VnA`E_*3F2Qp##d8RZb=H01_mm@+|Cqnc9PsG(F5HIG_C
zt)aG3uTh7n6Et<2In9F>NlT@zqLtGcXcuVrX|L#Xx)I%#9!{6gSJKPrN9dR61N3(c
z4Tcqi$B1Vr8Jidf7-t!G7_XR2rWw<V8OKyGH!<s&=a~<gZ&g?-wkmuTk;)2{N|h#+
z8!9hUsj8-`-l_{#^Hs}KkEvc$eXd4TGgITK3DlOWRjQp(>r)$3XQ?}=hpK0&Z&W{|
zep&sA23f;Q!%st`QJ}G3<GjWo3u76xcq}1n4XcKAfi=V?vCY|hb}GA={T;iDJ*ugp
zIYTo_Ggq@x^OR;k2jiG=_?&c33Fj!Mm-Bv#-W2aC;wc-ZG)%cMWn62jmY0@Tt4OO+
zt4Hg-Hm>cbou<7-yIK2z4nfCCCtN2-XOGSWo##{8Q{ATurxr~;I`ytDs%xbip}RzP
zziy}Qn4Z2~fSycmr`~zJ=lUFdFa1>gZThG6M+{g7vkW8#+YHVaJjFF}Z#*3@$J_By
zLtVo_L#1JrVVB{Ak-5=4qt!-@Mh}c>#$4kh<88)m#-k<%CLtzEP3leVno>=<rYWX7
zOgl`+&CJcB&DNPUn>{htGUuD;o7bD)w_sX$S}eAxwzy?UvgBH(S?;#HZiQMoS*2K2
zT3xe7t(~nU*1N5{rxB;QPLocnp4Ml>u<^FZwyC!nu;thW+pe~4wtZn|Vi#w(#jeBd
zlf9FDx_yoPJqHbk*$%56S{;6Kv~m<WRyy9A&YbQ)eZ};a=`Uwk&k)bpGvl@s%PGWZ
zol~3BM`ssjxpRZ_h>M9!g3B(KJ}#RZ#@)!h<Vtk)ab4kh()FF2vzx;0sN1jZHtuQe
zhuojcG@mJ+Su=Cc!^lJ6QRUG;3!jxRYu~JXPeV_EXSL@eFJmu}SFP8ux21Qg_hIiB
zKK4FxpW{B`JU8Al-dSJFH^8^Zx64n%Z=PR;-$Q>R|78Dq|Iq-afF%KE1Brn_fm;Im
z_<DRHzm7jT+hz8$+3i7$pt(U6L63s1g5|-jA!x|#kgXy2=a|ls&S?&XP=4sv&<A1W
zVT;3l3@3$$g;$0@j&O)r8qqPAHFwe6Lv!Cm`b3sQ-kWDJPdTqGN;N7zsxE3g+Bdp1
zx<AG)W?9VDSe;l&Y)c$DE-J1zZfw5a{O$9H;+^6P<9ipFFUVbRd7;k2^o6GusV)*M
zI+j38h)y_^@IeqNs1}SR@)LI@jtY6g9l~cKFVQy9h}c71DjrVqNGeTwlI)SZHF+e(
zGo>u$xr8UFki1L{Ox>G0o)(&RAZ;=|I=wN2l97;cLaHH6leTB-XXa*h%dBOEvi`+x
zi?=Txl?TadvyiL>SuF~-LZ;|cS}4~l2eM~nS7yJ>iOM;atDY;(?aZ^v+mJV$@1Ote
z62cPUlD4IWOIIx&SmwQ~YB{nzae3Pc;}r!fhE@iwJh+OsDs9zItL;~pu715HdQEGA
zUct(O!L<Qv>kCy1<%NCg+}G`0PgpNm-?d@-hMgNe6^V+j6x$b<6@S<$+<4_1hi}Ti
zncS4LsjI}fWY1>OX6feMEuLErma3QLmkw?X+1j)X-&VBk_4Y;EFPF_I+q;9dL%E~B
zJh;4Nr^(LEJ3myURP<E(R5tF?-L+xY_-@he8+*L=H0;&eTfF!EKFPk@RRL8^)n?UY
z`$_w=_dl+Qs_FQa`)ysVPHl1R#{<#>{Rblsw%57T)g973R8o)DE9*xN#~;4_o$q%o
z4K@u`jhx2fBXC4{<mvYb-}fF3I@)%Od#vFH(;s#nXB{tULYnfLMw?Tb`&(jLx=+kL
z(bnqTdi+P*9}k=~JXv{4^Hj-c+UbJRlV|eJjGdL8eSR+a++f?HwtMGe&fjVeZ|}Mg
zbm7uP|BL54ygSZZ^0;*JvfJeoSGZT2uR33C>U8Qn{*%*B$Ge=nny$HAYq{=vy|sI0
z_vss+H_qMky?OB#|JK!>IX&II^LlUh#rO5!7TtbwC;iULyV-Xq?ybB}ykGP{?LpZ?
z-G|jbTmIbG@7#ZCz;~eY(cDM(28Dyq{*m>M4?_iynUBkc4TkHUI6gT!;y-fz>HMcd
z&t%Ugo)`Y2{>!cx7B7DI)$7;J(U{Spm-3gBzioV_{p!H$8L!*M!p0uH$#^p{Ui4P`
z?ZJ24cOCDe-w#jZd?0@)|7iKK^;6KN`;!@ylm7$*nDhK&GcDTy000JJOGiWi{{a60
z|De66lK=n!32;bRa{vGf6951U69E94oEQKA00(qQO+^RV2oe()A>y0J-2easEJ;K`
zR5;6Jl3z%jbr{D#&+mQTbB>-f&3W<<%ayjKi&ZjBc2N<@)`~{dMXWB0(ajbV85_gJ
zf(EU`iek}4Bt%55ix|sVMm1u8KvB#hnmU~_r<<A{rXG*J@B4e7ZVoQ$bM@tc=leWg
z_zHRMKlBH^ZTA9=vi<0{cUBac>Ogd(A5vg_omvd-#L!=(BMV<WoZ(*xK;6sz3?APG
zcYj{<QtPf0x0NL}XG1N{ttd-A<a`SdB!tQDd#`;wb$o04?zTZX57i-0wGVOfU@Z-A
zOg1*x7hI^iHSWzWD!I_IylNyDC~A}_hzJEOaYTB@a<BFruKaNA1Da3Nv>klxVqhdT
zofSj`QA^|)G*lu58>#vhvA)%0Or&dIsb%b)st*L<z&G>V8`ANnOipDbh%_*c7`d6#
z21*z~Xd?ovgf>zq(o0?Et~9ti+pljZC~#_KvJhA>u91WRaq|uqBBKP6V0?p-NL59w
zrK0w($_m#SDPQ!Z$nhd^JO|f+7k5xca94d2OLJ&sSxlB7F%NtrF@@O7WWlkHSDtor
zzD?u;b&KN$*MnHx;JDy9P~G<{4}9__s&MATBV4R+MuA8TjlZ3ye&qZMCUe8ihBnHI
zh<cu?V+7B2@Dd)Idw!sNc!0{Geje#KN_uvJ<mw_#=f2j5&U}U!`mVEDwre?2lz#5^
zs=~DE8u46L<8dUGH2CRK$_ILg-^fs~Fh~08D1{62`b0;o6lbP!qwseDs68;cd&{PE
zr|zj;C&@w&FXd2}ghUEr!{am^X`!n77bFaE!T`sH05ibj&g(xZC-<)(X3PHm^>MSu
zSERHwrmBb$SWVr+)Yk2k^<JQ4@-jvv6nud_Qh(~Kd25GI_WW4}+iN;M{ph=GQ)3I=
z-RI|*t*T}hl*<>FgTMR6mP;@FY2{}BeV|SUo=mNk<-XSOHNErw>s{^rR-bu$@aN7=
zj~-qXcS2!BA*(Q**BOOl{FggkyHdCJi_Fy>?_K+G+DYwIn8`29DYPg&s4$}7D`fv?
zuyJ2sMfJX(I^yrf6u!(~9anf(AqAk&ke}uL0SIb-H!SaDQvd(}07*qoM6N<$g1Ha7
A2LJ#7

literal 0
HcmV?d00001

diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/comment.png b/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/comment.png
new file mode 100644
index 0000000000000000000000000000000000000000..92feb52b8824c6b0f59b658b1196c61de9162a95
GIT binary patch
literal 3445
zcmV-*4T|!KP)<h;3K|Lk000e1NJLTq000mG000mO1^@s6AM^iV000V4X+uL$P-t&-
zZ*ypGa3D!TLm+T+Z)Rz1WdHzp+MQEpR8#2|J@?-9LQ9B%luK_?6$l_wLW_VDktQl3
z2@pz%A)(n7QNa;KMFbnjpojyGj)066Q7jCK3fKqaA)=0hqlk*i`{8?|Yu3E?=FR@K
z*FNX0^PRKL2fzpnmPj*EHGmAMLLL#|gU7_i;p8qrfeIvW01ybXWFd3?BLM*Temp!Y
zBESc}00DT@3kU$fO`E_l9Ebl8>Oz@Z0f2-7z;ux~O9+4z06=<<LZ$#fMgf4Gm?l#I
zpacM5%VT2W08lLeU?+d((*S^-_?deF09%wH6#<};03Z`(h(rKrI{>WDR*FRcSTFz-
zW=q650N5=6FiBTtNC2?60Km==3$g$R3;-}uh=nNt1bYBr$Ri_o0EC$U6h`t_Jn<{8
z5a%iY0C<_QJh>z}MS)ugEpZ1|S1ukX&Pf+56gFW3VVXcL!g-k)GJ!M?;PcD?0HBc-
z5#WRK{dmp}uFlRjj<yb8E$Y7p{~}^y<NoE(t8hR70O53g(f%wivl@Uq27qn;q9yJG
zXkH7Tb@z*AvJXJD0HEpGSMzZAemp!yp^&-R+2!Qq*h<7gTVcvqeg0>{U%*%WZ25jX
z{P*?XzTzZ-GF^d31o+^>%=Ap99M6&ogks$0k4OBs3;+Bb(;~!4V!2o<6ys46agIcq
zjPo+3B8fthDa9qy|77CdEc*jK-!%ZRYCZvbku9iQV*~a}ClFY4z~c7+0P?$U!PF=S
z1Au6Q;m>#f??3%Vpd|o+W=WE9003S@Bra6Svp>fO002awfhw>;8}z{#EWidF!3EsG
z3;bX<ghC|5!a@*23S@vBa$qT}f<h>U&9EIRU@z1_9W=mEXoiz;4lcq~xDGvV5BgyU
zp1~-*fe8db$Osc*A=-!mVv1NJjtCc-h4>-CNCXm#Bp}I%6j35eku^v$Qi@a{RY)E3
zJ#qp$hg?Rwkvqr$GJ^buyhkyVfwECO)C{#lxu`c9ghrwZ&}4KmnvWKso6vH!8a<3Q
zq36)6Xb;+tK10Vaz~~qUGsJ8#F2=(`u{bOVlVi)VBCHIn#u~6ztOL7=^<&SmcLWlF
zMZgI*1b0FpVIDz9SWH+>*hr`#93(Um+6gxa1B6k+CnA%mOSC4s5&6UzVlpv@SV$}*
z))J2sFA#f(L&P^E5{W}HC%KRUNwK6<(h|}}(r!{C=`5+6G)NjFlgZj-YqAG9lq?`C
z$c5yc<iq4M<QwE6@>>d>VnA`E_*3F2Qp##d8RZb=H01_mm@+|Cqnc9PsG(F5HIG_C
zt)aG3uTh7n6Et<2In9F>NlT@zqLtGcXcuVrX|L#Xx)I%#9!{6gSJKPrN9dR61N3(c
z4Tcqi$B1Vr8Jidf7-t!G7_XR2rWw<V8OKyGH!<s&=a~<gZ&g?-wkmuTk;)2{N|h#+
z8!9hUsj8-`-l_{#^Hs}KkEvc$eXd4TGgITK3DlOWRjQp(>r)$3XQ?}=hpK0&Z&W{|
zep&sA23f;Q!%st`QJ}G3<GjWo3u76xcq}1n4XcKAfi=V?vCY|hb}GA={T;iDJ*ugp
zIYTo_Ggq@x^OR;k2jiG=_?&c33Fj!Mm-Bv#-W2aC;wc-ZG)%cMWn62jmY0@Tt4OO+
zt4Hg-Hm>cbou<7-yIK2z4nfCCCtN2-XOGSWo##{8Q{ATurxr~;I`ytDs%xbip}RzP
zziy}Qn4Z2~fSycmr`~zJ=lUFdFa1>gZThG6M+{g7vkW8#+YHVaJjFF}Z#*3@$J_By
zLtVo_L#1JrVVB{Ak-5=4qt!-@Mh}c>#$4kh<88)m#-k<%CLtzEP3leVno>=<rYWX7
zOgl`+&CJcB&DNPUn>{htGUuD;o7bD)w_sX$S}eAxwzy?UvgBH(S?;#HZiQMoS*2K2
zT3xe7t(~nU*1N5{rxB;QPLocnp4Ml>u<^FZwyC!nu;thW+pe~4wtZn|Vi#w(#jeBd
zlf9FDx_yoPJqHbk*$%56S{;6Kv~m<WRyy9A&YbQ)eZ};a=`Uwk&k)bpGvl@s%PGWZ
zol~3BM`ssjxpRZ_h>M9!g3B(KJ}#RZ#@)!h<Vtk)ab4kh()FF2vzx;0sN1jZHtuQe
zhuojcG@mJ+Su=Cc!^lJ6QRUG;3!jxRYu~JXPeV_EXSL@eFJmu}SFP8ux21Qg_hIiB
zKK4FxpW{B`JU8Al-dSJFH^8^Zx64n%Z=PR;-$Q>R|78Dq|Iq-afF%KE1Brn_fm;Im
z_<DRHzm7jT+hz8$+3i7$pt(U6L63s1g5|-jA!x|#kgXy2=a|ls&S?&XP=4sv&<A1W
zVT;3l3@3$$g;$0@j&O)r8qqPAHFwe6Lv!Cm`b3sQ-kWDJPdTqGN;N7zsxE3g+Bdp1
zx<AG)W?9VDSe;l&Y)c$DE-J1zZfw5a{O$9H;+^6P<9ipFFUVbRd7;k2^o6GusV)*M
zI+j38h)y_^@IeqNs1}SR@)LI@jtY6g9l~cKFVQy9h}c71DjrVqNGeTwlI)SZHF+e(
zGo>u$xr8UFki1L{Ox>G0o)(&RAZ;=|I=wN2l97;cLaHH6leTB-XXa*h%dBOEvi`+x
zi?=Txl?TadvyiL>SuF~-LZ;|cS}4~l2eM~nS7yJ>iOM;atDY;(?aZ^v+mJV$@1Ote
z62cPUlD4IWOIIx&SmwQ~YB{nzae3Pc;}r!fhE@iwJh+OsDs9zItL;~pu715HdQEGA
zUct(O!L<Qv>kCy1<%NCg+}G`0PgpNm-?d@-hMgNe6^V+j6x$b<6@S<$+<4_1hi}Ti
zncS4LsjI}fWY1>OX6feMEuLErma3QLmkw?X+1j)X-&VBk_4Y;EFPF_I+q;9dL%E~B
zJh;4Nr^(LEJ3myURP<E(R5tF?-L+xY_-@he8+*L=H0;&eTfF!EKFPk@RRL8^)n?UY
z`$_w=_dl+Qs_FQa`)ysVPHl1R#{<#>{Rblsw%57T)g973R8o)DE9*xN#~;4_o$q%o
z4K@u`jhx2fBXC4{<mvYb-}fF3I@)%Od#vFH(;s#nXB{tULYnfLMw?Tb`&(jLx=+kL
z(bnqTdi+P*9}k=~JXv{4^Hj-c+UbJRlV|eJjGdL8eSR+a++f?HwtMGe&fjVeZ|}Mg
zbm7uP|BL54ygSZZ^0;*JvfJeoSGZT2uR33C>U8Qn{*%*B$Ge=nny$HAYq{=vy|sI0
z_vss+H_qMky?OB#|JK!>IX&II^LlUh#rO5!7TtbwC;iULyV-Xq?ybB}ykGP{?LpZ?
z-G|jbTmIbG@7#ZCz;~eY(cDM(28Dyq{*m>M4?_iynUBkc4TkHUI6gT!;y-fz>HMcd
z&t%Ugo)`Y2{>!cx7B7DI)$7;J(U{Spm-3gBzioV_{p!H$8L!*M!p0uH$#^p{Ui4P`
z?ZJ24cOCDe-w#jZd?0@)|7iKK^;6KN`;!@ylm7$*nDhK&GcDTy000JJOGiWi{{a60
z|De66lK=n!32;bRa{vGf6951U69E94oEQKA00(qQO+^RV2nzr)JMUJvzW@LNr%6OX
zR5;6Zk;`k`RTRfR-*ac2G}PGmXsUu>6ce?Lsn$m^3Q`48f|TwQ+_-Qh=t8Ra7nE)y
zf@08(pjZ@22^EVjG*%30TJRMkBUC$WqZ73uoiv&J=APqX;!v%AH}`Vx`999MVjXwy
z{f1-vh8P<=plv&cZ>p5jjX~Vt&W0e)wpw1RFRuRd<fFsqxCjCmeC`BuuieS`d(-_p
zhOc?QyHdKP@VLS~$T=u-02Ik|rdDsfzWbrA`$zZ9F|l_L?cV<*2VWfE)2X=~n|r&z
z?CvU+n?)w)pyeTtfPjd=gD96w=ayEV-*xZ6tDOXI9h~VO8S4AN;j*>DkwlKb01tp5
zP=trFN0gH^|L4jJkB{6sCV;Q!ewpg-D&4cza%GQ*b>R*=34#dW;ek`FEiB(vnw+U#
zpOX5UMJBhIN&;D1!yQoIAySC!9zqJmmfoJqmQp}p&h*HTfMh~u9rKic2oz3sNM^#F
zBIq*MRLbsMt%y<?k&=)Mv-S*Xrzb+-2G$laiDYC!VQYmiM8vX02!#ofL^6@gNG42R
zCQOD2Bt>{EHj8}LeqUUvoxf0=kqji62>ne+U`d#%J)abyK&Y`=eD%oA!36<)baZyK
zXJh5im6umkS|_CSGXips$nI)oBHXojzBzyY_M5K*uvb0_9viuBVyV%5VtJ*Am1ag#
zczbv4B?u8j68iOz<+)nDu^oWnL+$_G{PZOCcOGQ?!1VCefves~rfpaEZs-PdVYMiV
z98ElaJ2}7f;htSXFY#Zv<K>?__sQeckE^HV<BJp3BNLx}`@rGJ?{6RfV0u%h;o7(P
zUmQL<J9zB7lcztQsUCUr-KmZLe0}DUe*1S}Z7naJt~VZ@J-#sd>{ItO=)2hMQs=(_
Xn!ZpXD%P(H00000NkvXXu0mjf<Culu

literal 0
HcmV?d00001

diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/default.css b/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/default.css
new file mode 100644
index 0000000..21f3f50
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/default.css
@@ -0,0 +1,256 @@
+/*
+ * default.css_t
+ * ~~~~~~~~~~~~~
+ *
+ * Sphinx stylesheet -- default theme.
+ *
+ * :copyright: Copyright 2007-2011 by the Sphinx team, see AUTHORS.
+ * :license: BSD, see LICENSE for details.
+ *
+ */
+
+@import url("basic.css");
+
+/* -- page layout ----------------------------------------------------------- */
+
+body {
+    font-family: sans-serif;
+    font-size: 100%;
+    background-color: #11303d;
+    color: #000;
+    margin: 0;
+    padding: 0;
+}
+
+div.document {
+    background-color: #1c4e63;
+}
+
+div.documentwrapper {
+    float: left;
+    width: 100%;
+}
+
+div.bodywrapper {
+    margin: 0 0 0 230px;
+}
+
+div.body {
+    background-color: #ffffff;
+    color: #000000;
+    padding: 0 20px 30px 20px;
+}
+
+div.footer {
+    color: #ffffff;
+    width: 100%;
+    padding: 9px 0 9px 0;
+    text-align: center;
+    font-size: 75%;
+}
+
+div.footer a {
+    color: #ffffff;
+    text-decoration: underline;
+}
+
+div.related {
+    background-color: #133f52;
+    line-height: 30px;
+    color: #ffffff;
+}
+
+div.related a {
+    color: #ffffff;
+}
+
+div.sphinxsidebar {
+}
+
+div.sphinxsidebar h3 {
+    font-family: 'Trebuchet MS', sans-serif;
+    color: #ffffff;
+    font-size: 1.4em;
+    font-weight: normal;
+    margin: 0;
+    padding: 0;
+}
+
+div.sphinxsidebar h3 a {
+    color: #ffffff;
+}
+
+div.sphinxsidebar h4 {
+    font-family: 'Trebuchet MS', sans-serif;
+    color: #ffffff;
+    font-size: 1.3em;
+    font-weight: normal;
+    margin: 5px 0 0 0;
+    padding: 0;
+}
+
+div.sphinxsidebar p {
+    color: #ffffff;
+}
+
+div.sphinxsidebar p.topless {
+    margin: 5px 10px 10px 10px;
+}
+
+div.sphinxsidebar ul {
+    margin: 10px;
+    padding: 0;
+    color: #ffffff;
+}
+
+div.sphinxsidebar a {
+    color: #98dbcc;
+}
+
+div.sphinxsidebar input {
+    border: 1px solid #98dbcc;
+    font-family: sans-serif;
+    font-size: 1em;
+}
+
+
+
+/* -- hyperlink styles ------------------------------------------------------ */
+
+a {
+    color: #355f7c;
+    text-decoration: none;
+}
+
+a:visited {
+    color: #355f7c;
+    text-decoration: none;
+}
+
+a:hover {
+    text-decoration: underline;
+}
+
+
+
+/* -- body styles ----------------------------------------------------------- */
+
+div.body h1,
+div.body h2,
+div.body h3,
+div.body h4,
+div.body h5,
+div.body h6 {
+    font-family: 'Trebuchet MS', sans-serif;
+    background-color: #f2f2f2;
+    font-weight: normal;
+    color: #20435c;
+    border-bottom: 1px solid #ccc;
+    margin: 20px -20px 10px -20px;
+    padding: 3px 0 3px 10px;
+}
+
+div.body h1 { margin-top: 0; font-size: 200%; }
+div.body h2 { font-size: 160%; }
+div.body h3 { font-size: 140%; }
+div.body h4 { font-size: 120%; }
+div.body h5 { font-size: 110%; }
+div.body h6 { font-size: 100%; }
+
+a.headerlink {
+    color: #c60f0f;
+    font-size: 0.8em;
+    padding: 0 4px 0 4px;
+    text-decoration: none;
+}
+
+a.headerlink:hover {
+    background-color: #c60f0f;
+    color: white;
+}
+
+div.body p, div.body dd, div.body li {
+    text-align: justify;
+    line-height: 130%;
+}
+
+div.admonition p.admonition-title + p {
+    display: inline;
+}
+
+div.admonition p {
+    margin-bottom: 5px;
+}
+
+div.admonition pre {
+    margin-bottom: 5px;
+}
+
+div.admonition ul, div.admonition ol {
+    margin-bottom: 5px;
+}
+
+div.note {
+    background-color: #eee;
+    border: 1px solid #ccc;
+}
+
+div.seealso {
+    background-color: #ffc;
+    border: 1px solid #ff6;
+}
+
+div.topic {
+    background-color: #eee;
+}
+
+div.warning {
+    background-color: #ffe4e4;
+    border: 1px solid #f66;
+}
+
+p.admonition-title {
+    display: inline;
+}
+
+p.admonition-title:after {
+    content: ":";
+}
+
+pre {
+    padding: 5px;
+    background-color: #eeffcc;
+    color: #333333;
+    line-height: 120%;
+    border: 1px solid #ac9;
+    border-left: none;
+    border-right: none;
+}
+
+tt {
+    background-color: #ecf0f3;
+    padding: 0 1px 0 1px;
+    font-size: 0.95em;
+}
+
+th {
+    background-color: #ede;
+}
+
+.warning tt {
+    background: #efc2c2;
+}
+
+.note tt {
+    background: #d6d6d6;
+}
+
+.viewcode-back {
+    font-family: sans-serif;
+}
+
+div.viewcode-block:target {
+    background-color: #f4debf;
+    border-top: 1px solid #ac9;
+    border-bottom: 1px solid #ac9;
+}
\ No newline at end of file
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/doctools.js b/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/doctools.js
new file mode 100644
index 0000000..d4619fd
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/doctools.js
@@ -0,0 +1,247 @@
+/*
+ * doctools.js
+ * ~~~~~~~~~~~
+ *
+ * Sphinx JavaScript utilities for all documentation.
+ *
+ * :copyright: Copyright 2007-2011 by the Sphinx team, see AUTHORS.
+ * :license: BSD, see LICENSE for details.
+ *
+ */
+
+/**
+ * select a different prefix for underscore
+ */
+$u = _.noConflict();
+
+/**
+ * make the code below compatible with browsers without
+ * an installed firebug like debugger
+if (!window.console || !console.firebug) {
+  var names = ["log", "debug", "info", "warn", "error", "assert", "dir",
+    "dirxml", "group", "groupEnd", "time", "timeEnd", "count", "trace",
+    "profile", "profileEnd"];
+  window.console = {};
+  for (var i = 0; i < names.length; ++i)
+    window.console[names[i]] = function() {};
+}
+ */
+
+/**
+ * small helper function to urldecode strings
+ */
+jQuery.urldecode = function(x) {
+  return decodeURIComponent(x).replace(/\+/g, ' ');
+}
+
+/**
+ * small helper function to urlencode strings
+ */
+jQuery.urlencode = encodeURIComponent;
+
+/**
+ * This function returns the parsed url parameters of the
+ * current request. Multiple values per key are supported,
+ * it will always return arrays of strings for the value parts.
+ */
+jQuery.getQueryParameters = function(s) {
+  if (typeof s == 'undefined')
+    s = document.location.search;
+  var parts = s.substr(s.indexOf('?') + 1).split('&');
+  var result = {};
+  for (var i = 0; i < parts.length; i++) {
+    var tmp = parts[i].split('=', 2);
+    var key = jQuery.urldecode(tmp[0]);
+    var value = jQuery.urldecode(tmp[1]);
+    if (key in result)
+      result[key].push(value);
+    else
+      result[key] = [value];
+  }
+  return result;
+};
+
+/**
+ * small function to check if an array contains
+ * a given item.
+ */
+jQuery.contains = function(arr, item) {
+  for (var i = 0; i < arr.length; i++) {
+    if (arr[i] == item)
+      return true;
+  }
+  return false;
+};
+
+/**
+ * highlight a given string on a jquery object by wrapping it in
+ * span elements with the given class name.
+ */
+jQuery.fn.highlightText = function(text, className) {
+  function highlight(node) {
+    if (node.nodeType == 3) {
+      var val = node.nodeValue;
+      var pos = val.toLowerCase().indexOf(text);
+      if (pos >= 0 && !jQuery(node.parentNode).hasClass(className)) {
+        var span = document.createElement("span");
+        span.className = className;
+        span.appendChild(document.createTextNode(val.substr(pos, text.length)));
+        node.parentNode.insertBefore(span, node.parentNode.insertBefore(
+          document.createTextNode(val.substr(pos + text.length)),
+          node.nextSibling));
+        node.nodeValue = val.substr(0, pos);
+      }
+    }
+    else if (!jQuery(node).is("button, select, textarea")) {
+      jQuery.each(node.childNodes, function() {
+        highlight(this);
+      });
+    }
+  }
+  return this.each(function() {
+    highlight(this);
+  });
+};
+
+/**
+ * Small JavaScript module for the documentation.
+ */
+var Documentation = {
+
+  init : function() {
+    this.fixFirefoxAnchorBug();
+    this.highlightSearchWords();
+    this.initIndexTable();
+  },
+
+  /**
+   * i18n support
+   */
+  TRANSLATIONS : {},
+  PLURAL_EXPR : function(n) { return n == 1 ? 0 : 1; },
+  LOCALE : 'unknown',
+
+  // gettext and ngettext don't access this so that the functions
+  // can safely bound to a different name (_ = Documentation.gettext)
+  gettext : function(string) {
+    var translated = Documentation.TRANSLATIONS[string];
+    if (typeof translated == 'undefined')
+      return string;
+    return (typeof translated == 'string') ? translated : translated[0];
+  },
+
+  ngettext : function(singular, plural, n) {
+    var translated = Documentation.TRANSLATIONS[singular];
+    if (typeof translated == 'undefined')
+      return (n == 1) ? singular : plural;
+    return translated[Documentation.PLURALEXPR(n)];
+  },
+
+  addTranslations : function(catalog) {
+    for (var key in catalog.messages)
+      this.TRANSLATIONS[key] = catalog.messages[key];
+    this.PLURAL_EXPR = new Function('n', 'return +(' + catalog.plural_expr + ')');
+    this.LOCALE = catalog.locale;
+  },
+
+  /**
+   * add context elements like header anchor links
+   */
+  addContextElements : function() {
+    $('div[id] > :header:first').each(function() {
+      $('<a class="headerlink">\u00B6</a>').
+      attr('href', '#' + this.id).
+      attr('title', _('Permalink to this headline')).
+      appendTo(this);
+    });
+    $('dt[id]').each(function() {
+      $('<a class="headerlink">\u00B6</a>').
+      attr('href', '#' + this.id).
+      attr('title', _('Permalink to this definition')).
+      appendTo(this);
+    });
+  },
+
+  /**
+   * workaround a firefox stupidity
+   */
+  fixFirefoxAnchorBug : function() {
+    if (document.location.hash && $.browser.mozilla)
+      window.setTimeout(function() {
+        document.location.href += '';
+      }, 10);
+  },
+
+  /**
+   * highlight the search words provided in the url in the text
+   */
+  highlightSearchWords : function() {
+    var params = $.getQueryParameters();
+    var terms = (params.highlight) ? params.highlight[0].split(/\s+/) : [];
+    if (terms.length) {
+      var body = $('div.body');
+      window.setTimeout(function() {
+        $.each(terms, function() {
+          body.highlightText(this.toLowerCase(), 'highlighted');
+        });
+      }, 10);
+      $('<p class="highlight-link"><a href="javascript:Documentation.' +
+        'hideSearchWords()">' + _('Hide Search Matches') + '</a></p>')
+          .appendTo($('#searchbox'));
+    }
+  },
+
+  /**
+   * init the domain index toggle buttons
+   */
+  initIndexTable : function() {
+    var togglers = $('img.toggler').click(function() {
+      var src = $(this).attr('src');
+      var idnum = $(this).attr('id').substr(7);
+      $('tr.cg-' + idnum).toggle();
+      if (src.substr(-9) == 'minus.png')
+        $(this).attr('src', src.substr(0, src.length-9) + 'plus.png');
+      else
+        $(this).attr('src', src.substr(0, src.length-8) + 'minus.png');
+    }).css('display', '');
+    if (DOCUMENTATION_OPTIONS.COLLAPSE_INDEX) {
+        togglers.click();
+    }
+  },
+
+  /**
+   * helper function to hide the search marks again
+   */
+  hideSearchWords : function() {
+    $('#searchbox .highlight-link').fadeOut(300);
+    $('span.highlighted').removeClass('highlighted');
+  },
+
+  /**
+   * make the url absolute
+   */
+  makeURL : function(relativeURL) {
+    return DOCUMENTATION_OPTIONS.URL_ROOT + '/' + relativeURL;
+  },
+
+  /**
+   * get the current relative url
+   */
+  getCurrentURL : function() {
+    var path = document.location.pathname;
+    var parts = path.split(/\//);
+    $.each(DOCUMENTATION_OPTIONS.URL_ROOT.split(/\//), function() {
+      if (this == '..')
+        parts.pop();
+    });
+    var url = parts.join('/');
+    return path.substring(url.lastIndexOf('/') + 1, path.length - 1);
+  }
+};
+
+// quick alias for translations
+_ = Documentation.gettext;
+
+$(document).ready(function() {
+  Documentation.init();
+});
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/down-pressed.png b/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/down-pressed.png
new file mode 100644
index 0000000000000000000000000000000000000000..6f7ad782782e4f8e39b0c6e15c7344700cdd2527
GIT binary patch
literal 368
zcmeAS@N?(olHy`uVBq!ia0vp^0wB!61|;P_|4#%`jKx9jP7LeL$-D$|*pj^6U4S$Y
z{B+)352QE?JR*yM+OLB!qm#z$3ZNi+iKnkC`z>}Z23@f-Ava~9&<9T!#}JFtXD=!G
zGdl{fK6ro2OGiOl+hKvH6i=D3%%Y^j`yIkRn!8O>@bG)IQR0{Kf+mxNd=_WScA8u_
z3;8(7x2){m9`nt+U(Nab&1G)!{`SPVpDX$w8McLTzAJ39wprG3p4XLq$06M`%}2Yk
zRPPsb<eOBuJzzJtaBsDHruj&MO}CkI9@oM{u93MWs^*chA=$e7rUh<GoTlU#?wGGz
z*_K*(>ES*dnYm1wkGL;iioAUB*Or2kz6(-M_r_#Me-<g+a_(*JjN&U*z02OX#~$%(
z6#3ZLekrlFz3AKX``cC&$K^ccDa(j?XLM8b!=w9;#rq6gQ-fH_ZUFtx;OXk;vd$@?
F2>`{mj$Z%(

literal 0
HcmV?d00001

diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/down.png b/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/down.png
new file mode 100644
index 0000000000000000000000000000000000000000..3003a88770de3977d47a2ba69893436a2860f9e7
GIT binary patch
literal 363
zcmeAS@N?(olHy`uVBq!ia0vp^0wB!61|;P_|4#%`jKx9jP7LeL$-D$|*pj^6U4S$Y
z{B+)352QE?JR*yM+OLB!qm#z$3ZNi+iKnkC`z>}xaV3tUZ$qnrLa#kt978NlpS`ru
z&)HFc^}^>{UOEce+71h5nn>6&w6A!ie<Ab_+oUB-{c$>Nbu1wh)UGh{8~et^#oZ1#
z>T7oM=FZ~xXWnTo{qnXm$ZLOlqGswI_m2{XwVK)IJmBjW{J3-B3x@C=M{ShWt#<pw
z+y29?H~r3Ic5@5&Ry#4lLZ0TfgDn1@D+(sA?zAeN{MGSl)<;wKn{AaYbJjJ-X;-#|
zTD>fYS9M?R;8K$~YwlIqwf>VA7q=YKcwf2DS4Zj5inDKXXB1zl=(YO3ST6~rDq)&z
z*o>z)=hxrfG-cDBW0G$!?6{M<$@{_4{m1o%Ub!naEtn|@^frU1tDnm{r-UW|!^@B8

literal 0
HcmV?d00001

diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/file.png b/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/file.png
new file mode 100644
index 0000000000000000000000000000000000000000..d18082e397e7e54f20721af768c4c2983258f1b4
GIT binary patch
literal 392
zcmeAS@N?(olHy`uVBq!ia0vp^0wB!61|;P_|4#%`Y)RhkE)4%caKYZ?lYt_f1s;*b
z3=G`DAk4@xYmNj^kiEpy*OmP$Hy<xMqvo~{83qPMQBN1g5R21mCvNmQ;vmqr-?K<V
zU4kQ;TS-l(;>OL$D9)yc9|lc|nKf<9@eUiWd>3GuTC!a5vdfWYEazjncPj5ZQX%+1
zt8B*4=d)!cdDz4wr^#OMYfqGz$1LDFF>|#>*O?<HXR=hzTfCLc!DZQEwT&GKx6RhQ
zo))l-Eh>AGil(WEs?wLLy{Gj2J_@opDm%`dlax3yA*@*N$G&*ukFv>P8+2CBWO(qz
zD0k1@kN>hhb1_6`&wrCswzINE(evt-5C1B^STi2@P<G<wTm_|``|B7th)+*kX+Pib
z*M}qKJqcfCd_2yP9QQKsOSb)vO-|{xyF)I_-07lx@Zvo#rJ$WIhTj)AKCk@a+86Xn
ktMBn$GheTj#{azILsys7Te#I72ZkAgr>mdKI;Vst0PQB6!2kdN

literal 0
HcmV?d00001

diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/jquery.js b/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/jquery.js
new file mode 100644
index 0000000..7c24308
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/jquery.js
@@ -0,0 +1,154 @@
+/*!
+ * jQuery JavaScript Library v1.4.2
+ * http://jquery.com/
+ *
+ * Copyright 2010, John Resig
+ * Dual licensed under the MIT or GPL Version 2 licenses.
+ * http://jquery.org/license
+ *
+ * Includes Sizzle.js
+ * http://sizzlejs.com/
+ * Copyright 2010, The Dojo Foundation
+ * Released under the MIT, BSD, and GPL Licenses.
+ *
+ * Date: Sat Feb 13 22:33:48 2010 -0500
+ */
+(function(A,w){function ma(){if(!c.isReady){try{s.documentElement.doScroll("left")}catch(a){setTimeout(ma,1);return}c.ready()}}function Qa(a,b){b.src?c.ajax({url:b.src,async:false,dataType:"script"}):c.globalEval(b.text||b.textContent||b.innerHTML||"");b.parentNode&&b.parentNode.removeChild(b)}function X(a,b,d,f,e,j){var i=a.length;if(typeof b==="object"){for(var o in b)X(a,o,b[o],f,e,d);return a}if(d!==w){f=!j&&f&&c.isFunction(d);for(o=0;o<i;o++)e(a[o],b,f?d.call(a[o],o,e(a[o],b)):d,j);return a}return i?
+e(a[0],b):w}function J(){return(new Date).getTime()}function Y(){return false}function Z(){return true}function na(a,b,d){d[0].type=a;return c.event.handle.apply(b,d)}function oa(a){var b,d=[],f=[],e=arguments,j,i,o,k,n,r;i=c.data(this,"events");if(!(a.liveFired===this||!i||!i.live||a.button&&a.type==="click")){a.liveFired=this;var u=i.live.slice(0);for(k=0;k<u.length;k++){i=u[k];i.origType.replace(O,"")===a.type?f.push(i.selector):u.splice(k--,1)}j=c(a.target).closest(f,a.currentTarget);n=0;for(r=
+j.length;n<r;n++)for(k=0;k<u.length;k++){i=u[k];if(j[n].selector===i.selector){o=j[n].elem;f=null;if(i.preType==="mouseenter"||i.preType==="mouseleave")f=c(a.relatedTarget).closest(i.selector)[0];if(!f||f!==o)d.push({elem:o,handleObj:i})}}n=0;for(r=d.length;n<r;n++){j=d[n];a.currentTarget=j.elem;a.data=j.handleObj.data;a.handleObj=j.handleObj;if(j.handleObj.origHandler.apply(j.elem,e)===false){b=false;break}}return b}}function pa(a,b){return"live."+(a&&a!=="*"?a+".":"")+b.replace(/\./g,"`").replace(/ /g,
+"&")}function qa(a){return!a||!a.parentNode||a.parentNode.nodeType===11}function ra(a,b){var d=0;b.each(function(){if(this.nodeName===(a[d]&&a[d].nodeName)){var f=c.data(a[d++]),e=c.data(this,f);if(f=f&&f.events){delete e.handle;e.events={};for(var j in f)for(var i in f[j])c.event.add(this,j,f[j][i],f[j][i].data)}}})}function sa(a,b,d){var f,e,j;b=b&&b[0]?b[0].ownerDocument||b[0]:s;if(a.length===1&&typeof a[0]==="string"&&a[0].length<512&&b===s&&!ta.test(a[0])&&(c.support.checkClone||!ua.test(a[0]))){e=
+true;if(j=c.fragments[a[0]])if(j!==1)f=j}if(!f){f=b.createDocumentFragment();c.clean(a,b,f,d)}if(e)c.fragments[a[0]]=j?f:1;return{fragment:f,cacheable:e}}function K(a,b){var d={};c.each(va.concat.apply([],va.slice(0,b)),function(){d[this]=a});return d}function wa(a){return"scrollTo"in a&&a.document?a:a.nodeType===9?a.defaultView||a.parentWindow:false}var c=function(a,b){return new c.fn.init(a,b)},Ra=A.jQuery,Sa=A.$,s=A.document,T,Ta=/^[^<]*(<[\w\W]+>)[^>]*$|^#([\w-]+)$/,Ua=/^.[^:#\[\.,]*$/,Va=/\S/,
+Wa=/^(\s|\u00A0)+|(\s|\u00A0)+$/g,Xa=/^<(\w+)\s*\/?>(?:<\/\1>)?$/,P=navigator.userAgent,xa=false,Q=[],L,$=Object.prototype.toString,aa=Object.prototype.hasOwnProperty,ba=Array.prototype.push,R=Array.prototype.slice,ya=Array.prototype.indexOf;c.fn=c.prototype={init:function(a,b){var d,f;if(!a)return this;if(a.nodeType){this.context=this[0]=a;this.length=1;return this}if(a==="body"&&!b){this.context=s;this[0]=s.body;this.selector="body";this.length=1;return this}if(typeof a==="string")if((d=Ta.exec(a))&&
+(d[1]||!b))if(d[1]){f=b?b.ownerDocument||b:s;if(a=Xa.exec(a))if(c.isPlainObject(b)){a=[s.createElement(a[1])];c.fn.attr.call(a,b,true)}else a=[f.createElement(a[1])];else{a=sa([d[1]],[f]);a=(a.cacheable?a.fragment.cloneNode(true):a.fragment).childNodes}return c.merge(this,a)}else{if(b=s.getElementById(d[2])){if(b.id!==d[2])return T.find(a);this.length=1;this[0]=b}this.context=s;this.selector=a;return this}else if(!b&&/^\w+$/.test(a)){this.selector=a;this.context=s;a=s.getElementsByTagName(a);return c.merge(this,
+a)}else return!b||b.jquery?(b||T).find(a):c(b).find(a);else if(c.isFunction(a))return T.ready(a);if(a.selector!==w){this.selector=a.selector;this.context=a.context}return c.makeArray(a,this)},selector:"",jquery:"1.4.2",length:0,size:function(){return this.length},toArray:function(){return R.call(this,0)},get:function(a){return a==null?this.toArray():a<0?this.slice(a)[0]:this[a]},pushStack:function(a,b,d){var f=c();c.isArray(a)?ba.apply(f,a):c.merge(f,a);f.prevObject=this;f.context=this.context;if(b===
+"find")f.selector=this.selector+(this.selector?" ":"")+d;else if(b)f.selector=this.selector+"."+b+"("+d+")";return f},each:function(a,b){return c.each(this,a,b)},ready:function(a){c.bindReady();if(c.isReady)a.call(s,c);else Q&&Q.push(a);return this},eq:function(a){return a===-1?this.slice(a):this.slice(a,+a+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(R.apply(this,arguments),"slice",R.call(arguments).join(","))},map:function(a){return this.pushStack(c.map(this,
+function(b,d){return a.call(b,d,b)}))},end:function(){return this.prevObject||c(null)},push:ba,sort:[].sort,splice:[].splice};c.fn.init.prototype=c.fn;c.extend=c.fn.extend=function(){var a=arguments[0]||{},b=1,d=arguments.length,f=false,e,j,i,o;if(typeof a==="boolean"){f=a;a=arguments[1]||{};b=2}if(typeof a!=="object"&&!c.isFunction(a))a={};if(d===b){a=this;--b}for(;b<d;b++)if((e=arguments[b])!=null)for(j in e){i=a[j];o=e[j];if(a!==o)if(f&&o&&(c.isPlainObject(o)||c.isArray(o))){i=i&&(c.isPlainObject(i)||
+c.isArray(i))?i:c.isArray(o)?[]:{};a[j]=c.extend(f,i,o)}else if(o!==w)a[j]=o}return a};c.extend({noConflict:function(a){A.$=Sa;if(a)A.jQuery=Ra;return c},isReady:false,ready:function(){if(!c.isReady){if(!s.body)return setTimeout(c.ready,13);c.isReady=true;if(Q){for(var a,b=0;a=Q[b++];)a.call(s,c);Q=null}c.fn.triggerHandler&&c(s).triggerHandler("ready")}},bindReady:function(){if(!xa){xa=true;if(s.readyState==="complete")return c.ready();if(s.addEventListener){s.addEventListener("DOMContentLoaded",
+L,false);A.addEventListener("load",c.ready,false)}else if(s.attachEvent){s.attachEvent("onreadystatechange",L);A.attachEvent("onload",c.ready);var a=false;try{a=A.frameElement==null}catch(b){}s.documentElement.doScroll&&a&&ma()}}},isFunction:function(a){return $.call(a)==="[object Function]"},isArray:function(a){return $.call(a)==="[object Array]"},isPlainObject:function(a){if(!a||$.call(a)!=="[object Object]"||a.nodeType||a.setInterval)return false;if(a.constructor&&!aa.call(a,"constructor")&&!aa.call(a.constructor.prototype,
+"isPrototypeOf"))return false;var b;for(b in a);return b===w||aa.call(a,b)},isEmptyObject:function(a){for(var b in a)return false;return true},error:function(a){throw a;},parseJSON:function(a){if(typeof a!=="string"||!a)return null;a=c.trim(a);if(/^[\],:{}\s]*$/.test(a.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,"@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,"]").replace(/(?:^|:|,)(?:\s*\[)+/g,"")))return A.JSON&&A.JSON.parse?A.JSON.parse(a):(new Function("return "+
+a))();else c.error("Invalid JSON: "+a)},noop:function(){},globalEval:function(a){if(a&&Va.test(a)){var b=s.getElementsByTagName("head")[0]||s.documentElement,d=s.createElement("script");d.type="text/javascript";if(c.support.scriptEval)d.appendChild(s.createTextNode(a));else d.text=a;b.insertBefore(d,b.firstChild);b.removeChild(d)}},nodeName:function(a,b){return a.nodeName&&a.nodeName.toUpperCase()===b.toUpperCase()},each:function(a,b,d){var f,e=0,j=a.length,i=j===w||c.isFunction(a);if(d)if(i)for(f in a){if(b.apply(a[f],
+d)===false)break}else for(;e<j;){if(b.apply(a[e++],d)===false)break}else if(i)for(f in a){if(b.call(a[f],f,a[f])===false)break}else for(d=a[0];e<j&&b.call(d,e,d)!==false;d=a[++e]);return a},trim:function(a){return(a||"").replace(Wa,"")},makeArray:function(a,b){b=b||[];if(a!=null)a.length==null||typeof a==="string"||c.isFunction(a)||typeof a!=="function"&&a.setInterval?ba.call(b,a):c.merge(b,a);return b},inArray:function(a,b){if(b.indexOf)return b.indexOf(a);for(var d=0,f=b.length;d<f;d++)if(b[d]===
+a)return d;return-1},merge:function(a,b){var d=a.length,f=0;if(typeof b.length==="number")for(var e=b.length;f<e;f++)a[d++]=b[f];else for(;b[f]!==w;)a[d++]=b[f++];a.length=d;return a},grep:function(a,b,d){for(var f=[],e=0,j=a.length;e<j;e++)!d!==!b(a[e],e)&&f.push(a[e]);return f},map:function(a,b,d){for(var f=[],e,j=0,i=a.length;j<i;j++){e=b(a[j],j,d);if(e!=null)f[f.length]=e}return f.concat.apply([],f)},guid:1,proxy:function(a,b,d){if(arguments.length===2)if(typeof b==="string"){d=a;a=d[b];b=w}else if(b&&
+!c.isFunction(b)){d=b;b=w}if(!b&&a)b=function(){return a.apply(d||this,arguments)};if(a)b.guid=a.guid=a.guid||b.guid||c.guid++;return b},uaMatch:function(a){a=a.toLowerCase();a=/(webkit)[ \/]([\w.]+)/.exec(a)||/(opera)(?:.*version)?[ \/]([\w.]+)/.exec(a)||/(msie) ([\w.]+)/.exec(a)||!/compatible/.test(a)&&/(mozilla)(?:.*? rv:([\w.]+))?/.exec(a)||[];return{browser:a[1]||"",version:a[2]||"0"}},browser:{}});P=c.uaMatch(P);if(P.browser){c.browser[P.browser]=true;c.browser.version=P.version}if(c.browser.webkit)c.browser.safari=
+true;if(ya)c.inArray=function(a,b){return ya.call(b,a)};T=c(s);if(s.addEventListener)L=function(){s.removeEventListener("DOMContentLoaded",L,false);c.ready()};else if(s.attachEvent)L=function(){if(s.readyState==="complete"){s.detachEvent("onreadystatechange",L);c.ready()}};(function(){c.support={};var a=s.documentElement,b=s.createElement("script"),d=s.createElement("div"),f="script"+J();d.style.display="none";d.innerHTML="   <link/><table></table><a href='/a' style='color:red;float:left;opacity:.55;'>a</a><input type='checkbox'/>";
+var e=d.getElementsByTagName("*"),j=d.getElementsByTagName("a")[0];if(!(!e||!e.length||!j)){c.support={leadingWhitespace:d.firstChild.nodeType===3,tbody:!d.getElementsByTagName("tbody").length,htmlSerialize:!!d.getElementsByTagName("link").length,style:/red/.test(j.getAttribute("style")),hrefNormalized:j.getAttribute("href")==="/a",opacity:/^0.55$/.test(j.style.opacity),cssFloat:!!j.style.cssFloat,checkOn:d.getElementsByTagName("input")[0].value==="on",optSelected:s.createElement("select").appendChild(s.createElement("option")).selected,
+parentNode:d.removeChild(d.appendChild(s.createElement("div"))).parentNode===null,deleteExpando:true,checkClone:false,scriptEval:false,noCloneEvent:true,boxModel:null};b.type="text/javascript";try{b.appendChild(s.createTextNode("window."+f+"=1;"))}catch(i){}a.insertBefore(b,a.firstChild);if(A[f]){c.support.scriptEval=true;delete A[f]}try{delete b.test}catch(o){c.support.deleteExpando=false}a.removeChild(b);if(d.attachEvent&&d.fireEvent){d.attachEvent("onclick",function k(){c.support.noCloneEvent=
+false;d.detachEvent("onclick",k)});d.cloneNode(true).fireEvent("onclick")}d=s.createElement("div");d.innerHTML="<input type='radio' name='radiotest' checked='checked'/>";a=s.createDocumentFragment();a.appendChild(d.firstChild);c.support.checkClone=a.cloneNode(true).cloneNode(true).lastChild.checked;c(function(){var k=s.createElement("div");k.style.width=k.style.paddingLeft="1px";s.body.appendChild(k);c.boxModel=c.support.boxModel=k.offsetWidth===2;s.body.removeChild(k).style.display="none"});a=function(k){var n=
+s.createElement("div");k="on"+k;var r=k in n;if(!r){n.setAttribute(k,"return;");r=typeof n[k]==="function"}return r};c.support.submitBubbles=a("submit");c.support.changeBubbles=a("change");a=b=d=e=j=null}})();c.props={"for":"htmlFor","class":"className",readonly:"readOnly",maxlength:"maxLength",cellspacing:"cellSpacing",rowspan:"rowSpan",colspan:"colSpan",tabindex:"tabIndex",usemap:"useMap",frameborder:"frameBorder"};var G="jQuery"+J(),Ya=0,za={};c.extend({cache:{},expando:G,noData:{embed:true,object:true,
+applet:true},data:function(a,b,d){if(!(a.nodeName&&c.noData[a.nodeName.toLowerCase()])){a=a==A?za:a;var f=a[G],e=c.cache;if(!f&&typeof b==="string"&&d===w)return null;f||(f=++Ya);if(typeof b==="object"){a[G]=f;e[f]=c.extend(true,{},b)}else if(!e[f]){a[G]=f;e[f]={}}a=e[f];if(d!==w)a[b]=d;return typeof b==="string"?a[b]:a}},removeData:function(a,b){if(!(a.nodeName&&c.noData[a.nodeName.toLowerCase()])){a=a==A?za:a;var d=a[G],f=c.cache,e=f[d];if(b){if(e){delete e[b];c.isEmptyObject(e)&&c.removeData(a)}}else{if(c.support.deleteExpando)delete a[c.expando];
+else a.removeAttribute&&a.removeAttribute(c.expando);delete f[d]}}}});c.fn.extend({data:function(a,b){if(typeof a==="undefined"&&this.length)return c.data(this[0]);else if(typeof a==="object")return this.each(function(){c.data(this,a)});var d=a.split(".");d[1]=d[1]?"."+d[1]:"";if(b===w){var f=this.triggerHandler("getData"+d[1]+"!",[d[0]]);if(f===w&&this.length)f=c.data(this[0],a);return f===w&&d[1]?this.data(d[0]):f}else return this.trigger("setData"+d[1]+"!",[d[0],b]).each(function(){c.data(this,
+a,b)})},removeData:function(a){return this.each(function(){c.removeData(this,a)})}});c.extend({queue:function(a,b,d){if(a){b=(b||"fx")+"queue";var f=c.data(a,b);if(!d)return f||[];if(!f||c.isArray(d))f=c.data(a,b,c.makeArray(d));else f.push(d);return f}},dequeue:function(a,b){b=b||"fx";var d=c.queue(a,b),f=d.shift();if(f==="inprogress")f=d.shift();if(f){b==="fx"&&d.unshift("inprogress");f.call(a,function(){c.dequeue(a,b)})}}});c.fn.extend({queue:function(a,b){if(typeof a!=="string"){b=a;a="fx"}if(b===
+w)return c.queue(this[0],a);return this.each(function(){var d=c.queue(this,a,b);a==="fx"&&d[0]!=="inprogress"&&c.dequeue(this,a)})},dequeue:function(a){return this.each(function(){c.dequeue(this,a)})},delay:function(a,b){a=c.fx?c.fx.speeds[a]||a:a;b=b||"fx";return this.queue(b,function(){var d=this;setTimeout(function(){c.dequeue(d,b)},a)})},clearQueue:function(a){return this.queue(a||"fx",[])}});var Aa=/[\n\t]/g,ca=/\s+/,Za=/\r/g,$a=/href|src|style/,ab=/(button|input)/i,bb=/(button|input|object|select|textarea)/i,
+cb=/^(a|area)$/i,Ba=/radio|checkbox/;c.fn.extend({attr:function(a,b){return X(this,a,b,true,c.attr)},removeAttr:function(a){return this.each(function(){c.attr(this,a,"");this.nodeType===1&&this.removeAttribute(a)})},addClass:function(a){if(c.isFunction(a))return this.each(function(n){var r=c(this);r.addClass(a.call(this,n,r.attr("class")))});if(a&&typeof a==="string")for(var b=(a||"").split(ca),d=0,f=this.length;d<f;d++){var e=this[d];if(e.nodeType===1)if(e.className){for(var j=" "+e.className+" ",
+i=e.className,o=0,k=b.length;o<k;o++)if(j.indexOf(" "+b[o]+" ")<0)i+=" "+b[o];e.className=c.trim(i)}else e.className=a}return this},removeClass:function(a){if(c.isFunction(a))return this.each(function(k){var n=c(this);n.removeClass(a.call(this,k,n.attr("class")))});if(a&&typeof a==="string"||a===w)for(var b=(a||"").split(ca),d=0,f=this.length;d<f;d++){var e=this[d];if(e.nodeType===1&&e.className)if(a){for(var j=(" "+e.className+" ").replace(Aa," "),i=0,o=b.length;i<o;i++)j=j.replace(" "+b[i]+" ",
+" ");e.className=c.trim(j)}else e.className=""}return this},toggleClass:function(a,b){var d=typeof a,f=typeof b==="boolean";if(c.isFunction(a))return this.each(function(e){var j=c(this);j.toggleClass(a.call(this,e,j.attr("class"),b),b)});return this.each(function(){if(d==="string")for(var e,j=0,i=c(this),o=b,k=a.split(ca);e=k[j++];){o=f?o:!i.hasClass(e);i[o?"addClass":"removeClass"](e)}else if(d==="undefined"||d==="boolean"){this.className&&c.data(this,"__className__",this.className);this.className=
+this.className||a===false?"":c.data(this,"__className__")||""}})},hasClass:function(a){a=" "+a+" ";for(var b=0,d=this.length;b<d;b++)if((" "+this[b].className+" ").replace(Aa," ").indexOf(a)>-1)return true;return false},val:function(a){if(a===w){var b=this[0];if(b){if(c.nodeName(b,"option"))return(b.attributes.value||{}).specified?b.value:b.text;if(c.nodeName(b,"select")){var d=b.selectedIndex,f=[],e=b.options;b=b.type==="select-one";if(d<0)return null;var j=b?d:0;for(d=b?d+1:e.length;j<d;j++){var i=
+e[j];if(i.selected){a=c(i).val();if(b)return a;f.push(a)}}return f}if(Ba.test(b.type)&&!c.support.checkOn)return b.getAttribute("value")===null?"on":b.value;return(b.value||"").replace(Za,"")}return w}var o=c.isFunction(a);return this.each(function(k){var n=c(this),r=a;if(this.nodeType===1){if(o)r=a.call(this,k,n.val());if(typeof r==="number")r+="";if(c.isArray(r)&&Ba.test(this.type))this.checked=c.inArray(n.val(),r)>=0;else if(c.nodeName(this,"select")){var u=c.makeArray(r);c("option",this).each(function(){this.selected=
+c.inArray(c(this).val(),u)>=0});if(!u.length)this.selectedIndex=-1}else this.value=r}})}});c.extend({attrFn:{val:true,css:true,html:true,text:true,data:true,width:true,height:true,offset:true},attr:function(a,b,d,f){if(!a||a.nodeType===3||a.nodeType===8)return w;if(f&&b in c.attrFn)return c(a)[b](d);f=a.nodeType!==1||!c.isXMLDoc(a);var e=d!==w;b=f&&c.props[b]||b;if(a.nodeType===1){var j=$a.test(b);if(b in a&&f&&!j){if(e){b==="type"&&ab.test(a.nodeName)&&a.parentNode&&c.error("type property can't be changed");
+a[b]=d}if(c.nodeName(a,"form")&&a.getAttributeNode(b))return a.getAttributeNode(b).nodeValue;if(b==="tabIndex")return(b=a.getAttributeNode("tabIndex"))&&b.specified?b.value:bb.test(a.nodeName)||cb.test(a.nodeName)&&a.href?0:w;return a[b]}if(!c.support.style&&f&&b==="style"){if(e)a.style.cssText=""+d;return a.style.cssText}e&&a.setAttribute(b,""+d);a=!c.support.hrefNormalized&&f&&j?a.getAttribute(b,2):a.getAttribute(b);return a===null?w:a}return c.style(a,b,d)}});var O=/\.(.*)$/,db=function(a){return a.replace(/[^\w\s\.\|`]/g,
+function(b){return"\\"+b})};c.event={add:function(a,b,d,f){if(!(a.nodeType===3||a.nodeType===8)){if(a.setInterval&&a!==A&&!a.frameElement)a=A;var e,j;if(d.handler){e=d;d=e.handler}if(!d.guid)d.guid=c.guid++;if(j=c.data(a)){var i=j.events=j.events||{},o=j.handle;if(!o)j.handle=o=function(){return typeof c!=="undefined"&&!c.event.triggered?c.event.handle.apply(o.elem,arguments):w};o.elem=a;b=b.split(" ");for(var k,n=0,r;k=b[n++];){j=e?c.extend({},e):{handler:d,data:f};if(k.indexOf(".")>-1){r=k.split(".");
+k=r.shift();j.namespace=r.slice(0).sort().join(".")}else{r=[];j.namespace=""}j.type=k;j.guid=d.guid;var u=i[k],z=c.event.special[k]||{};if(!u){u=i[k]=[];if(!z.setup||z.setup.call(a,f,r,o)===false)if(a.addEventListener)a.addEventListener(k,o,false);else a.attachEvent&&a.attachEvent("on"+k,o)}if(z.add){z.add.call(a,j);if(!j.handler.guid)j.handler.guid=d.guid}u.push(j);c.event.global[k]=true}a=null}}},global:{},remove:function(a,b,d,f){if(!(a.nodeType===3||a.nodeType===8)){var e,j=0,i,o,k,n,r,u,z=c.data(a),
+C=z&&z.events;if(z&&C){if(b&&b.type){d=b.handler;b=b.type}if(!b||typeof b==="string"&&b.charAt(0)==="."){b=b||"";for(e in C)c.event.remove(a,e+b)}else{for(b=b.split(" ");e=b[j++];){n=e;i=e.indexOf(".")<0;o=[];if(!i){o=e.split(".");e=o.shift();k=new RegExp("(^|\\.)"+c.map(o.slice(0).sort(),db).join("\\.(?:.*\\.)?")+"(\\.|$)")}if(r=C[e])if(d){n=c.event.special[e]||{};for(B=f||0;B<r.length;B++){u=r[B];if(d.guid===u.guid){if(i||k.test(u.namespace)){f==null&&r.splice(B--,1);n.remove&&n.remove.call(a,u)}if(f!=
+null)break}}if(r.length===0||f!=null&&r.length===1){if(!n.teardown||n.teardown.call(a,o)===false)Ca(a,e,z.handle);delete C[e]}}else for(var B=0;B<r.length;B++){u=r[B];if(i||k.test(u.namespace)){c.event.remove(a,n,u.handler,B);r.splice(B--,1)}}}if(c.isEmptyObject(C)){if(b=z.handle)b.elem=null;delete z.events;delete z.handle;c.isEmptyObject(z)&&c.removeData(a)}}}}},trigger:function(a,b,d,f){var e=a.type||a;if(!f){a=typeof a==="object"?a[G]?a:c.extend(c.Event(e),a):c.Event(e);if(e.indexOf("!")>=0){a.type=
+e=e.slice(0,-1);a.exclusive=true}if(!d){a.stopPropagation();c.event.global[e]&&c.each(c.cache,function(){this.events&&this.events[e]&&c.event.trigger(a,b,this.handle.elem)})}if(!d||d.nodeType===3||d.nodeType===8)return w;a.result=w;a.target=d;b=c.makeArray(b);b.unshift(a)}a.currentTarget=d;(f=c.data(d,"handle"))&&f.apply(d,b);f=d.parentNode||d.ownerDocument;try{if(!(d&&d.nodeName&&c.noData[d.nodeName.toLowerCase()]))if(d["on"+e]&&d["on"+e].apply(d,b)===false)a.result=false}catch(j){}if(!a.isPropagationStopped()&&
+f)c.event.trigger(a,b,f,true);else if(!a.isDefaultPrevented()){f=a.target;var i,o=c.nodeName(f,"a")&&e==="click",k=c.event.special[e]||{};if((!k._default||k._default.call(d,a)===false)&&!o&&!(f&&f.nodeName&&c.noData[f.nodeName.toLowerCase()])){try{if(f[e]){if(i=f["on"+e])f["on"+e]=null;c.event.triggered=true;f[e]()}}catch(n){}if(i)f["on"+e]=i;c.event.triggered=false}}},handle:function(a){var b,d,f,e;a=arguments[0]=c.event.fix(a||A.event);a.currentTarget=this;b=a.type.indexOf(".")<0&&!a.exclusive;
+if(!b){d=a.type.split(".");a.type=d.shift();f=new RegExp("(^|\\.)"+d.slice(0).sort().join("\\.(?:.*\\.)?")+"(\\.|$)")}e=c.data(this,"events");d=e[a.type];if(e&&d){d=d.slice(0);e=0;for(var j=d.length;e<j;e++){var i=d[e];if(b||f.test(i.namespace)){a.handler=i.handler;a.data=i.data;a.handleObj=i;i=i.handler.apply(this,arguments);if(i!==w){a.result=i;if(i===false){a.preventDefault();a.stopPropagation()}}if(a.isImmediatePropagationStopped())break}}}return a.result},props:"altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY originalTarget pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which".split(" "),
+fix:function(a){if(a[G])return a;var b=a;a=c.Event(b);for(var d=this.props.length,f;d;){f=this.props[--d];a[f]=b[f]}if(!a.target)a.target=a.srcElement||s;if(a.target.nodeType===3)a.target=a.target.parentNode;if(!a.relatedTarget&&a.fromElement)a.relatedTarget=a.fromElement===a.target?a.toElement:a.fromElement;if(a.pageX==null&&a.clientX!=null){b=s.documentElement;d=s.body;a.pageX=a.clientX+(b&&b.scrollLeft||d&&d.scrollLeft||0)-(b&&b.clientLeft||d&&d.clientLeft||0);a.pageY=a.clientY+(b&&b.scrollTop||
+d&&d.scrollTop||0)-(b&&b.clientTop||d&&d.clientTop||0)}if(!a.which&&(a.charCode||a.charCode===0?a.charCode:a.keyCode))a.which=a.charCode||a.keyCode;if(!a.metaKey&&a.ctrlKey)a.metaKey=a.ctrlKey;if(!a.which&&a.button!==w)a.which=a.button&1?1:a.button&2?3:a.button&4?2:0;return a},guid:1E8,proxy:c.proxy,special:{ready:{setup:c.bindReady,teardown:c.noop},live:{add:function(a){c.event.add(this,a.origType,c.extend({},a,{handler:oa}))},remove:function(a){var b=true,d=a.origType.replace(O,"");c.each(c.data(this,
+"events").live||[],function(){if(d===this.origType.replace(O,""))return b=false});b&&c.event.remove(this,a.origType,oa)}},beforeunload:{setup:function(a,b,d){if(this.setInterval)this.onbeforeunload=d;return false},teardown:function(a,b){if(this.onbeforeunload===b)this.onbeforeunload=null}}}};var Ca=s.removeEventListener?function(a,b,d){a.removeEventListener(b,d,false)}:function(a,b,d){a.detachEvent("on"+b,d)};c.Event=function(a){if(!this.preventDefault)return new c.Event(a);if(a&&a.type){this.originalEvent=
+a;this.type=a.type}else this.type=a;this.timeStamp=J();this[G]=true};c.Event.prototype={preventDefault:function(){this.isDefaultPrevented=Z;var a=this.originalEvent;if(a){a.preventDefault&&a.preventDefault();a.returnValue=false}},stopPropagation:function(){this.isPropagationStopped=Z;var a=this.originalEvent;if(a){a.stopPropagation&&a.stopPropagation();a.cancelBubble=true}},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=Z;this.stopPropagation()},isDefaultPrevented:Y,isPropagationStopped:Y,
+isImmediatePropagationStopped:Y};var Da=function(a){var b=a.relatedTarget;try{for(;b&&b!==this;)b=b.parentNode;if(b!==this){a.type=a.data;c.event.handle.apply(this,arguments)}}catch(d){}},Ea=function(a){a.type=a.data;c.event.handle.apply(this,arguments)};c.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(a,b){c.event.special[a]={setup:function(d){c.event.add(this,b,d&&d.selector?Ea:Da,a)},teardown:function(d){c.event.remove(this,b,d&&d.selector?Ea:Da)}}});if(!c.support.submitBubbles)c.event.special.submit=
+{setup:function(){if(this.nodeName.toLowerCase()!=="form"){c.event.add(this,"click.specialSubmit",function(a){var b=a.target,d=b.type;if((d==="submit"||d==="image")&&c(b).closest("form").length)return na("submit",this,arguments)});c.event.add(this,"keypress.specialSubmit",function(a){var b=a.target,d=b.type;if((d==="text"||d==="password")&&c(b).closest("form").length&&a.keyCode===13)return na("submit",this,arguments)})}else return false},teardown:function(){c.event.remove(this,".specialSubmit")}};
+if(!c.support.changeBubbles){var da=/textarea|input|select/i,ea,Fa=function(a){var b=a.type,d=a.value;if(b==="radio"||b==="checkbox")d=a.checked;else if(b==="select-multiple")d=a.selectedIndex>-1?c.map(a.options,function(f){return f.selected}).join("-"):"";else if(a.nodeName.toLowerCase()==="select")d=a.selectedIndex;return d},fa=function(a,b){var d=a.target,f,e;if(!(!da.test(d.nodeName)||d.readOnly)){f=c.data(d,"_change_data");e=Fa(d);if(a.type!=="focusout"||d.type!=="radio")c.data(d,"_change_data",
+e);if(!(f===w||e===f))if(f!=null||e){a.type="change";return c.event.trigger(a,b,d)}}};c.event.special.change={filters:{focusout:fa,click:function(a){var b=a.target,d=b.type;if(d==="radio"||d==="checkbox"||b.nodeName.toLowerCase()==="select")return fa.call(this,a)},keydown:function(a){var b=a.target,d=b.type;if(a.keyCode===13&&b.nodeName.toLowerCase()!=="textarea"||a.keyCode===32&&(d==="checkbox"||d==="radio")||d==="select-multiple")return fa.call(this,a)},beforeactivate:function(a){a=a.target;c.data(a,
+"_change_data",Fa(a))}},setup:function(){if(this.type==="file")return false;for(var a in ea)c.event.add(this,a+".specialChange",ea[a]);return da.test(this.nodeName)},teardown:function(){c.event.remove(this,".specialChange");return da.test(this.nodeName)}};ea=c.event.special.change.filters}s.addEventListener&&c.each({focus:"focusin",blur:"focusout"},function(a,b){function d(f){f=c.event.fix(f);f.type=b;return c.event.handle.call(this,f)}c.event.special[b]={setup:function(){this.addEventListener(a,
+d,true)},teardown:function(){this.removeEventListener(a,d,true)}}});c.each(["bind","one"],function(a,b){c.fn[b]=function(d,f,e){if(typeof d==="object"){for(var j in d)this[b](j,f,d[j],e);return this}if(c.isFunction(f)){e=f;f=w}var i=b==="one"?c.proxy(e,function(k){c(this).unbind(k,i);return e.apply(this,arguments)}):e;if(d==="unload"&&b!=="one")this.one(d,f,e);else{j=0;for(var o=this.length;j<o;j++)c.event.add(this[j],d,i,f)}return this}});c.fn.extend({unbind:function(a,b){if(typeof a==="object"&&
+!a.preventDefault)for(var d in a)this.unbind(d,a[d]);else{d=0;for(var f=this.length;d<f;d++)c.event.remove(this[d],a,b)}return this},delegate:function(a,b,d,f){return this.live(b,d,f,a)},undelegate:function(a,b,d){return arguments.length===0?this.unbind("live"):this.die(b,null,d,a)},trigger:function(a,b){return this.each(function(){c.event.trigger(a,b,this)})},triggerHandler:function(a,b){if(this[0]){a=c.Event(a);a.preventDefault();a.stopPropagation();c.event.trigger(a,b,this[0]);return a.result}},
+toggle:function(a){for(var b=arguments,d=1;d<b.length;)c.proxy(a,b[d++]);return this.click(c.proxy(a,function(f){var e=(c.data(this,"lastToggle"+a.guid)||0)%d;c.data(this,"lastToggle"+a.guid,e+1);f.preventDefault();return b[e].apply(this,arguments)||false}))},hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}});var Ga={focus:"focusin",blur:"focusout",mouseenter:"mouseover",mouseleave:"mouseout"};c.each(["live","die"],function(a,b){c.fn[b]=function(d,f,e,j){var i,o=0,k,n,r=j||this.selector,
+u=j?this:c(this.context);if(c.isFunction(f)){e=f;f=w}for(d=(d||"").split(" ");(i=d[o++])!=null;){j=O.exec(i);k="";if(j){k=j[0];i=i.replace(O,"")}if(i==="hover")d.push("mouseenter"+k,"mouseleave"+k);else{n=i;if(i==="focus"||i==="blur"){d.push(Ga[i]+k);i+=k}else i=(Ga[i]||i)+k;b==="live"?u.each(function(){c.event.add(this,pa(i,r),{data:f,selector:r,handler:e,origType:i,origHandler:e,preType:n})}):u.unbind(pa(i,r),e)}}return this}});c.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error".split(" "),
+function(a,b){c.fn[b]=function(d){return d?this.bind(b,d):this.trigger(b)};if(c.attrFn)c.attrFn[b]=true});A.attachEvent&&!A.addEventListener&&A.attachEvent("onunload",function(){for(var a in c.cache)if(c.cache[a].handle)try{c.event.remove(c.cache[a].handle.elem)}catch(b){}});(function(){function a(g){for(var h="",l,m=0;g[m];m++){l=g[m];if(l.nodeType===3||l.nodeType===4)h+=l.nodeValue;else if(l.nodeType!==8)h+=a(l.childNodes)}return h}function b(g,h,l,m,q,p){q=0;for(var v=m.length;q<v;q++){var t=m[q];
+if(t){t=t[g];for(var y=false;t;){if(t.sizcache===l){y=m[t.sizset];break}if(t.nodeType===1&&!p){t.sizcache=l;t.sizset=q}if(t.nodeName.toLowerCase()===h){y=t;break}t=t[g]}m[q]=y}}}function d(g,h,l,m,q,p){q=0;for(var v=m.length;q<v;q++){var t=m[q];if(t){t=t[g];for(var y=false;t;){if(t.sizcache===l){y=m[t.sizset];break}if(t.nodeType===1){if(!p){t.sizcache=l;t.sizset=q}if(typeof h!=="string"){if(t===h){y=true;break}}else if(k.filter(h,[t]).length>0){y=t;break}}t=t[g]}m[q]=y}}}var f=/((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^[\]]*\]|['"][^'"]*['"]|[^[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
+e=0,j=Object.prototype.toString,i=false,o=true;[0,0].sort(function(){o=false;return 0});var k=function(g,h,l,m){l=l||[];var q=h=h||s;if(h.nodeType!==1&&h.nodeType!==9)return[];if(!g||typeof g!=="string")return l;for(var p=[],v,t,y,S,H=true,M=x(h),I=g;(f.exec(""),v=f.exec(I))!==null;){I=v[3];p.push(v[1]);if(v[2]){S=v[3];break}}if(p.length>1&&r.exec(g))if(p.length===2&&n.relative[p[0]])t=ga(p[0]+p[1],h);else for(t=n.relative[p[0]]?[h]:k(p.shift(),h);p.length;){g=p.shift();if(n.relative[g])g+=p.shift();
+t=ga(g,t)}else{if(!m&&p.length>1&&h.nodeType===9&&!M&&n.match.ID.test(p[0])&&!n.match.ID.test(p[p.length-1])){v=k.find(p.shift(),h,M);h=v.expr?k.filter(v.expr,v.set)[0]:v.set[0]}if(h){v=m?{expr:p.pop(),set:z(m)}:k.find(p.pop(),p.length===1&&(p[0]==="~"||p[0]==="+")&&h.parentNode?h.parentNode:h,M);t=v.expr?k.filter(v.expr,v.set):v.set;if(p.length>0)y=z(t);else H=false;for(;p.length;){var D=p.pop();v=D;if(n.relative[D])v=p.pop();else D="";if(v==null)v=h;n.relative[D](y,v,M)}}else y=[]}y||(y=t);y||k.error(D||
+g);if(j.call(y)==="[object Array]")if(H)if(h&&h.nodeType===1)for(g=0;y[g]!=null;g++){if(y[g]&&(y[g]===true||y[g].nodeType===1&&E(h,y[g])))l.push(t[g])}else for(g=0;y[g]!=null;g++)y[g]&&y[g].nodeType===1&&l.push(t[g]);else l.push.apply(l,y);else z(y,l);if(S){k(S,q,l,m);k.uniqueSort(l)}return l};k.uniqueSort=function(g){if(B){i=o;g.sort(B);if(i)for(var h=1;h<g.length;h++)g[h]===g[h-1]&&g.splice(h--,1)}return g};k.matches=function(g,h){return k(g,null,null,h)};k.find=function(g,h,l){var m,q;if(!g)return[];
+for(var p=0,v=n.order.length;p<v;p++){var t=n.order[p];if(q=n.leftMatch[t].exec(g)){var y=q[1];q.splice(1,1);if(y.substr(y.length-1)!=="\\"){q[1]=(q[1]||"").replace(/\\/g,"");m=n.find[t](q,h,l);if(m!=null){g=g.replace(n.match[t],"");break}}}}m||(m=h.getElementsByTagName("*"));return{set:m,expr:g}};k.filter=function(g,h,l,m){for(var q=g,p=[],v=h,t,y,S=h&&h[0]&&x(h[0]);g&&h.length;){for(var H in n.filter)if((t=n.leftMatch[H].exec(g))!=null&&t[2]){var M=n.filter[H],I,D;D=t[1];y=false;t.splice(1,1);if(D.substr(D.length-
+1)!=="\\"){if(v===p)p=[];if(n.preFilter[H])if(t=n.preFilter[H](t,v,l,p,m,S)){if(t===true)continue}else y=I=true;if(t)for(var U=0;(D=v[U])!=null;U++)if(D){I=M(D,t,U,v);var Ha=m^!!I;if(l&&I!=null)if(Ha)y=true;else v[U]=false;else if(Ha){p.push(D);y=true}}if(I!==w){l||(v=p);g=g.replace(n.match[H],"");if(!y)return[];break}}}if(g===q)if(y==null)k.error(g);else break;q=g}return v};k.error=function(g){throw"Syntax error, unrecognized expression: "+g;};var n=k.selectors={order:["ID","NAME","TAG"],match:{ID:/#((?:[\w\u00c0-\uFFFF-]|\\.)+)/,
+CLASS:/\.((?:[\w\u00c0-\uFFFF-]|\\.)+)/,NAME:/\[name=['"]*((?:[\w\u00c0-\uFFFF-]|\\.)+)['"]*\]/,ATTR:/\[\s*((?:[\w\u00c0-\uFFFF-]|\\.)+)\s*(?:(\S?=)\s*(['"]*)(.*?)\3|)\s*\]/,TAG:/^((?:[\w\u00c0-\uFFFF\*-]|\\.)+)/,CHILD:/:(only|nth|last|first)-child(?:\((even|odd|[\dn+-]*)\))?/,POS:/:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^-]|$)/,PSEUDO:/:((?:[\w\u00c0-\uFFFF-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/},leftMatch:{},attrMap:{"class":"className","for":"htmlFor"},attrHandle:{href:function(g){return g.getAttribute("href")}},
+relative:{"+":function(g,h){var l=typeof h==="string",m=l&&!/\W/.test(h);l=l&&!m;if(m)h=h.toLowerCase();m=0;for(var q=g.length,p;m<q;m++)if(p=g[m]){for(;(p=p.previousSibling)&&p.nodeType!==1;);g[m]=l||p&&p.nodeName.toLowerCase()===h?p||false:p===h}l&&k.filter(h,g,true)},">":function(g,h){var l=typeof h==="string";if(l&&!/\W/.test(h)){h=h.toLowerCase();for(var m=0,q=g.length;m<q;m++){var p=g[m];if(p){l=p.parentNode;g[m]=l.nodeName.toLowerCase()===h?l:false}}}else{m=0;for(q=g.length;m<q;m++)if(p=g[m])g[m]=
+l?p.parentNode:p.parentNode===h;l&&k.filter(h,g,true)}},"":function(g,h,l){var m=e++,q=d;if(typeof h==="string"&&!/\W/.test(h)){var p=h=h.toLowerCase();q=b}q("parentNode",h,m,g,p,l)},"~":function(g,h,l){var m=e++,q=d;if(typeof h==="string"&&!/\W/.test(h)){var p=h=h.toLowerCase();q=b}q("previousSibling",h,m,g,p,l)}},find:{ID:function(g,h,l){if(typeof h.getElementById!=="undefined"&&!l)return(g=h.getElementById(g[1]))?[g]:[]},NAME:function(g,h){if(typeof h.getElementsByName!=="undefined"){var l=[];
+h=h.getElementsByName(g[1]);for(var m=0,q=h.length;m<q;m++)h[m].getAttribute("name")===g[1]&&l.push(h[m]);return l.length===0?null:l}},TAG:function(g,h){return h.getElementsByTagName(g[1])}},preFilter:{CLASS:function(g,h,l,m,q,p){g=" "+g[1].replace(/\\/g,"")+" ";if(p)return g;p=0;for(var v;(v=h[p])!=null;p++)if(v)if(q^(v.className&&(" "+v.className+" ").replace(/[\t\n]/g," ").indexOf(g)>=0))l||m.push(v);else if(l)h[p]=false;return false},ID:function(g){return g[1].replace(/\\/g,"")},TAG:function(g){return g[1].toLowerCase()},
+CHILD:function(g){if(g[1]==="nth"){var h=/(-?)(\d*)n((?:\+|-)?\d*)/.exec(g[2]==="even"&&"2n"||g[2]==="odd"&&"2n+1"||!/\D/.test(g[2])&&"0n+"+g[2]||g[2]);g[2]=h[1]+(h[2]||1)-0;g[3]=h[3]-0}g[0]=e++;return g},ATTR:function(g,h,l,m,q,p){h=g[1].replace(/\\/g,"");if(!p&&n.attrMap[h])g[1]=n.attrMap[h];if(g[2]==="~=")g[4]=" "+g[4]+" ";return g},PSEUDO:function(g,h,l,m,q){if(g[1]==="not")if((f.exec(g[3])||"").length>1||/^\w/.test(g[3]))g[3]=k(g[3],null,null,h);else{g=k.filter(g[3],h,l,true^q);l||m.push.apply(m,
+g);return false}else if(n.match.POS.test(g[0])||n.match.CHILD.test(g[0]))return true;return g},POS:function(g){g.unshift(true);return g}},filters:{enabled:function(g){return g.disabled===false&&g.type!=="hidden"},disabled:function(g){return g.disabled===true},checked:function(g){return g.checked===true},selected:function(g){return g.selected===true},parent:function(g){return!!g.firstChild},empty:function(g){return!g.firstChild},has:function(g,h,l){return!!k(l[3],g).length},header:function(g){return/h\d/i.test(g.nodeName)},
+text:function(g){return"text"===g.type},radio:function(g){return"radio"===g.type},checkbox:function(g){return"checkbox"===g.type},file:function(g){return"file"===g.type},password:function(g){return"password"===g.type},submit:function(g){return"submit"===g.type},image:function(g){return"image"===g.type},reset:function(g){return"reset"===g.type},button:function(g){return"button"===g.type||g.nodeName.toLowerCase()==="button"},input:function(g){return/input|select|textarea|button/i.test(g.nodeName)}},
+setFilters:{first:function(g,h){return h===0},last:function(g,h,l,m){return h===m.length-1},even:function(g,h){return h%2===0},odd:function(g,h){return h%2===1},lt:function(g,h,l){return h<l[3]-0},gt:function(g,h,l){return h>l[3]-0},nth:function(g,h,l){return l[3]-0===h},eq:function(g,h,l){return l[3]-0===h}},filter:{PSEUDO:function(g,h,l,m){var q=h[1],p=n.filters[q];if(p)return p(g,l,h,m);else if(q==="contains")return(g.textContent||g.innerText||a([g])||"").indexOf(h[3])>=0;else if(q==="not"){h=
+h[3];l=0;for(m=h.length;l<m;l++)if(h[l]===g)return false;return true}else k.error("Syntax error, unrecognized expression: "+q)},CHILD:function(g,h){var l=h[1],m=g;switch(l){case "only":case "first":for(;m=m.previousSibling;)if(m.nodeType===1)return false;if(l==="first")return true;m=g;case "last":for(;m=m.nextSibling;)if(m.nodeType===1)return false;return true;case "nth":l=h[2];var q=h[3];if(l===1&&q===0)return true;h=h[0];var p=g.parentNode;if(p&&(p.sizcache!==h||!g.nodeIndex)){var v=0;for(m=p.firstChild;m;m=
+m.nextSibling)if(m.nodeType===1)m.nodeIndex=++v;p.sizcache=h}g=g.nodeIndex-q;return l===0?g===0:g%l===0&&g/l>=0}},ID:function(g,h){return g.nodeType===1&&g.getAttribute("id")===h},TAG:function(g,h){return h==="*"&&g.nodeType===1||g.nodeName.toLowerCase()===h},CLASS:function(g,h){return(" "+(g.className||g.getAttribute("class"))+" ").indexOf(h)>-1},ATTR:function(g,h){var l=h[1];g=n.attrHandle[l]?n.attrHandle[l](g):g[l]!=null?g[l]:g.getAttribute(l);l=g+"";var m=h[2];h=h[4];return g==null?m==="!=":m===
+"="?l===h:m==="*="?l.indexOf(h)>=0:m==="~="?(" "+l+" ").indexOf(h)>=0:!h?l&&g!==false:m==="!="?l!==h:m==="^="?l.indexOf(h)===0:m==="$="?l.substr(l.length-h.length)===h:m==="|="?l===h||l.substr(0,h.length+1)===h+"-":false},POS:function(g,h,l,m){var q=n.setFilters[h[2]];if(q)return q(g,l,h,m)}}},r=n.match.POS;for(var u in n.match){n.match[u]=new RegExp(n.match[u].source+/(?![^\[]*\])(?![^\(]*\))/.source);n.leftMatch[u]=new RegExp(/(^(?:.|\r|\n)*?)/.source+n.match[u].source.replace(/\\(\d+)/g,function(g,
+h){return"\\"+(h-0+1)}))}var z=function(g,h){g=Array.prototype.slice.call(g,0);if(h){h.push.apply(h,g);return h}return g};try{Array.prototype.slice.call(s.documentElement.childNodes,0)}catch(C){z=function(g,h){h=h||[];if(j.call(g)==="[object Array]")Array.prototype.push.apply(h,g);else if(typeof g.length==="number")for(var l=0,m=g.length;l<m;l++)h.push(g[l]);else for(l=0;g[l];l++)h.push(g[l]);return h}}var B;if(s.documentElement.compareDocumentPosition)B=function(g,h){if(!g.compareDocumentPosition||
+!h.compareDocumentPosition){if(g==h)i=true;return g.compareDocumentPosition?-1:1}g=g.compareDocumentPosition(h)&4?-1:g===h?0:1;if(g===0)i=true;return g};else if("sourceIndex"in s.documentElement)B=function(g,h){if(!g.sourceIndex||!h.sourceIndex){if(g==h)i=true;return g.sourceIndex?-1:1}g=g.sourceIndex-h.sourceIndex;if(g===0)i=true;return g};else if(s.createRange)B=function(g,h){if(!g.ownerDocument||!h.ownerDocument){if(g==h)i=true;return g.ownerDocument?-1:1}var l=g.ownerDocument.createRange(),m=
+h.ownerDocument.createRange();l.setStart(g,0);l.setEnd(g,0);m.setStart(h,0);m.setEnd(h,0);g=l.compareBoundaryPoints(Range.START_TO_END,m);if(g===0)i=true;return g};(function(){var g=s.createElement("div"),h="script"+(new Date).getTime();g.innerHTML="<a name='"+h+"'/>";var l=s.documentElement;l.insertBefore(g,l.firstChild);if(s.getElementById(h)){n.find.ID=function(m,q,p){if(typeof q.getElementById!=="undefined"&&!p)return(q=q.getElementById(m[1]))?q.id===m[1]||typeof q.getAttributeNode!=="undefined"&&
+q.getAttributeNode("id").nodeValue===m[1]?[q]:w:[]};n.filter.ID=function(m,q){var p=typeof m.getAttributeNode!=="undefined"&&m.getAttributeNode("id");return m.nodeType===1&&p&&p.nodeValue===q}}l.removeChild(g);l=g=null})();(function(){var g=s.createElement("div");g.appendChild(s.createComment(""));if(g.getElementsByTagName("*").length>0)n.find.TAG=function(h,l){l=l.getElementsByTagName(h[1]);if(h[1]==="*"){h=[];for(var m=0;l[m];m++)l[m].nodeType===1&&h.push(l[m]);l=h}return l};g.innerHTML="<a href='#'></a>";
+if(g.firstChild&&typeof g.firstChild.getAttribute!=="undefined"&&g.firstChild.getAttribute("href")!=="#")n.attrHandle.href=function(h){return h.getAttribute("href",2)};g=null})();s.querySelectorAll&&function(){var g=k,h=s.createElement("div");h.innerHTML="<p class='TEST'></p>";if(!(h.querySelectorAll&&h.querySelectorAll(".TEST").length===0)){k=function(m,q,p,v){q=q||s;if(!v&&q.nodeType===9&&!x(q))try{return z(q.querySelectorAll(m),p)}catch(t){}return g(m,q,p,v)};for(var l in g)k[l]=g[l];h=null}}();
+(function(){var g=s.createElement("div");g.innerHTML="<div class='test e'></div><div class='test'></div>";if(!(!g.getElementsByClassName||g.getElementsByClassName("e").length===0)){g.lastChild.className="e";if(g.getElementsByClassName("e").length!==1){n.order.splice(1,0,"CLASS");n.find.CLASS=function(h,l,m){if(typeof l.getElementsByClassName!=="undefined"&&!m)return l.getElementsByClassName(h[1])};g=null}}})();var E=s.compareDocumentPosition?function(g,h){return!!(g.compareDocumentPosition(h)&16)}:
+function(g,h){return g!==h&&(g.contains?g.contains(h):true)},x=function(g){return(g=(g?g.ownerDocument||g:0).documentElement)?g.nodeName!=="HTML":false},ga=function(g,h){var l=[],m="",q;for(h=h.nodeType?[h]:h;q=n.match.PSEUDO.exec(g);){m+=q[0];g=g.replace(n.match.PSEUDO,"")}g=n.relative[g]?g+"*":g;q=0;for(var p=h.length;q<p;q++)k(g,h[q],l);return k.filter(m,l)};c.find=k;c.expr=k.selectors;c.expr[":"]=c.expr.filters;c.unique=k.uniqueSort;c.text=a;c.isXMLDoc=x;c.contains=E})();var eb=/Until$/,fb=/^(?:parents|prevUntil|prevAll)/,
+gb=/,/;R=Array.prototype.slice;var Ia=function(a,b,d){if(c.isFunction(b))return c.grep(a,function(e,j){return!!b.call(e,j,e)===d});else if(b.nodeType)return c.grep(a,function(e){return e===b===d});else if(typeof b==="string"){var f=c.grep(a,function(e){return e.nodeType===1});if(Ua.test(b))return c.filter(b,f,!d);else b=c.filter(b,f)}return c.grep(a,function(e){return c.inArray(e,b)>=0===d})};c.fn.extend({find:function(a){for(var b=this.pushStack("","find",a),d=0,f=0,e=this.length;f<e;f++){d=b.length;
+c.find(a,this[f],b);if(f>0)for(var j=d;j<b.length;j++)for(var i=0;i<d;i++)if(b[i]===b[j]){b.splice(j--,1);break}}return b},has:function(a){var b=c(a);return this.filter(function(){for(var d=0,f=b.length;d<f;d++)if(c.contains(this,b[d]))return true})},not:function(a){return this.pushStack(Ia(this,a,false),"not",a)},filter:function(a){return this.pushStack(Ia(this,a,true),"filter",a)},is:function(a){return!!a&&c.filter(a,this).length>0},closest:function(a,b){if(c.isArray(a)){var d=[],f=this[0],e,j=
+{},i;if(f&&a.length){e=0;for(var o=a.length;e<o;e++){i=a[e];j[i]||(j[i]=c.expr.match.POS.test(i)?c(i,b||this.context):i)}for(;f&&f.ownerDocument&&f!==b;){for(i in j){e=j[i];if(e.jquery?e.index(f)>-1:c(f).is(e)){d.push({selector:i,elem:f});delete j[i]}}f=f.parentNode}}return d}var k=c.expr.match.POS.test(a)?c(a,b||this.context):null;return this.map(function(n,r){for(;r&&r.ownerDocument&&r!==b;){if(k?k.index(r)>-1:c(r).is(a))return r;r=r.parentNode}return null})},index:function(a){if(!a||typeof a===
+"string")return c.inArray(this[0],a?c(a):this.parent().children());return c.inArray(a.jquery?a[0]:a,this)},add:function(a,b){a=typeof a==="string"?c(a,b||this.context):c.makeArray(a);b=c.merge(this.get(),a);return this.pushStack(qa(a[0])||qa(b[0])?b:c.unique(b))},andSelf:function(){return this.add(this.prevObject)}});c.each({parent:function(a){return(a=a.parentNode)&&a.nodeType!==11?a:null},parents:function(a){return c.dir(a,"parentNode")},parentsUntil:function(a,b,d){return c.dir(a,"parentNode",
+d)},next:function(a){return c.nth(a,2,"nextSibling")},prev:function(a){return c.nth(a,2,"previousSibling")},nextAll:function(a){return c.dir(a,"nextSibling")},prevAll:function(a){return c.dir(a,"previousSibling")},nextUntil:function(a,b,d){return c.dir(a,"nextSibling",d)},prevUntil:function(a,b,d){return c.dir(a,"previousSibling",d)},siblings:function(a){return c.sibling(a.parentNode.firstChild,a)},children:function(a){return c.sibling(a.firstChild)},contents:function(a){return c.nodeName(a,"iframe")?
+a.contentDocument||a.contentWindow.document:c.makeArray(a.childNodes)}},function(a,b){c.fn[a]=function(d,f){var e=c.map(this,b,d);eb.test(a)||(f=d);if(f&&typeof f==="string")e=c.filter(f,e);e=this.length>1?c.unique(e):e;if((this.length>1||gb.test(f))&&fb.test(a))e=e.reverse();return this.pushStack(e,a,R.call(arguments).join(","))}});c.extend({filter:function(a,b,d){if(d)a=":not("+a+")";return c.find.matches(a,b)},dir:function(a,b,d){var f=[];for(a=a[b];a&&a.nodeType!==9&&(d===w||a.nodeType!==1||!c(a).is(d));){a.nodeType===
+1&&f.push(a);a=a[b]}return f},nth:function(a,b,d){b=b||1;for(var f=0;a;a=a[d])if(a.nodeType===1&&++f===b)break;return a},sibling:function(a,b){for(var d=[];a;a=a.nextSibling)a.nodeType===1&&a!==b&&d.push(a);return d}});var Ja=/ jQuery\d+="(?:\d+|null)"/g,V=/^\s+/,Ka=/(<([\w:]+)[^>]*?)\/>/g,hb=/^(?:area|br|col|embed|hr|img|input|link|meta|param)$/i,La=/<([\w:]+)/,ib=/<tbody/i,jb=/<|&#?\w+;/,ta=/<script|<object|<embed|<option|<style/i,ua=/checked\s*(?:[^=]|=\s*.checked.)/i,Ma=function(a,b,d){return hb.test(d)?
+a:b+"></"+d+">"},F={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],area:[1,"<map>","</map>"],_default:[0,"",""]};F.optgroup=F.option;F.tbody=F.tfoot=F.colgroup=F.caption=F.thead;F.th=F.td;if(!c.support.htmlSerialize)F._default=[1,"div<div>","</div>"];c.fn.extend({text:function(a){if(c.isFunction(a))return this.each(function(b){var d=
+c(this);d.text(a.call(this,b,d.text()))});if(typeof a!=="object"&&a!==w)return this.empty().append((this[0]&&this[0].ownerDocument||s).createTextNode(a));return c.text(this)},wrapAll:function(a){if(c.isFunction(a))return this.each(function(d){c(this).wrapAll(a.call(this,d))});if(this[0]){var b=c(a,this[0].ownerDocument).eq(0).clone(true);this[0].parentNode&&b.insertBefore(this[0]);b.map(function(){for(var d=this;d.firstChild&&d.firstChild.nodeType===1;)d=d.firstChild;return d}).append(this)}return this},
+wrapInner:function(a){if(c.isFunction(a))return this.each(function(b){c(this).wrapInner(a.call(this,b))});return this.each(function(){var b=c(this),d=b.contents();d.length?d.wrapAll(a):b.append(a)})},wrap:function(a){return this.each(function(){c(this).wrapAll(a)})},unwrap:function(){return this.parent().each(function(){c.nodeName(this,"body")||c(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,true,function(a){this.nodeType===1&&this.appendChild(a)})},
+prepend:function(){return this.domManip(arguments,true,function(a){this.nodeType===1&&this.insertBefore(a,this.firstChild)})},before:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,false,function(b){this.parentNode.insertBefore(b,this)});else if(arguments.length){var a=c(arguments[0]);a.push.apply(a,this.toArray());return this.pushStack(a,"before",arguments)}},after:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,false,function(b){this.parentNode.insertBefore(b,
+this.nextSibling)});else if(arguments.length){var a=this.pushStack(this,"after",arguments);a.push.apply(a,c(arguments[0]).toArray());return a}},remove:function(a,b){for(var d=0,f;(f=this[d])!=null;d++)if(!a||c.filter(a,[f]).length){if(!b&&f.nodeType===1){c.cleanData(f.getElementsByTagName("*"));c.cleanData([f])}f.parentNode&&f.parentNode.removeChild(f)}return this},empty:function(){for(var a=0,b;(b=this[a])!=null;a++)for(b.nodeType===1&&c.cleanData(b.getElementsByTagName("*"));b.firstChild;)b.removeChild(b.firstChild);
+return this},clone:function(a){var b=this.map(function(){if(!c.support.noCloneEvent&&!c.isXMLDoc(this)){var d=this.outerHTML,f=this.ownerDocument;if(!d){d=f.createElement("div");d.appendChild(this.cloneNode(true));d=d.innerHTML}return c.clean([d.replace(Ja,"").replace(/=([^="'>\s]+\/)>/g,'="$1">').replace(V,"")],f)[0]}else return this.cloneNode(true)});if(a===true){ra(this,b);ra(this.find("*"),b.find("*"))}return b},html:function(a){if(a===w)return this[0]&&this[0].nodeType===1?this[0].innerHTML.replace(Ja,
+""):null;else if(typeof a==="string"&&!ta.test(a)&&(c.support.leadingWhitespace||!V.test(a))&&!F[(La.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(Ka,Ma);try{for(var b=0,d=this.length;b<d;b++)if(this[b].nodeType===1){c.cleanData(this[b].getElementsByTagName("*"));this[b].innerHTML=a}}catch(f){this.empty().append(a)}}else c.isFunction(a)?this.each(function(e){var j=c(this),i=j.html();j.empty().append(function(){return a.call(this,e,i)})}):this.empty().append(a);return this},replaceWith:function(a){if(this[0]&&
+this[0].parentNode){if(c.isFunction(a))return this.each(function(b){var d=c(this),f=d.html();d.replaceWith(a.call(this,b,f))});if(typeof a!=="string")a=c(a).detach();return this.each(function(){var b=this.nextSibling,d=this.parentNode;c(this).remove();b?c(b).before(a):c(d).append(a)})}else return this.pushStack(c(c.isFunction(a)?a():a),"replaceWith",a)},detach:function(a){return this.remove(a,true)},domManip:function(a,b,d){function f(u){return c.nodeName(u,"table")?u.getElementsByTagName("tbody")[0]||
+u.appendChild(u.ownerDocument.createElement("tbody")):u}var e,j,i=a[0],o=[],k;if(!c.support.checkClone&&arguments.length===3&&typeof i==="string"&&ua.test(i))return this.each(function(){c(this).domManip(a,b,d,true)});if(c.isFunction(i))return this.each(function(u){var z=c(this);a[0]=i.call(this,u,b?z.html():w);z.domManip(a,b,d)});if(this[0]){e=i&&i.parentNode;e=c.support.parentNode&&e&&e.nodeType===11&&e.childNodes.length===this.length?{fragment:e}:sa(a,this,o);k=e.fragment;if(j=k.childNodes.length===
+1?(k=k.firstChild):k.firstChild){b=b&&c.nodeName(j,"tr");for(var n=0,r=this.length;n<r;n++)d.call(b?f(this[n],j):this[n],n>0||e.cacheable||this.length>1?k.cloneNode(true):k)}o.length&&c.each(o,Qa)}return this}});c.fragments={};c.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){c.fn[a]=function(d){var f=[];d=c(d);var e=this.length===1&&this[0].parentNode;if(e&&e.nodeType===11&&e.childNodes.length===1&&d.length===1){d[b](this[0]);
+return this}else{e=0;for(var j=d.length;e<j;e++){var i=(e>0?this.clone(true):this).get();c.fn[b].apply(c(d[e]),i);f=f.concat(i)}return this.pushStack(f,a,d.selector)}}});c.extend({clean:function(a,b,d,f){b=b||s;if(typeof b.createElement==="undefined")b=b.ownerDocument||b[0]&&b[0].ownerDocument||s;for(var e=[],j=0,i;(i=a[j])!=null;j++){if(typeof i==="number")i+="";if(i){if(typeof i==="string"&&!jb.test(i))i=b.createTextNode(i);else if(typeof i==="string"){i=i.replace(Ka,Ma);var o=(La.exec(i)||["",
+""])[1].toLowerCase(),k=F[o]||F._default,n=k[0],r=b.createElement("div");for(r.innerHTML=k[1]+i+k[2];n--;)r=r.lastChild;if(!c.support.tbody){n=ib.test(i);o=o==="table"&&!n?r.firstChild&&r.firstChild.childNodes:k[1]==="<table>"&&!n?r.childNodes:[];for(k=o.length-1;k>=0;--k)c.nodeName(o[k],"tbody")&&!o[k].childNodes.length&&o[k].parentNode.removeChild(o[k])}!c.support.leadingWhitespace&&V.test(i)&&r.insertBefore(b.createTextNode(V.exec(i)[0]),r.firstChild);i=r.childNodes}if(i.nodeType)e.push(i);else e=
+c.merge(e,i)}}if(d)for(j=0;e[j];j++)if(f&&c.nodeName(e[j],"script")&&(!e[j].type||e[j].type.toLowerCase()==="text/javascript"))f.push(e[j].parentNode?e[j].parentNode.removeChild(e[j]):e[j]);else{e[j].nodeType===1&&e.splice.apply(e,[j+1,0].concat(c.makeArray(e[j].getElementsByTagName("script"))));d.appendChild(e[j])}return e},cleanData:function(a){for(var b,d,f=c.cache,e=c.event.special,j=c.support.deleteExpando,i=0,o;(o=a[i])!=null;i++)if(d=o[c.expando]){b=f[d];if(b.events)for(var k in b.events)e[k]?
+c.event.remove(o,k):Ca(o,k,b.handle);if(j)delete o[c.expando];else o.removeAttribute&&o.removeAttribute(c.expando);delete f[d]}}});var kb=/z-?index|font-?weight|opacity|zoom|line-?height/i,Na=/alpha\([^)]*\)/,Oa=/opacity=([^)]*)/,ha=/float/i,ia=/-([a-z])/ig,lb=/([A-Z])/g,mb=/^-?\d+(?:px)?$/i,nb=/^-?\d/,ob={position:"absolute",visibility:"hidden",display:"block"},pb=["Left","Right"],qb=["Top","Bottom"],rb=s.defaultView&&s.defaultView.getComputedStyle,Pa=c.support.cssFloat?"cssFloat":"styleFloat",ja=
+function(a,b){return b.toUpperCase()};c.fn.css=function(a,b){return X(this,a,b,true,function(d,f,e){if(e===w)return c.curCSS(d,f);if(typeof e==="number"&&!kb.test(f))e+="px";c.style(d,f,e)})};c.extend({style:function(a,b,d){if(!a||a.nodeType===3||a.nodeType===8)return w;if((b==="width"||b==="height")&&parseFloat(d)<0)d=w;var f=a.style||a,e=d!==w;if(!c.support.opacity&&b==="opacity"){if(e){f.zoom=1;b=parseInt(d,10)+""==="NaN"?"":"alpha(opacity="+d*100+")";a=f.filter||c.curCSS(a,"filter")||"";f.filter=
+Na.test(a)?a.replace(Na,b):b}return f.filter&&f.filter.indexOf("opacity=")>=0?parseFloat(Oa.exec(f.filter)[1])/100+"":""}if(ha.test(b))b=Pa;b=b.replace(ia,ja);if(e)f[b]=d;return f[b]},css:function(a,b,d,f){if(b==="width"||b==="height"){var e,j=b==="width"?pb:qb;function i(){e=b==="width"?a.offsetWidth:a.offsetHeight;f!=="border"&&c.each(j,function(){f||(e-=parseFloat(c.curCSS(a,"padding"+this,true))||0);if(f==="margin")e+=parseFloat(c.curCSS(a,"margin"+this,true))||0;else e-=parseFloat(c.curCSS(a,
+"border"+this+"Width",true))||0})}a.offsetWidth!==0?i():c.swap(a,ob,i);return Math.max(0,Math.round(e))}return c.curCSS(a,b,d)},curCSS:function(a,b,d){var f,e=a.style;if(!c.support.opacity&&b==="opacity"&&a.currentStyle){f=Oa.test(a.currentStyle.filter||"")?parseFloat(RegExp.$1)/100+"":"";return f===""?"1":f}if(ha.test(b))b=Pa;if(!d&&e&&e[b])f=e[b];else if(rb){if(ha.test(b))b="float";b=b.replace(lb,"-$1").toLowerCase();e=a.ownerDocument.defaultView;if(!e)return null;if(a=e.getComputedStyle(a,null))f=
+a.getPropertyValue(b);if(b==="opacity"&&f==="")f="1"}else if(a.currentStyle){d=b.replace(ia,ja);f=a.currentStyle[b]||a.currentStyle[d];if(!mb.test(f)&&nb.test(f)){b=e.left;var j=a.runtimeStyle.left;a.runtimeStyle.left=a.currentStyle.left;e.left=d==="fontSize"?"1em":f||0;f=e.pixelLeft+"px";e.left=b;a.runtimeStyle.left=j}}return f},swap:function(a,b,d){var f={};for(var e in b){f[e]=a.style[e];a.style[e]=b[e]}d.call(a);for(e in b)a.style[e]=f[e]}});if(c.expr&&c.expr.filters){c.expr.filters.hidden=function(a){var b=
+a.offsetWidth,d=a.offsetHeight,f=a.nodeName.toLowerCase()==="tr";return b===0&&d===0&&!f?true:b>0&&d>0&&!f?false:c.curCSS(a,"display")==="none"};c.expr.filters.visible=function(a){return!c.expr.filters.hidden(a)}}var sb=J(),tb=/<script(.|\s)*?\/script>/gi,ub=/select|textarea/i,vb=/color|date|datetime|email|hidden|month|number|password|range|search|tel|text|time|url|week/i,N=/=\?(&|$)/,ka=/\?/,wb=/(\?|&)_=.*?(&|$)/,xb=/^(\w+:)?\/\/([^\/?#]+)/,yb=/%20/g,zb=c.fn.load;c.fn.extend({load:function(a,b,d){if(typeof a!==
+"string")return zb.call(this,a);else if(!this.length)return this;var f=a.indexOf(" ");if(f>=0){var e=a.slice(f,a.length);a=a.slice(0,f)}f="GET";if(b)if(c.isFunction(b)){d=b;b=null}else if(typeof b==="object"){b=c.param(b,c.ajaxSettings.traditional);f="POST"}var j=this;c.ajax({url:a,type:f,dataType:"html",data:b,complete:function(i,o){if(o==="success"||o==="notmodified")j.html(e?c("<div />").append(i.responseText.replace(tb,"")).find(e):i.responseText);d&&j.each(d,[i.responseText,o,i])}});return this},
+serialize:function(){return c.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?c.makeArray(this.elements):this}).filter(function(){return this.name&&!this.disabled&&(this.checked||ub.test(this.nodeName)||vb.test(this.type))}).map(function(a,b){a=c(this).val();return a==null?null:c.isArray(a)?c.map(a,function(d){return{name:b.name,value:d}}):{name:b.name,value:a}}).get()}});c.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "),
+function(a,b){c.fn[b]=function(d){return this.bind(b,d)}});c.extend({get:function(a,b,d,f){if(c.isFunction(b)){f=f||d;d=b;b=null}return c.ajax({type:"GET",url:a,data:b,success:d,dataType:f})},getScript:function(a,b){return c.get(a,null,b,"script")},getJSON:function(a,b,d){return c.get(a,b,d,"json")},post:function(a,b,d,f){if(c.isFunction(b)){f=f||d;d=b;b={}}return c.ajax({type:"POST",url:a,data:b,success:d,dataType:f})},ajaxSetup:function(a){c.extend(c.ajaxSettings,a)},ajaxSettings:{url:location.href,
+global:true,type:"GET",contentType:"application/x-www-form-urlencoded",processData:true,async:true,xhr:A.XMLHttpRequest&&(A.location.protocol!=="file:"||!A.ActiveXObject)?function(){return new A.XMLHttpRequest}:function(){try{return new A.ActiveXObject("Microsoft.XMLHTTP")}catch(a){}},accepts:{xml:"application/xml, text/xml",html:"text/html",script:"text/javascript, application/javascript",json:"application/json, text/javascript",text:"text/plain",_default:"*/*"}},lastModified:{},etag:{},ajax:function(a){function b(){e.success&&
+e.success.call(k,o,i,x);e.global&&f("ajaxSuccess",[x,e])}function d(){e.complete&&e.complete.call(k,x,i);e.global&&f("ajaxComplete",[x,e]);e.global&&!--c.active&&c.event.trigger("ajaxStop")}function f(q,p){(e.context?c(e.context):c.event).trigger(q,p)}var e=c.extend(true,{},c.ajaxSettings,a),j,i,o,k=a&&a.context||e,n=e.type.toUpperCase();if(e.data&&e.processData&&typeof e.data!=="string")e.data=c.param(e.data,e.traditional);if(e.dataType==="jsonp"){if(n==="GET")N.test(e.url)||(e.url+=(ka.test(e.url)?
+"&":"?")+(e.jsonp||"callback")+"=?");else if(!e.data||!N.test(e.data))e.data=(e.data?e.data+"&":"")+(e.jsonp||"callback")+"=?";e.dataType="json"}if(e.dataType==="json"&&(e.data&&N.test(e.data)||N.test(e.url))){j=e.jsonpCallback||"jsonp"+sb++;if(e.data)e.data=(e.data+"").replace(N,"="+j+"$1");e.url=e.url.replace(N,"="+j+"$1");e.dataType="script";A[j]=A[j]||function(q){o=q;b();d();A[j]=w;try{delete A[j]}catch(p){}z&&z.removeChild(C)}}if(e.dataType==="script"&&e.cache===null)e.cache=false;if(e.cache===
+false&&n==="GET"){var r=J(),u=e.url.replace(wb,"$1_="+r+"$2");e.url=u+(u===e.url?(ka.test(e.url)?"&":"?")+"_="+r:"")}if(e.data&&n==="GET")e.url+=(ka.test(e.url)?"&":"?")+e.data;e.global&&!c.active++&&c.event.trigger("ajaxStart");r=(r=xb.exec(e.url))&&(r[1]&&r[1]!==location.protocol||r[2]!==location.host);if(e.dataType==="script"&&n==="GET"&&r){var z=s.getElementsByTagName("head")[0]||s.documentElement,C=s.createElement("script");C.src=e.url;if(e.scriptCharset)C.charset=e.scriptCharset;if(!j){var B=
+false;C.onload=C.onreadystatechange=function(){if(!B&&(!this.readyState||this.readyState==="loaded"||this.readyState==="complete")){B=true;b();d();C.onload=C.onreadystatechange=null;z&&C.parentNode&&z.removeChild(C)}}}z.insertBefore(C,z.firstChild);return w}var E=false,x=e.xhr();if(x){e.username?x.open(n,e.url,e.async,e.username,e.password):x.open(n,e.url,e.async);try{if(e.data||a&&a.contentType)x.setRequestHeader("Content-Type",e.contentType);if(e.ifModified){c.lastModified[e.url]&&x.setRequestHeader("If-Modified-Since",
+c.lastModified[e.url]);c.etag[e.url]&&x.setRequestHeader("If-None-Match",c.etag[e.url])}r||x.setRequestHeader("X-Requested-With","XMLHttpRequest");x.setRequestHeader("Accept",e.dataType&&e.accepts[e.dataType]?e.accepts[e.dataType]+", */*":e.accepts._default)}catch(ga){}if(e.beforeSend&&e.beforeSend.call(k,x,e)===false){e.global&&!--c.active&&c.event.trigger("ajaxStop");x.abort();return false}e.global&&f("ajaxSend",[x,e]);var g=x.onreadystatechange=function(q){if(!x||x.readyState===0||q==="abort"){E||
+d();E=true;if(x)x.onreadystatechange=c.noop}else if(!E&&x&&(x.readyState===4||q==="timeout")){E=true;x.onreadystatechange=c.noop;i=q==="timeout"?"timeout":!c.httpSuccess(x)?"error":e.ifModified&&c.httpNotModified(x,e.url)?"notmodified":"success";var p;if(i==="success")try{o=c.httpData(x,e.dataType,e)}catch(v){i="parsererror";p=v}if(i==="success"||i==="notmodified")j||b();else c.handleError(e,x,i,p);d();q==="timeout"&&x.abort();if(e.async)x=null}};try{var h=x.abort;x.abort=function(){x&&h.call(x);
+g("abort")}}catch(l){}e.async&&e.timeout>0&&setTimeout(function(){x&&!E&&g("timeout")},e.timeout);try{x.send(n==="POST"||n==="PUT"||n==="DELETE"?e.data:null)}catch(m){c.handleError(e,x,null,m);d()}e.async||g();return x}},handleError:function(a,b,d,f){if(a.error)a.error.call(a.context||a,b,d,f);if(a.global)(a.context?c(a.context):c.event).trigger("ajaxError",[b,a,f])},active:0,httpSuccess:function(a){try{return!a.status&&location.protocol==="file:"||a.status>=200&&a.status<300||a.status===304||a.status===
+1223||a.status===0}catch(b){}return false},httpNotModified:function(a,b){var d=a.getResponseHeader("Last-Modified"),f=a.getResponseHeader("Etag");if(d)c.lastModified[b]=d;if(f)c.etag[b]=f;return a.status===304||a.status===0},httpData:function(a,b,d){var f=a.getResponseHeader("content-type")||"",e=b==="xml"||!b&&f.indexOf("xml")>=0;a=e?a.responseXML:a.responseText;e&&a.documentElement.nodeName==="parsererror"&&c.error("parsererror");if(d&&d.dataFilter)a=d.dataFilter(a,b);if(typeof a==="string")if(b===
+"json"||!b&&f.indexOf("json")>=0)a=c.parseJSON(a);else if(b==="script"||!b&&f.indexOf("javascript")>=0)c.globalEval(a);return a},param:function(a,b){function d(i,o){if(c.isArray(o))c.each(o,function(k,n){b||/\[\]$/.test(i)?f(i,n):d(i+"["+(typeof n==="object"||c.isArray(n)?k:"")+"]",n)});else!b&&o!=null&&typeof o==="object"?c.each(o,function(k,n){d(i+"["+k+"]",n)}):f(i,o)}function f(i,o){o=c.isFunction(o)?o():o;e[e.length]=encodeURIComponent(i)+"="+encodeURIComponent(o)}var e=[];if(b===w)b=c.ajaxSettings.traditional;
+if(c.isArray(a)||a.jquery)c.each(a,function(){f(this.name,this.value)});else for(var j in a)d(j,a[j]);return e.join("&").replace(yb,"+")}});var la={},Ab=/toggle|show|hide/,Bb=/^([+-]=)?([\d+-.]+)(.*)$/,W,va=[["height","marginTop","marginBottom","paddingTop","paddingBottom"],["width","marginLeft","marginRight","paddingLeft","paddingRight"],["opacity"]];c.fn.extend({show:function(a,b){if(a||a===0)return this.animate(K("show",3),a,b);else{a=0;for(b=this.length;a<b;a++){var d=c.data(this[a],"olddisplay");
+this[a].style.display=d||"";if(c.css(this[a],"display")==="none"){d=this[a].nodeName;var f;if(la[d])f=la[d];else{var e=c("<"+d+" />").appendTo("body");f=e.css("display");if(f==="none")f="block";e.remove();la[d]=f}c.data(this[a],"olddisplay",f)}}a=0;for(b=this.length;a<b;a++)this[a].style.display=c.data(this[a],"olddisplay")||"";return this}},hide:function(a,b){if(a||a===0)return this.animate(K("hide",3),a,b);else{a=0;for(b=this.length;a<b;a++){var d=c.data(this[a],"olddisplay");!d&&d!=="none"&&c.data(this[a],
+"olddisplay",c.css(this[a],"display"))}a=0;for(b=this.length;a<b;a++)this[a].style.display="none";return this}},_toggle:c.fn.toggle,toggle:function(a,b){var d=typeof a==="boolean";if(c.isFunction(a)&&c.isFunction(b))this._toggle.apply(this,arguments);else a==null||d?this.each(function(){var f=d?a:c(this).is(":hidden");c(this)[f?"show":"hide"]()}):this.animate(K("toggle",3),a,b);return this},fadeTo:function(a,b,d){return this.filter(":hidden").css("opacity",0).show().end().animate({opacity:b},a,d)},
+animate:function(a,b,d,f){var e=c.speed(b,d,f);if(c.isEmptyObject(a))return this.each(e.complete);return this[e.queue===false?"each":"queue"](function(){var j=c.extend({},e),i,o=this.nodeType===1&&c(this).is(":hidden"),k=this;for(i in a){var n=i.replace(ia,ja);if(i!==n){a[n]=a[i];delete a[i];i=n}if(a[i]==="hide"&&o||a[i]==="show"&&!o)return j.complete.call(this);if((i==="height"||i==="width")&&this.style){j.display=c.css(this,"display");j.overflow=this.style.overflow}if(c.isArray(a[i])){(j.specialEasing=
+j.specialEasing||{})[i]=a[i][1];a[i]=a[i][0]}}if(j.overflow!=null)this.style.overflow="hidden";j.curAnim=c.extend({},a);c.each(a,function(r,u){var z=new c.fx(k,j,r);if(Ab.test(u))z[u==="toggle"?o?"show":"hide":u](a);else{var C=Bb.exec(u),B=z.cur(true)||0;if(C){u=parseFloat(C[2]);var E=C[3]||"px";if(E!=="px"){k.style[r]=(u||1)+E;B=(u||1)/z.cur(true)*B;k.style[r]=B+E}if(C[1])u=(C[1]==="-="?-1:1)*u+B;z.custom(B,u,E)}else z.custom(B,u,"")}});return true})},stop:function(a,b){var d=c.timers;a&&this.queue([]);
+this.each(function(){for(var f=d.length-1;f>=0;f--)if(d[f].elem===this){b&&d[f](true);d.splice(f,1)}});b||this.dequeue();return this}});c.each({slideDown:K("show",1),slideUp:K("hide",1),slideToggle:K("toggle",1),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"}},function(a,b){c.fn[a]=function(d,f){return this.animate(b,d,f)}});c.extend({speed:function(a,b,d){var f=a&&typeof a==="object"?a:{complete:d||!d&&b||c.isFunction(a)&&a,duration:a,easing:d&&b||b&&!c.isFunction(b)&&b};f.duration=c.fx.off?0:typeof f.duration===
+"number"?f.duration:c.fx.speeds[f.duration]||c.fx.speeds._default;f.old=f.complete;f.complete=function(){f.queue!==false&&c(this).dequeue();c.isFunction(f.old)&&f.old.call(this)};return f},easing:{linear:function(a,b,d,f){return d+f*a},swing:function(a,b,d,f){return(-Math.cos(a*Math.PI)/2+0.5)*f+d}},timers:[],fx:function(a,b,d){this.options=b;this.elem=a;this.prop=d;if(!b.orig)b.orig={}}});c.fx.prototype={update:function(){this.options.step&&this.options.step.call(this.elem,this.now,this);(c.fx.step[this.prop]||
+c.fx.step._default)(this);if((this.prop==="height"||this.prop==="width")&&this.elem.style)this.elem.style.display="block"},cur:function(a){if(this.elem[this.prop]!=null&&(!this.elem.style||this.elem.style[this.prop]==null))return this.elem[this.prop];return(a=parseFloat(c.css(this.elem,this.prop,a)))&&a>-10000?a:parseFloat(c.curCSS(this.elem,this.prop))||0},custom:function(a,b,d){function f(j){return e.step(j)}this.startTime=J();this.start=a;this.end=b;this.unit=d||this.unit||"px";this.now=this.start;
+this.pos=this.state=0;var e=this;f.elem=this.elem;if(f()&&c.timers.push(f)&&!W)W=setInterval(c.fx.tick,13)},show:function(){this.options.orig[this.prop]=c.style(this.elem,this.prop);this.options.show=true;this.custom(this.prop==="width"||this.prop==="height"?1:0,this.cur());c(this.elem).show()},hide:function(){this.options.orig[this.prop]=c.style(this.elem,this.prop);this.options.hide=true;this.custom(this.cur(),0)},step:function(a){var b=J(),d=true;if(a||b>=this.options.duration+this.startTime){this.now=
+this.end;this.pos=this.state=1;this.update();this.options.curAnim[this.prop]=true;for(var f in this.options.curAnim)if(this.options.curAnim[f]!==true)d=false;if(d){if(this.options.display!=null){this.elem.style.overflow=this.options.overflow;a=c.data(this.elem,"olddisplay");this.elem.style.display=a?a:this.options.display;if(c.css(this.elem,"display")==="none")this.elem.style.display="block"}this.options.hide&&c(this.elem).hide();if(this.options.hide||this.options.show)for(var e in this.options.curAnim)c.style(this.elem,
+e,this.options.orig[e]);this.options.complete.call(this.elem)}return false}else{e=b-this.startTime;this.state=e/this.options.duration;a=this.options.easing||(c.easing.swing?"swing":"linear");this.pos=c.easing[this.options.specialEasing&&this.options.specialEasing[this.prop]||a](this.state,e,0,1,this.options.duration);this.now=this.start+(this.end-this.start)*this.pos;this.update()}return true}};c.extend(c.fx,{tick:function(){for(var a=c.timers,b=0;b<a.length;b++)a[b]()||a.splice(b--,1);a.length||
+c.fx.stop()},stop:function(){clearInterval(W);W=null},speeds:{slow:600,fast:200,_default:400},step:{opacity:function(a){c.style(a.elem,"opacity",a.now)},_default:function(a){if(a.elem.style&&a.elem.style[a.prop]!=null)a.elem.style[a.prop]=(a.prop==="width"||a.prop==="height"?Math.max(0,a.now):a.now)+a.unit;else a.elem[a.prop]=a.now}}});if(c.expr&&c.expr.filters)c.expr.filters.animated=function(a){return c.grep(c.timers,function(b){return a===b.elem}).length};c.fn.offset="getBoundingClientRect"in s.documentElement?
+function(a){var b=this[0];if(a)return this.each(function(e){c.offset.setOffset(this,a,e)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return c.offset.bodyOffset(b);var d=b.getBoundingClientRect(),f=b.ownerDocument;b=f.body;f=f.documentElement;return{top:d.top+(self.pageYOffset||c.support.boxModel&&f.scrollTop||b.scrollTop)-(f.clientTop||b.clientTop||0),left:d.left+(self.pageXOffset||c.support.boxModel&&f.scrollLeft||b.scrollLeft)-(f.clientLeft||b.clientLeft||0)}}:function(a){var b=
+this[0];if(a)return this.each(function(r){c.offset.setOffset(this,a,r)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return c.offset.bodyOffset(b);c.offset.initialize();var d=b.offsetParent,f=b,e=b.ownerDocument,j,i=e.documentElement,o=e.body;f=(e=e.defaultView)?e.getComputedStyle(b,null):b.currentStyle;for(var k=b.offsetTop,n=b.offsetLeft;(b=b.parentNode)&&b!==o&&b!==i;){if(c.offset.supportsFixedPosition&&f.position==="fixed")break;j=e?e.getComputedStyle(b,null):b.currentStyle;
+k-=b.scrollTop;n-=b.scrollLeft;if(b===d){k+=b.offsetTop;n+=b.offsetLeft;if(c.offset.doesNotAddBorder&&!(c.offset.doesAddBorderForTableAndCells&&/^t(able|d|h)$/i.test(b.nodeName))){k+=parseFloat(j.borderTopWidth)||0;n+=parseFloat(j.borderLeftWidth)||0}f=d;d=b.offsetParent}if(c.offset.subtractsBorderForOverflowNotVisible&&j.overflow!=="visible"){k+=parseFloat(j.borderTopWidth)||0;n+=parseFloat(j.borderLeftWidth)||0}f=j}if(f.position==="relative"||f.position==="static"){k+=o.offsetTop;n+=o.offsetLeft}if(c.offset.supportsFixedPosition&&
+f.position==="fixed"){k+=Math.max(i.scrollTop,o.scrollTop);n+=Math.max(i.scrollLeft,o.scrollLeft)}return{top:k,left:n}};c.offset={initialize:function(){var a=s.body,b=s.createElement("div"),d,f,e,j=parseFloat(c.curCSS(a,"marginTop",true))||0;c.extend(b.style,{position:"absolute",top:0,left:0,margin:0,border:0,width:"1px",height:"1px",visibility:"hidden"});b.innerHTML="<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div><table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>";
+a.insertBefore(b,a.firstChild);d=b.firstChild;f=d.firstChild;e=d.nextSibling.firstChild.firstChild;this.doesNotAddBorder=f.offsetTop!==5;this.doesAddBorderForTableAndCells=e.offsetTop===5;f.style.position="fixed";f.style.top="20px";this.supportsFixedPosition=f.offsetTop===20||f.offsetTop===15;f.style.position=f.style.top="";d.style.overflow="hidden";d.style.position="relative";this.subtractsBorderForOverflowNotVisible=f.offsetTop===-5;this.doesNotIncludeMarginInBodyOffset=a.offsetTop!==j;a.removeChild(b);
+c.offset.initialize=c.noop},bodyOffset:function(a){var b=a.offsetTop,d=a.offsetLeft;c.offset.initialize();if(c.offset.doesNotIncludeMarginInBodyOffset){b+=parseFloat(c.curCSS(a,"marginTop",true))||0;d+=parseFloat(c.curCSS(a,"marginLeft",true))||0}return{top:b,left:d}},setOffset:function(a,b,d){if(/static/.test(c.curCSS(a,"position")))a.style.position="relative";var f=c(a),e=f.offset(),j=parseInt(c.curCSS(a,"top",true),10)||0,i=parseInt(c.curCSS(a,"left",true),10)||0;if(c.isFunction(b))b=b.call(a,
+d,e);d={top:b.top-e.top+j,left:b.left-e.left+i};"using"in b?b.using.call(a,d):f.css(d)}};c.fn.extend({position:function(){if(!this[0])return null;var a=this[0],b=this.offsetParent(),d=this.offset(),f=/^body|html$/i.test(b[0].nodeName)?{top:0,left:0}:b.offset();d.top-=parseFloat(c.curCSS(a,"marginTop",true))||0;d.left-=parseFloat(c.curCSS(a,"marginLeft",true))||0;f.top+=parseFloat(c.curCSS(b[0],"borderTopWidth",true))||0;f.left+=parseFloat(c.curCSS(b[0],"borderLeftWidth",true))||0;return{top:d.top-
+f.top,left:d.left-f.left}},offsetParent:function(){return this.map(function(){for(var a=this.offsetParent||s.body;a&&!/^body|html$/i.test(a.nodeName)&&c.css(a,"position")==="static";)a=a.offsetParent;return a})}});c.each(["Left","Top"],function(a,b){var d="scroll"+b;c.fn[d]=function(f){var e=this[0],j;if(!e)return null;if(f!==w)return this.each(function(){if(j=wa(this))j.scrollTo(!a?f:c(j).scrollLeft(),a?f:c(j).scrollTop());else this[d]=f});else return(j=wa(e))?"pageXOffset"in j?j[a?"pageYOffset":
+"pageXOffset"]:c.support.boxModel&&j.document.documentElement[d]||j.document.body[d]:e[d]}});c.each(["Height","Width"],function(a,b){var d=b.toLowerCase();c.fn["inner"+b]=function(){return this[0]?c.css(this[0],d,false,"padding"):null};c.fn["outer"+b]=function(f){return this[0]?c.css(this[0],d,false,f?"margin":"border"):null};c.fn[d]=function(f){var e=this[0];if(!e)return f==null?null:this;if(c.isFunction(f))return this.each(function(j){var i=c(this);i[d](f.call(this,j,i[d]()))});return"scrollTo"in
+e&&e.document?e.document.compatMode==="CSS1Compat"&&e.document.documentElement["client"+b]||e.document.body["client"+b]:e.nodeType===9?Math.max(e.documentElement["client"+b],e.body["scroll"+b],e.documentElement["scroll"+b],e.body["offset"+b],e.documentElement["offset"+b]):f===w?c.css(e,d):this.css(d,typeof f==="string"?f:f+"px")}});A.jQuery=A.$=c})(window);
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/minus.png b/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/minus.png
new file mode 100644
index 0000000000000000000000000000000000000000..da1c5620d10c047525a467a425abe9ff5269cfc2
GIT binary patch
literal 199
zcmeAS@N?(olHy`uVBq!ia0vp^+#t-s1SHkYJtzcHoCO|{#XvD(5N2eUHAey{$X?><
z>&kweokM_|(Po{+Q=kw>iEBiObAE1aYF-J$w=>iB1I2<oT^vIsE+^X*KjUGJJ8<a0
zfdz{eHHE&rzrX(bySvGUL|lavlN4AuRwpzDOq(`sMv;5Joa+jUx<3|oWPN;mPUJ0`
pW__Wi<5+59Lc)&n_i}Q^3>R$WLpMkF=>bh=@O1TaS?83{1OVknK<NMg

literal 0
HcmV?d00001

diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/plus.png b/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/plus.png
new file mode 100644
index 0000000000000000000000000000000000000000..b3cb37425ea68b39ffa7b2e5fb69161275a87541
GIT binary patch
literal 199
zcmeAS@N?(olHy`uVBq!ia0vp^+#t-s1SHkYJtzcHoCO|{#XvD(5N2eUHAey{$X?><
z>&kweokM`jkU7Va11Q8%;u=xnoS&PUnpeW`?aZ|OK(QcC7sn8Z%gHvy&v=;Q4jejg
zV8NnAO`-4Z@2~&<?ryS^@YXF`T!a&o6j(S`Cmb}9IcHb(MZ@Xn$H&JXUMl#uzyAM<
o7knL=1-mEi3=josIGoJJAh%tCVFz!`HlXPYp00i_>zopr02WF_WB>pF

literal 0
HcmV?d00001

diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/pygments.css b/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/pygments.css
new file mode 100644
index 0000000..1a14f2a
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/pygments.css
@@ -0,0 +1,62 @@
+.highlight .hll { background-color: #ffffcc }
+.highlight  { background: #eeffcc; }
+.highlight .c { color: #408090; font-style: italic } /* Comment */
+.highlight .err { border: 1px solid #FF0000 } /* Error */
+.highlight .k { color: #007020; font-weight: bold } /* Keyword */
+.highlight .o { color: #666666 } /* Operator */
+.highlight .cm { color: #408090; font-style: italic } /* Comment.Multiline */
+.highlight .cp { color: #007020 } /* Comment.Preproc */
+.highlight .c1 { color: #408090; font-style: italic } /* Comment.Single */
+.highlight .cs { color: #408090; background-color: #fff0f0 } /* Comment.Special */
+.highlight .gd { color: #A00000 } /* Generic.Deleted */
+.highlight .ge { font-style: italic } /* Generic.Emph */
+.highlight .gr { color: #FF0000 } /* Generic.Error */
+.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
+.highlight .gi { color: #00A000 } /* Generic.Inserted */
+.highlight .go { color: #303030 } /* Generic.Output */
+.highlight .gp { color: #c65d09; font-weight: bold } /* Generic.Prompt */
+.highlight .gs { font-weight: bold } /* Generic.Strong */
+.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
+.highlight .gt { color: #0040D0 } /* Generic.Traceback */
+.highlight .kc { color: #007020; font-weight: bold } /* Keyword.Constant */
+.highlight .kd { color: #007020; font-weight: bold } /* Keyword.Declaration */
+.highlight .kn { color: #007020; font-weight: bold } /* Keyword.Namespace */
+.highlight .kp { color: #007020 } /* Keyword.Pseudo */
+.highlight .kr { color: #007020; font-weight: bold } /* Keyword.Reserved */
+.highlight .kt { color: #902000 } /* Keyword.Type */
+.highlight .m { color: #208050 } /* Literal.Number */
+.highlight .s { color: #4070a0 } /* Literal.String */
+.highlight .na { color: #4070a0 } /* Name.Attribute */
+.highlight .nb { color: #007020 } /* Name.Builtin */
+.highlight .nc { color: #0e84b5; font-weight: bold } /* Name.Class */
+.highlight .no { color: #60add5 } /* Name.Constant */
+.highlight .nd { color: #555555; font-weight: bold } /* Name.Decorator */
+.highlight .ni { color: #d55537; font-weight: bold } /* Name.Entity */
+.highlight .ne { color: #007020 } /* Name.Exception */
+.highlight .nf { color: #06287e } /* Name.Function */
+.highlight .nl { color: #002070; font-weight: bold } /* Name.Label */
+.highlight .nn { color: #0e84b5; font-weight: bold } /* Name.Namespace */
+.highlight .nt { color: #062873; font-weight: bold } /* Name.Tag */
+.highlight .nv { color: #bb60d5 } /* Name.Variable */
+.highlight .ow { color: #007020; font-weight: bold } /* Operator.Word */
+.highlight .w { color: #bbbbbb } /* Text.Whitespace */
+.highlight .mf { color: #208050 } /* Literal.Number.Float */
+.highlight .mh { color: #208050 } /* Literal.Number.Hex */
+.highlight .mi { color: #208050 } /* Literal.Number.Integer */
+.highlight .mo { color: #208050 } /* Literal.Number.Oct */
+.highlight .sb { color: #4070a0 } /* Literal.String.Backtick */
+.highlight .sc { color: #4070a0 } /* Literal.String.Char */
+.highlight .sd { color: #4070a0; font-style: italic } /* Literal.String.Doc */
+.highlight .s2 { color: #4070a0 } /* Literal.String.Double */
+.highlight .se { color: #4070a0; font-weight: bold } /* Literal.String.Escape */
+.highlight .sh { color: #4070a0 } /* Literal.String.Heredoc */
+.highlight .si { color: #70a0d0; font-style: italic } /* Literal.String.Interpol */
+.highlight .sx { color: #c65d09 } /* Literal.String.Other */
+.highlight .sr { color: #235388 } /* Literal.String.Regex */
+.highlight .s1 { color: #4070a0 } /* Literal.String.Single */
+.highlight .ss { color: #517918 } /* Literal.String.Symbol */
+.highlight .bp { color: #007020 } /* Name.Builtin.Pseudo */
+.highlight .vc { color: #bb60d5 } /* Name.Variable.Class */
+.highlight .vg { color: #bb60d5 } /* Name.Variable.Global */
+.highlight .vi { color: #bb60d5 } /* Name.Variable.Instance */
+.highlight .il { color: #208050 } /* Literal.Number.Integer.Long */
\ No newline at end of file
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/searchtools.js b/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/searchtools.js
new file mode 100644
index 0000000..663be4c
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/searchtools.js
@@ -0,0 +1,560 @@
+/*
+ * searchtools.js_t
+ * ~~~~~~~~~~~~~~~~
+ *
+ * Sphinx JavaScript utilties for the full-text search.
+ *
+ * :copyright: Copyright 2007-2011 by the Sphinx team, see AUTHORS.
+ * :license: BSD, see LICENSE for details.
+ *
+ */
+
+/**
+ * helper function to return a node containing the
+ * search summary for a given text. keywords is a list
+ * of stemmed words, hlwords is the list of normal, unstemmed
+ * words. the first one is used to find the occurance, the
+ * latter for highlighting it.
+ */
+
+jQuery.makeSearchSummary = function(text, keywords, hlwords) {
+  var textLower = text.toLowerCase();
+  var start = 0;
+  $.each(keywords, function() {
+    var i = textLower.indexOf(this.toLowerCase());
+    if (i > -1)
+      start = i;
+  });
+  start = Math.max(start - 120, 0);
+  var excerpt = ((start > 0) ? '...' : '') +
+  $.trim(text.substr(start, 240)) +
+  ((start + 240 - text.length) ? '...' : '');
+  var rv = $('<div class="context"></div>').text(excerpt);
+  $.each(hlwords, function() {
+    rv = rv.highlightText(this, 'highlighted');
+  });
+  return rv;
+}
+
+
+/**
+ * Porter Stemmer
+ */
+var Stemmer = function() {
+
+  var step2list = {
+    ational: 'ate',
+    tional: 'tion',
+    enci: 'ence',
+    anci: 'ance',
+    izer: 'ize',
+    bli: 'ble',
+    alli: 'al',
+    entli: 'ent',
+    eli: 'e',
+    ousli: 'ous',
+    ization: 'ize',
+    ation: 'ate',
+    ator: 'ate',
+    alism: 'al',
+    iveness: 'ive',
+    fulness: 'ful',
+    ousness: 'ous',
+    aliti: 'al',
+    iviti: 'ive',
+    biliti: 'ble',
+    logi: 'log'
+  };
+
+  var step3list = {
+    icate: 'ic',
+    ative: '',
+    alize: 'al',
+    iciti: 'ic',
+    ical: 'ic',
+    ful: '',
+    ness: ''
+  };
+
+  var c = "[^aeiou]";          // consonant
+  var v = "[aeiouy]";          // vowel
+  var C = c + "[^aeiouy]*";    // consonant sequence
+  var V = v + "[aeiou]*";      // vowel sequence
+
+  var mgr0 = "^(" + C + ")?" + V + C;                      // [C]VC... is m>0
+  var meq1 = "^(" + C + ")?" + V + C + "(" + V + ")?$";    // [C]VC[V] is m=1
+  var mgr1 = "^(" + C + ")?" + V + C + V + C;              // [C]VCVC... is m>1
+  var s_v   = "^(" + C + ")?" + v;                         // vowel in stem
+
+  this.stemWord = function (w) {
+    var stem;
+    var suffix;
+    var firstch;
+    var origword = w;
+
+    if (w.length < 3)
+      return w;
+
+    var re;
+    var re2;
+    var re3;
+    var re4;
+
+    firstch = w.substr(0,1);
+    if (firstch == "y")
+      w = firstch.toUpperCase() + w.substr(1);
+
+    // Step 1a
+    re = /^(.+?)(ss|i)es$/;
+    re2 = /^(.+?)([^s])s$/;
+
+    if (re.test(w))
+      w = w.replace(re,"$1$2");
+    else if (re2.test(w))
+      w = w.replace(re2,"$1$2");
+
+    // Step 1b
+    re = /^(.+?)eed$/;
+    re2 = /^(.+?)(ed|ing)$/;
+    if (re.test(w)) {
+      var fp = re.exec(w);
+      re = new RegExp(mgr0);
+      if (re.test(fp[1])) {
+        re = /.$/;
+        w = w.replace(re,"");
+      }
+    }
+    else if (re2.test(w)) {
+      var fp = re2.exec(w);
+      stem = fp[1];
+      re2 = new RegExp(s_v);
+      if (re2.test(stem)) {
+        w = stem;
+        re2 = /(at|bl|iz)$/;
+        re3 = new RegExp("([^aeiouylsz])\\1$");
+        re4 = new RegExp("^" + C + v + "[^aeiouwxy]$");
+        if (re2.test(w))
+          w = w + "e";
+        else if (re3.test(w)) {
+          re = /.$/;
+          w = w.replace(re,"");
+        }
+        else if (re4.test(w))
+          w = w + "e";
+      }
+    }
+
+    // Step 1c
+    re = /^(.+?)y$/;
+    if (re.test(w)) {
+      var fp = re.exec(w);
+      stem = fp[1];
+      re = new RegExp(s_v);
+      if (re.test(stem))
+        w = stem + "i";
+    }
+
+    // Step 2
+    re = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;
+    if (re.test(w)) {
+      var fp = re.exec(w);
+      stem = fp[1];
+      suffix = fp[2];
+      re = new RegExp(mgr0);
+      if (re.test(stem))
+        w = stem + step2list[suffix];
+    }
+
+    // Step 3
+    re = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;
+    if (re.test(w)) {
+      var fp = re.exec(w);
+      stem = fp[1];
+      suffix = fp[2];
+      re = new RegExp(mgr0);
+      if (re.test(stem))
+        w = stem + step3list[suffix];
+    }
+
+    // Step 4
+    re = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;
+    re2 = /^(.+?)(s|t)(ion)$/;
+    if (re.test(w)) {
+      var fp = re.exec(w);
+      stem = fp[1];
+      re = new RegExp(mgr1);
+      if (re.test(stem))
+        w = stem;
+    }
+    else if (re2.test(w)) {
+      var fp = re2.exec(w);
+      stem = fp[1] + fp[2];
+      re2 = new RegExp(mgr1);
+      if (re2.test(stem))
+        w = stem;
+    }
+
+    // Step 5
+    re = /^(.+?)e$/;
+    if (re.test(w)) {
+      var fp = re.exec(w);
+      stem = fp[1];
+      re = new RegExp(mgr1);
+      re2 = new RegExp(meq1);
+      re3 = new RegExp("^" + C + v + "[^aeiouwxy]$");
+      if (re.test(stem) || (re2.test(stem) && !(re3.test(stem))))
+        w = stem;
+    }
+    re = /ll$/;
+    re2 = new RegExp(mgr1);
+    if (re.test(w) && re2.test(w)) {
+      re = /.$/;
+      w = w.replace(re,"");
+    }
+
+    // and turn initial Y back to y
+    if (firstch == "y")
+      w = firstch.toLowerCase() + w.substr(1);
+    return w;
+  }
+}
+
+
+/**
+ * Search Module
+ */
+var Search = {
+
+  _index : null,
+  _queued_query : null,
+  _pulse_status : -1,
+
+  init : function() {
+      var params = $.getQueryParameters();
+      if (params.q) {
+          var query = params.q[0];
+          $('input[name="q"]')[0].value = query;
+          this.performSearch(query);
+      }
+  },
+
+  loadIndex : function(url) {
+    $.ajax({type: "GET", url: url, data: null, success: null,
+            dataType: "script", cache: true});
+  },
+
+  setIndex : function(index) {
+    var q;
+    this._index = index;
+    if ((q = this._queued_query) !== null) {
+      this._queued_query = null;
+      Search.query(q);
+    }
+  },
+
+  hasIndex : function() {
+      return this._index !== null;
+  },
+
+  deferQuery : function(query) {
+      this._queued_query = query;
+  },
+
+  stopPulse : function() {
+      this._pulse_status = 0;
+  },
+
+  startPulse : function() {
+    if (this._pulse_status >= 0)
+        return;
+    function pulse() {
+      Search._pulse_status = (Search._pulse_status + 1) % 4;
+      var dotString = '';
+      for (var i = 0; i < Search._pulse_status; i++)
+        dotString += '.';
+      Search.dots.text(dotString);
+      if (Search._pulse_status > -1)
+        window.setTimeout(pulse, 500);
+    };
+    pulse();
+  },
+
+  /**
+   * perform a search for something
+   */
+  performSearch : function(query) {
+    // create the required interface elements
+    this.out = $('#search-results');
+    this.title = $('<h2>' + _('Searching') + '</h2>').appendTo(this.out);
+    this.dots = $('<span></span>').appendTo(this.title);
+    this.status = $('<p style="display: none"></p>').appendTo(this.out);
+    this.output = $('<ul class="search"/>').appendTo(this.out);
+
+    $('#search-progress').text(_('Preparing search...'));
+    this.startPulse();
+
+    // index already loaded, the browser was quick!
+    if (this.hasIndex())
+      this.query(query);
+    else
+      this.deferQuery(query);
+  },
+
+  query : function(query) {
+    var stopwords = ["and","then","into","it","as","are","in","if","for","no","there","their","was","is","be","to","that","but","they","not","such","with","by","a","on","these","of","will","this","near","the","or","at"];
+
+    // Stem the searchterms and add them to the correct list
+    var stemmer = new Stemmer();
+    var searchterms = [];
+    var excluded = [];
+    var hlterms = [];
+    var tmp = query.split(/\s+/);
+    var objectterms = [];
+    for (var i = 0; i < tmp.length; i++) {
+      if (tmp[i] != "") {
+          objectterms.push(tmp[i].toLowerCase());
+      }
+
+      if ($u.indexOf(stopwords, tmp[i]) != -1 || tmp[i].match(/^\d+$/) ||
+          tmp[i] == "") {
+        // skip this "word"
+        continue;
+      }
+      // stem the word
+      var word = stemmer.stemWord(tmp[i]).toLowerCase();
+      // select the correct list
+      if (word[0] == '-') {
+        var toAppend = excluded;
+        word = word.substr(1);
+      }
+      else {
+        var toAppend = searchterms;
+        hlterms.push(tmp[i].toLowerCase());
+      }
+      // only add if not already in the list
+      if (!$.contains(toAppend, word))
+        toAppend.push(word);
+    };
+    var highlightstring = '?highlight=' + $.urlencode(hlterms.join(" "));
+
+    // console.debug('SEARCH: searching for:');
+    // console.info('required: ', searchterms);
+    // console.info('excluded: ', excluded);
+
+    // prepare search
+    var filenames = this._index.filenames;
+    var titles = this._index.titles;
+    var terms = this._index.terms;
+    var fileMap = {};
+    var files = null;
+    // different result priorities
+    var importantResults = [];
+    var objectResults = [];
+    var regularResults = [];
+    var unimportantResults = [];
+    $('#search-progress').empty();
+
+    // lookup as object
+    for (var i = 0; i < objectterms.length; i++) {
+      var others = [].concat(objectterms.slice(0,i),
+                             objectterms.slice(i+1, objectterms.length))
+      var results = this.performObjectSearch(objectterms[i], others);
+      // Assume first word is most likely to be the object,
+      // other words more likely to be in description.
+      // Therefore put matches for earlier words first.
+      // (Results are eventually used in reverse order).
+      objectResults = results[0].concat(objectResults);
+      importantResults = results[1].concat(importantResults);
+      unimportantResults = results[2].concat(unimportantResults);
+    }
+
+    // perform the search on the required terms
+    for (var i = 0; i < searchterms.length; i++) {
+      var word = searchterms[i];
+      // no match but word was a required one
+      if ((files = terms[word]) == null)
+        break;
+      if (files.length == undefined) {
+        files = [files];
+      }
+      // create the mapping
+      for (var j = 0; j < files.length; j++) {
+        var file = files[j];
+        if (file in fileMap)
+          fileMap[file].push(word);
+        else
+          fileMap[file] = [word];
+      }
+    }
+
+    // now check if the files don't contain excluded terms
+    for (var file in fileMap) {
+      var valid = true;
+
+      // check if all requirements are matched
+      if (fileMap[file].length != searchterms.length)
+        continue;
+
+      // ensure that none of the excluded terms is in the
+      // search result.
+      for (var i = 0; i < excluded.length; i++) {
+        if (terms[excluded[i]] == file ||
+            $.contains(terms[excluded[i]] || [], file)) {
+          valid = false;
+          break;
+        }
+      }
+
+      // if we have still a valid result we can add it
+      // to the result list
+      if (valid)
+        regularResults.push([filenames[file], titles[file], '', null]);
+    }
+
+    // delete unused variables in order to not waste
+    // memory until list is retrieved completely
+    delete filenames, titles, terms;
+
+    // now sort the regular results descending by title
+    regularResults.sort(function(a, b) {
+      var left = a[1].toLowerCase();
+      var right = b[1].toLowerCase();
+      return (left > right) ? -1 : ((left < right) ? 1 : 0);
+    });
+
+    // combine all results
+    var results = unimportantResults.concat(regularResults)
+      .concat(objectResults).concat(importantResults);
+
+    // print the results
+    var resultCount = results.length;
+    function displayNextItem() {
+      // results left, load the summary and display it
+      if (results.length) {
+        var item = results.pop();
+        var listItem = $('<li style="display:none"></li>');
+        if (DOCUMENTATION_OPTIONS.FILE_SUFFIX == '') {
+          // dirhtml builder
+          var dirname = item[0] + '/';
+          if (dirname.match(/\/index\/$/)) {
+            dirname = dirname.substring(0, dirname.length-6);
+          } else if (dirname == 'index/') {
+            dirname = '';
+          }
+          listItem.append($('<a/>').attr('href',
+            DOCUMENTATION_OPTIONS.URL_ROOT + dirname +
+            highlightstring + item[2]).html(item[1]));
+        } else {
+          // normal html builders
+          listItem.append($('<a/>').attr('href',
+            item[0] + DOCUMENTATION_OPTIONS.FILE_SUFFIX +
+            highlightstring + item[2]).html(item[1]));
+        }
+        if (item[3]) {
+          listItem.append($('<span> (' + item[3] + ')</span>'));
+          Search.output.append(listItem);
+          listItem.slideDown(5, function() {
+            displayNextItem();
+          });
+        } else if (DOCUMENTATION_OPTIONS.HAS_SOURCE) {
+          $.get(DOCUMENTATION_OPTIONS.URL_ROOT + '_sources/' +
+                item[0] + '.txt', function(data) {
+            if (data != '') {
+              listItem.append($.makeSearchSummary(data, searchterms, hlterms));
+              Search.output.append(listItem);
+            }
+            listItem.slideDown(5, function() {
+              displayNextItem();
+            });
+          }, "text");
+        } else {
+          // no source available, just display title
+          Search.output.append(listItem);
+          listItem.slideDown(5, function() {
+            displayNextItem();
+          });
+        }
+      }
+      // search finished, update title and status message
+      else {
+        Search.stopPulse();
+        Search.title.text(_('Search Results'));
+        if (!resultCount)
+          Search.status.text(_('Your search did not match any documents. Please make sure that all words are spelled correctly and that you\'ve selected enough categories.'));
+        else
+            Search.status.text(_('Search finished, found %s page(s) matching the search query.').replace('%s', resultCount));
+        Search.status.fadeIn(500);
+      }
+    }
+    displayNextItem();
+  },
+
+  performObjectSearch : function(object, otherterms) {
+    var filenames = this._index.filenames;
+    var objects = this._index.objects;
+    var objnames = this._index.objnames;
+    var titles = this._index.titles;
+
+    var importantResults = [];
+    var objectResults = [];
+    var unimportantResults = [];
+
+    for (var prefix in objects) {
+      for (var name in objects[prefix]) {
+        var fullname = (prefix ? prefix + '.' : '') + name;
+        if (fullname.toLowerCase().indexOf(object) > -1) {
+          var match = objects[prefix][name];
+          var objname = objnames[match[1]][2];
+          var title = titles[match[0]];
+          // If more than one term searched for, we require other words to be
+          // found in the name/title/description
+          if (otherterms.length > 0) {
+            var haystack = (prefix + ' ' + name + ' ' +
+                            objname + ' ' + title).toLowerCase();
+            var allfound = true;
+            for (var i = 0; i < otherterms.length; i++) {
+              if (haystack.indexOf(otherterms[i]) == -1) {
+                allfound = false;
+                break;
+              }
+            }
+            if (!allfound) {
+              continue;
+            }
+          }
+          var descr = objname + _(', in ') + title;
+          anchor = match[3];
+          if (anchor == '')
+            anchor = fullname;
+          else if (anchor == '-')
+            anchor = objnames[match[1]][1] + '-' + fullname;
+          result = [filenames[match[0]], fullname, '#'+anchor, descr];
+          switch (match[2]) {
+          case 1: objectResults.push(result); break;
+          case 0: importantResults.push(result); break;
+          case 2: unimportantResults.push(result); break;
+          }
+        }
+      }
+    }
+
+    // sort results descending
+    objectResults.sort(function(a, b) {
+      return (a[1] > b[1]) ? -1 : ((a[1] < b[1]) ? 1 : 0);
+    });
+
+    importantResults.sort(function(a, b) {
+      return (a[1] > b[1]) ? -1 : ((a[1] < b[1]) ? 1 : 0);
+    });
+
+    unimportantResults.sort(function(a, b) {
+      return (a[1] > b[1]) ? -1 : ((a[1] < b[1]) ? 1 : 0);
+    });
+
+    return [importantResults, objectResults, unimportantResults]
+  }
+}
+
+$(document).ready(function() {
+  Search.init();
+});
\ No newline at end of file
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/sidebar.js b/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/sidebar.js
new file mode 100644
index 0000000..a45e192
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/sidebar.js
@@ -0,0 +1,151 @@
+/*
+ * sidebar.js
+ * ~~~~~~~~~~
+ *
+ * This script makes the Sphinx sidebar collapsible.
+ *
+ * .sphinxsidebar contains .sphinxsidebarwrapper.  This script adds
+ * in .sphixsidebar, after .sphinxsidebarwrapper, the #sidebarbutton
+ * used to collapse and expand the sidebar.
+ *
+ * When the sidebar is collapsed the .sphinxsidebarwrapper is hidden
+ * and the width of the sidebar and the margin-left of the document
+ * are decreased. When the sidebar is expanded the opposite happens.
+ * This script saves a per-browser/per-session cookie used to
+ * remember the position of the sidebar among the pages.
+ * Once the browser is closed the cookie is deleted and the position
+ * reset to the default (expanded).
+ *
+ * :copyright: Copyright 2007-2011 by the Sphinx team, see AUTHORS.
+ * :license: BSD, see LICENSE for details.
+ *
+ */
+
+$(function() {
+  // global elements used by the functions.
+  // the 'sidebarbutton' element is defined as global after its
+  // creation, in the add_sidebar_button function
+  var bodywrapper = $('.bodywrapper');
+  var sidebar = $('.sphinxsidebar');
+  var sidebarwrapper = $('.sphinxsidebarwrapper');
+
+  // for some reason, the document has no sidebar; do not run into errors
+  if (!sidebar.length) return;
+
+  // original margin-left of the bodywrapper and width of the sidebar
+  // with the sidebar expanded
+  var bw_margin_expanded = bodywrapper.css('margin-left');
+  var ssb_width_expanded = sidebar.width();
+
+  // margin-left of the bodywrapper and width of the sidebar
+  // with the sidebar collapsed
+  var bw_margin_collapsed = '.8em';
+  var ssb_width_collapsed = '.8em';
+
+  // colors used by the current theme
+  var dark_color = $('.related').css('background-color');
+  var light_color = $('.document').css('background-color');
+
+  function sidebar_is_collapsed() {
+    return sidebarwrapper.is(':not(:visible)');
+  }
+
+  function toggle_sidebar() {
+    if (sidebar_is_collapsed())
+      expand_sidebar();
+    else
+      collapse_sidebar();
+  }
+
+  function collapse_sidebar() {
+    sidebarwrapper.hide();
+    sidebar.css('width', ssb_width_collapsed);
+    bodywrapper.css('margin-left', bw_margin_collapsed);
+    sidebarbutton.css({
+        'margin-left': '0',
+        'height': bodywrapper.height()
+    });
+    sidebarbutton.find('span').text('');
+    sidebarbutton.attr('title', _('Expand sidebar'));
+    document.cookie = 'sidebar=collapsed';
+  }
+
+  function expand_sidebar() {
+    bodywrapper.css('margin-left', bw_margin_expanded);
+    sidebar.css('width', ssb_width_expanded);
+    sidebarwrapper.show();
+    sidebarbutton.css({
+        'margin-left': ssb_width_expanded-12,
+        'height': bodywrapper.height()
+    });
+    sidebarbutton.find('span').text('');
+    sidebarbutton.attr('title', _('Collapse sidebar'));
+    document.cookie = 'sidebar=expanded';
+  }
+
+  function add_sidebar_button() {
+    sidebarwrapper.css({
+        'float': 'left',
+        'margin-right': '0',
+        'width': ssb_width_expanded - 28
+    });
+    // create the button
+    sidebar.append(
+        '<div id="sidebarbutton"><span>&laquo;</span></div>'
+    );
+    var sidebarbutton = $('#sidebarbutton');
+    light_color = sidebarbutton.css('background-color');
+    // find the height of the viewport to center the '<<' in the page
+    var viewport_height;
+    if (window.innerHeight)
+ 	  viewport_height = window.innerHeight;
+    else
+	  viewport_height = $(window).height();
+    sidebarbutton.find('span').css({
+        'display': 'block',
+        'margin-top': (viewport_height - sidebar.position().top - 20) / 2
+    });
+
+    sidebarbutton.click(toggle_sidebar);
+    sidebarbutton.attr('title', _('Collapse sidebar'));
+    sidebarbutton.css({
+        'color': '#FFFFFF',
+        'border-left': '1px solid ' + dark_color,
+        'font-size': '1.2em',
+        'cursor': 'pointer',
+        'height': bodywrapper.height(),
+        'padding-top': '1px',
+        'margin-left': ssb_width_expanded - 12
+    });
+
+    sidebarbutton.hover(
+      function () {
+          $(this).css('background-color', dark_color);
+      },
+      function () {
+          $(this).css('background-color', light_color);
+      }
+    );
+  }
+
+  function set_position_from_cookie() {
+    if (!document.cookie)
+      return;
+    var items = document.cookie.split(';');
+    for(var k=0; k<items.length; k++) {
+      var key_val = items[k].split('=');
+      var key = key_val[0];
+      if (key == 'sidebar') {
+        var value = key_val[1];
+        if ((value == 'collapsed') && (!sidebar_is_collapsed()))
+          collapse_sidebar();
+        else if ((value == 'expanded') && (sidebar_is_collapsed()))
+          expand_sidebar();
+      }
+    }
+  }
+
+  add_sidebar_button();
+  var sidebarbutton = $('#sidebarbutton');
+  set_position_from_cookie();
+});
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/underscore.js b/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/underscore.js
new file mode 100644
index 0000000..5d89914
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/underscore.js
@@ -0,0 +1,23 @@
+// Underscore.js 0.5.5
+// (c) 2009 Jeremy Ashkenas, DocumentCloud Inc.
+// Underscore is freely distributable under the terms of the MIT license.
+// Portions of Underscore are inspired by or borrowed from Prototype.js,
+// Oliver Steele's Functional, and John Resig's Micro-Templating.
+// For all details and documentation:
+// http://documentcloud.github.com/underscore/
+(function(){var j=this,n=j._,i=function(a){this._wrapped=a},m=typeof StopIteration!=="undefined"?StopIteration:"__break__",b=j._=function(a){return new i(a)};if(typeof exports!=="undefined")exports._=b;var k=Array.prototype.slice,o=Array.prototype.unshift,p=Object.prototype.toString,q=Object.prototype.hasOwnProperty,r=Object.prototype.propertyIsEnumerable;b.VERSION="0.5.5";b.each=function(a,c,d){try{if(a.forEach)a.forEach(c,d);else if(b.isArray(a)||b.isArguments(a))for(var e=0,f=a.length;e<f;e++)c.call(d,
+a[e],e,a);else{var g=b.keys(a);f=g.length;for(e=0;e<f;e++)c.call(d,a[g[e]],g[e],a)}}catch(h){if(h!=m)throw h;}return a};b.map=function(a,c,d){if(a&&b.isFunction(a.map))return a.map(c,d);var e=[];b.each(a,function(f,g,h){e.push(c.call(d,f,g,h))});return e};b.reduce=function(a,c,d,e){if(a&&b.isFunction(a.reduce))return a.reduce(b.bind(d,e),c);b.each(a,function(f,g,h){c=d.call(e,c,f,g,h)});return c};b.reduceRight=function(a,c,d,e){if(a&&b.isFunction(a.reduceRight))return a.reduceRight(b.bind(d,e),c);
+var f=b.clone(b.toArray(a)).reverse();b.each(f,function(g,h){c=d.call(e,c,g,h,a)});return c};b.detect=function(a,c,d){var e;b.each(a,function(f,g,h){if(c.call(d,f,g,h)){e=f;b.breakLoop()}});return e};b.select=function(a,c,d){if(a&&b.isFunction(a.filter))return a.filter(c,d);var e=[];b.each(a,function(f,g,h){c.call(d,f,g,h)&&e.push(f)});return e};b.reject=function(a,c,d){var e=[];b.each(a,function(f,g,h){!c.call(d,f,g,h)&&e.push(f)});return e};b.all=function(a,c,d){c=c||b.identity;if(a&&b.isFunction(a.every))return a.every(c,
+d);var e=true;b.each(a,function(f,g,h){(e=e&&c.call(d,f,g,h))||b.breakLoop()});return e};b.any=function(a,c,d){c=c||b.identity;if(a&&b.isFunction(a.some))return a.some(c,d);var e=false;b.each(a,function(f,g,h){if(e=c.call(d,f,g,h))b.breakLoop()});return e};b.include=function(a,c){if(b.isArray(a))return b.indexOf(a,c)!=-1;var d=false;b.each(a,function(e){if(d=e===c)b.breakLoop()});return d};b.invoke=function(a,c){var d=b.rest(arguments,2);return b.map(a,function(e){return(c?e[c]:e).apply(e,d)})};b.pluck=
+function(a,c){return b.map(a,function(d){return d[c]})};b.max=function(a,c,d){if(!c&&b.isArray(a))return Math.max.apply(Math,a);var e={computed:-Infinity};b.each(a,function(f,g,h){g=c?c.call(d,f,g,h):f;g>=e.computed&&(e={value:f,computed:g})});return e.value};b.min=function(a,c,d){if(!c&&b.isArray(a))return Math.min.apply(Math,a);var e={computed:Infinity};b.each(a,function(f,g,h){g=c?c.call(d,f,g,h):f;g<e.computed&&(e={value:f,computed:g})});return e.value};b.sortBy=function(a,c,d){return b.pluck(b.map(a,
+function(e,f,g){return{value:e,criteria:c.call(d,e,f,g)}}).sort(function(e,f){e=e.criteria;f=f.criteria;return e<f?-1:e>f?1:0}),"value")};b.sortedIndex=function(a,c,d){d=d||b.identity;for(var e=0,f=a.length;e<f;){var g=e+f>>1;d(a[g])<d(c)?(e=g+1):(f=g)}return e};b.toArray=function(a){if(!a)return[];if(a.toArray)return a.toArray();if(b.isArray(a))return a;if(b.isArguments(a))return k.call(a);return b.values(a)};b.size=function(a){return b.toArray(a).length};b.first=function(a,c,d){return c&&!d?k.call(a,
+0,c):a[0]};b.rest=function(a,c,d){return k.call(a,b.isUndefined(c)||d?1:c)};b.last=function(a){return a[a.length-1]};b.compact=function(a){return b.select(a,function(c){return!!c})};b.flatten=function(a){return b.reduce(a,[],function(c,d){if(b.isArray(d))return c.concat(b.flatten(d));c.push(d);return c})};b.without=function(a){var c=b.rest(arguments);return b.select(a,function(d){return!b.include(c,d)})};b.uniq=function(a,c){return b.reduce(a,[],function(d,e,f){if(0==f||(c===true?b.last(d)!=e:!b.include(d,
+e)))d.push(e);return d})};b.intersect=function(a){var c=b.rest(arguments);return b.select(b.uniq(a),function(d){return b.all(c,function(e){return b.indexOf(e,d)>=0})})};b.zip=function(){for(var a=b.toArray(arguments),c=b.max(b.pluck(a,"length")),d=new Array(c),e=0;e<c;e++)d[e]=b.pluck(a,String(e));return d};b.indexOf=function(a,c){if(a.indexOf)return a.indexOf(c);for(var d=0,e=a.length;d<e;d++)if(a[d]===c)return d;return-1};b.lastIndexOf=function(a,c){if(a.lastIndexOf)return a.lastIndexOf(c);for(var d=
+a.length;d--;)if(a[d]===c)return d;return-1};b.range=function(a,c,d){var e=b.toArray(arguments),f=e.length<=1;a=f?0:e[0];c=f?e[0]:e[1];d=e[2]||1;e=Math.ceil((c-a)/d);if(e<=0)return[];e=new Array(e);f=a;for(var g=0;1;f+=d){if((d>0?f-c:c-f)>=0)return e;e[g++]=f}};b.bind=function(a,c){var d=b.rest(arguments,2);return function(){return a.apply(c||j,d.concat(b.toArray(arguments)))}};b.bindAll=function(a){var c=b.rest(arguments);if(c.length==0)c=b.functions(a);b.each(c,function(d){a[d]=b.bind(a[d],a)});
+return a};b.delay=function(a,c){var d=b.rest(arguments,2);return setTimeout(function(){return a.apply(a,d)},c)};b.defer=function(a){return b.delay.apply(b,[a,1].concat(b.rest(arguments)))};b.wrap=function(a,c){return function(){var d=[a].concat(b.toArray(arguments));return c.apply(c,d)}};b.compose=function(){var a=b.toArray(arguments);return function(){for(var c=b.toArray(arguments),d=a.length-1;d>=0;d--)c=[a[d].apply(this,c)];return c[0]}};b.keys=function(a){if(b.isArray(a))return b.range(0,a.length);
+var c=[];for(var d in a)q.call(a,d)&&c.push(d);return c};b.values=function(a){return b.map(a,b.identity)};b.functions=function(a){return b.select(b.keys(a),function(c){return b.isFunction(a[c])}).sort()};b.extend=function(a,c){for(var d in c)a[d]=c[d];return a};b.clone=function(a){if(b.isArray(a))return a.slice(0);return b.extend({},a)};b.tap=function(a,c){c(a);return a};b.isEqual=function(a,c){if(a===c)return true;var d=typeof a;if(d!=typeof c)return false;if(a==c)return true;if(!a&&c||a&&!c)return false;
+if(a.isEqual)return a.isEqual(c);if(b.isDate(a)&&b.isDate(c))return a.getTime()===c.getTime();if(b.isNaN(a)&&b.isNaN(c))return true;if(b.isRegExp(a)&&b.isRegExp(c))return a.source===c.source&&a.global===c.global&&a.ignoreCase===c.ignoreCase&&a.multiline===c.multiline;if(d!=="object")return false;if(a.length&&a.length!==c.length)return false;d=b.keys(a);var e=b.keys(c);if(d.length!=e.length)return false;for(var f in a)if(!b.isEqual(a[f],c[f]))return false;return true};b.isEmpty=function(a){return b.keys(a).length==
+0};b.isElement=function(a){return!!(a&&a.nodeType==1)};b.isArray=function(a){return!!(a&&a.concat&&a.unshift)};b.isArguments=function(a){return a&&b.isNumber(a.length)&&!b.isArray(a)&&!r.call(a,"length")};b.isFunction=function(a){return!!(a&&a.constructor&&a.call&&a.apply)};b.isString=function(a){return!!(a===""||a&&a.charCodeAt&&a.substr)};b.isNumber=function(a){return p.call(a)==="[object Number]"};b.isDate=function(a){return!!(a&&a.getTimezoneOffset&&a.setUTCFullYear)};b.isRegExp=function(a){return!!(a&&
+a.test&&a.exec&&(a.ignoreCase||a.ignoreCase===false))};b.isNaN=function(a){return b.isNumber(a)&&isNaN(a)};b.isNull=function(a){return a===null};b.isUndefined=function(a){return typeof a=="undefined"};b.noConflict=function(){j._=n;return this};b.identity=function(a){return a};b.breakLoop=function(){throw m;};var s=0;b.uniqueId=function(a){var c=s++;return a?a+c:c};b.template=function(a,c){a=new Function("obj","var p=[],print=function(){p.push.apply(p,arguments);};with(obj){p.push('"+a.replace(/[\r\t\n]/g,
+" ").replace(/'(?=[^%]*%>)/g,"\t").split("'").join("\\'").split("\t").join("'").replace(/<%=(.+?)%>/g,"',$1,'").split("<%").join("');").split("%>").join("p.push('")+"');}return p.join('');");return c?a(c):a};b.forEach=b.each;b.foldl=b.inject=b.reduce;b.foldr=b.reduceRight;b.filter=b.select;b.every=b.all;b.some=b.any;b.head=b.first;b.tail=b.rest;b.methods=b.functions;var l=function(a,c){return c?b(a).chain():a};b.each(b.functions(b),function(a){var c=b[a];i.prototype[a]=function(){var d=b.toArray(arguments);
+o.call(d,this._wrapped);return l(c.apply(b,d),this._chain)}});b.each(["pop","push","reverse","shift","sort","splice","unshift"],function(a){var c=Array.prototype[a];i.prototype[a]=function(){c.apply(this._wrapped,arguments);return l(this._wrapped,this._chain)}});b.each(["concat","join","slice"],function(a){var c=Array.prototype[a];i.prototype[a]=function(){return l(c.apply(this._wrapped,arguments),this._chain)}});i.prototype.chain=function(){this._chain=true;return this};i.prototype.value=function(){return this._wrapped}})();
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/up-pressed.png b/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/up-pressed.png
new file mode 100644
index 0000000000000000000000000000000000000000..8bd587afee2fe38989383ff82010147ea56b93dd
GIT binary patch
literal 372
zcmeAS@N?(olHy`uVBq!ia0vp^0wB!61|;P_|4#%`jKx9jP7LeL$-D$|*pj^6U4S$Y
z{B+)352QE?JR*yM+OLB!qm#z$3ZNi+iKnkC`z>}Z1|5lxjZvvUp)Z~;jv*GO&raT-
z#pEb(tbY1#Ey4dH;Y+=<pEBRLsjGAOCY!v|CyvUA4wrPfZ{O_DPe^{q91)qJXqI&@
zO~JiL+CN7oqU^@cvS+{3Bz9yAOB-!e{LTNlK+)ab|H>wAPPMA->(Ug=YM6W%tgKtA
zI`O=0Laf#Y-Y4f~`^K_)D_mvj{B=4?=t!I41ZLNlI~j_4kE*^nvF$)|>mH^X%(>6c
z8XimFvvIAOoRJf!>6jzIa5w(S%7lxdZ{*qJxhxpj6S#UB!oTuMX^Z^6%)IfT_v-!3
z=PEaM_iSh6_`s$!$NaEMP6gw<x#pX-zc1lmBOrZAdYY~+^N*K~{#DY`%7Ol8@O1Ta
JS?83{1OR?3hMxcc

literal 0
HcmV?d00001

diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/up.png b/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/up.png
new file mode 100644
index 0000000000000000000000000000000000000000..b94625680b4a4b9647c3a6f3f283776930696aa9
GIT binary patch
literal 363
zcmeAS@N?(olHy`uVBq!ia0vp^0wB!61|;P_|4#%`jKx9jP7LeL$-D$|*pj^6U4S$Y
z{B+)352QE?JR*yM+OLB!qm#z$3ZNi+iKnkC`z>}xaYa3wv(2tRq1T=+jv*GO&raUx
z$K)u`w*Tuor>1}ySNCesuPuG-8#b%jw0sn-5fpk^!623V@1GR6+<`78?&Rhov&jx6
z*R7KttIVGJ=8yH~|HhI(uB&NIpYp$LXT}M`Z<Dv|Q9O9-{p!t<9#srg4(I=_Xg%_r
zaf7X90Rxxu?X9UB7>)D=?%dxpN#UiKM#HZsJK4DUm#Y3a5!dMF634rTxz_l%hvABb
z(=Pc<$5*Xj@eE$@$89c0_oa>Y5;`&;INvn7C-9xQbH92`*_(~*lcvS}m5Z2pGdgKc
z>;tJC%=6B^QS*>ubT+QGD)v`9z&&Y`y-xHu*7vDC$|9@xfdY)d)78&qol`;+01iQm
A<^TWy

literal 0
HcmV?d00001

diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/websupport.js b/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/websupport.js
new file mode 100644
index 0000000..e9bd1b8
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/html/_static/websupport.js
@@ -0,0 +1,808 @@
+/*
+ * websupport.js
+ * ~~~~~~~~~~~~~
+ *
+ * sphinx.websupport utilties for all documentation.
+ *
+ * :copyright: Copyright 2007-2011 by the Sphinx team, see AUTHORS.
+ * :license: BSD, see LICENSE for details.
+ *
+ */
+
+(function($) {
+  $.fn.autogrow = function() {
+    return this.each(function() {
+    var textarea = this;
+
+    $.fn.autogrow.resize(textarea);
+
+    $(textarea)
+      .focus(function() {
+        textarea.interval = setInterval(function() {
+          $.fn.autogrow.resize(textarea);
+        }, 500);
+      })
+      .blur(function() {
+        clearInterval(textarea.interval);
+      });
+    });
+  };
+
+  $.fn.autogrow.resize = function(textarea) {
+    var lineHeight = parseInt($(textarea).css('line-height'), 10);
+    var lines = textarea.value.split('\n');
+    var columns = textarea.cols;
+    var lineCount = 0;
+    $.each(lines, function() {
+      lineCount += Math.ceil(this.length / columns) || 1;
+    });
+    var height = lineHeight * (lineCount + 1);
+    $(textarea).css('height', height);
+  };
+})(jQuery);
+
+(function($) {
+  var comp, by;
+
+  function init() {
+    initEvents();
+    initComparator();
+  }
+
+  function initEvents() {
+    $('a.comment-close').live("click", function(event) {
+      event.preventDefault();
+      hide($(this).attr('id').substring(2));
+    });
+    $('a.vote').live("click", function(event) {
+      event.preventDefault();
+      handleVote($(this));
+    });
+    $('a.reply').live("click", function(event) {
+      event.preventDefault();
+      openReply($(this).attr('id').substring(2));
+    });
+    $('a.close-reply').live("click", function(event) {
+      event.preventDefault();
+      closeReply($(this).attr('id').substring(2));
+    });
+    $('a.sort-option').live("click", function(event) {
+      event.preventDefault();
+      handleReSort($(this));
+    });
+    $('a.show-proposal').live("click", function(event) {
+      event.preventDefault();
+      showProposal($(this).attr('id').substring(2));
+    });
+    $('a.hide-proposal').live("click", function(event) {
+      event.preventDefault();
+      hideProposal($(this).attr('id').substring(2));
+    });
+    $('a.show-propose-change').live("click", function(event) {
+      event.preventDefault();
+      showProposeChange($(this).attr('id').substring(2));
+    });
+    $('a.hide-propose-change').live("click", function(event) {
+      event.preventDefault();
+      hideProposeChange($(this).attr('id').substring(2));
+    });
+    $('a.accept-comment').live("click", function(event) {
+      event.preventDefault();
+      acceptComment($(this).attr('id').substring(2));
+    });
+    $('a.delete-comment').live("click", function(event) {
+      event.preventDefault();
+      deleteComment($(this).attr('id').substring(2));
+    });
+    $('a.comment-markup').live("click", function(event) {
+      event.preventDefault();
+      toggleCommentMarkupBox($(this).attr('id').substring(2));
+    });
+  }
+
+  /**
+   * Set comp, which is a comparator function used for sorting and
+   * inserting comments into the list.
+   */
+  function setComparator() {
+    // If the first three letters are "asc", sort in ascending order
+    // and remove the prefix.
+    if (by.substring(0,3) == 'asc') {
+      var i = by.substring(3);
+      comp = function(a, b) { return a[i] - b[i]; };
+    } else {
+      // Otherwise sort in descending order.
+      comp = function(a, b) { return b[by] - a[by]; };
+    }
+
+    // Reset link styles and format the selected sort option.
+    $('a.sel').attr('href', '#').removeClass('sel');
+    $('a.by' + by).removeAttr('href').addClass('sel');
+  }
+
+  /**
+   * Create a comp function. If the user has preferences stored in
+   * the sortBy cookie, use those, otherwise use the default.
+   */
+  function initComparator() {
+    by = 'rating'; // Default to sort by rating.
+    // If the sortBy cookie is set, use that instead.
+    if (document.cookie.length > 0) {
+      var start = document.cookie.indexOf('sortBy=');
+      if (start != -1) {
+        start = start + 7;
+        var end = document.cookie.indexOf(";", start);
+        if (end == -1) {
+          end = document.cookie.length;
+          by = unescape(document.cookie.substring(start, end));
+        }
+      }
+    }
+    setComparator();
+  }
+
+  /**
+   * Show a comment div.
+   */
+  function show(id) {
+    $('#ao' + id).hide();
+    $('#ah' + id).show();
+    var context = $.extend({id: id}, opts);
+    var popup = $(renderTemplate(popupTemplate, context)).hide();
+    popup.find('textarea[name="proposal"]').hide();
+    popup.find('a.by' + by).addClass('sel');
+    var form = popup.find('#cf' + id);
+    form.submit(function(event) {
+      event.preventDefault();
+      addComment(form);
+    });
+    $('#s' + id).after(popup);
+    popup.slideDown('fast', function() {
+      getComments(id);
+    });
+  }
+
+  /**
+   * Hide a comment div.
+   */
+  function hide(id) {
+    $('#ah' + id).hide();
+    $('#ao' + id).show();
+    var div = $('#sc' + id);
+    div.slideUp('fast', function() {
+      div.remove();
+    });
+  }
+
+  /**
+   * Perform an ajax request to get comments for a node
+   * and insert the comments into the comments tree.
+   */
+  function getComments(id) {
+    $.ajax({
+     type: 'GET',
+     url: opts.getCommentsURL,
+     data: {node: id},
+     success: function(data, textStatus, request) {
+       var ul = $('#cl' + id);
+       var speed = 100;
+       $('#cf' + id)
+         .find('textarea[name="proposal"]')
+         .data('source', data.source);
+
+       if (data.comments.length === 0) {
+         ul.html('<li>No comments yet.</li>');
+         ul.data('empty', true);
+       } else {
+         // If there are comments, sort them and put them in the list.
+         var comments = sortComments(data.comments);
+         speed = data.comments.length * 100;
+         appendComments(comments, ul);
+         ul.data('empty', false);
+       }
+       $('#cn' + id).slideUp(speed + 200);
+       ul.slideDown(speed);
+     },
+     error: function(request, textStatus, error) {
+       showError('Oops, there was a problem retrieving the comments.');
+     },
+     dataType: 'json'
+    });
+  }
+
+  /**
+   * Add a comment via ajax and insert the comment into the comment tree.
+   */
+  function addComment(form) {
+    var node_id = form.find('input[name="node"]').val();
+    var parent_id = form.find('input[name="parent"]').val();
+    var text = form.find('textarea[name="comment"]').val();
+    var proposal = form.find('textarea[name="proposal"]').val();
+
+    if (text == '') {
+      showError('Please enter a comment.');
+      return;
+    }
+
+    // Disable the form that is being submitted.
+    form.find('textarea,input').attr('disabled', 'disabled');
+
+    // Send the comment to the server.
+    $.ajax({
+      type: "POST",
+      url: opts.addCommentURL,
+      dataType: 'json',
+      data: {
+        node: node_id,
+        parent: parent_id,
+        text: text,
+        proposal: proposal
+      },
+      success: function(data, textStatus, error) {
+        // Reset the form.
+        if (node_id) {
+          hideProposeChange(node_id);
+        }
+        form.find('textarea')
+          .val('')
+          .add(form.find('input'))
+          .removeAttr('disabled');
+	var ul = $('#cl' + (node_id || parent_id));
+        if (ul.data('empty')) {
+          $(ul).empty();
+          ul.data('empty', false);
+        }
+        insertComment(data.comment);
+        var ao = $('#ao' + node_id);
+        ao.find('img').attr({'src': opts.commentBrightImage});
+        if (node_id) {
+          // if this was a "root" comment, remove the commenting box
+          // (the user can get it back by reopening the comment popup)
+          $('#ca' + node_id).slideUp();
+        }
+      },
+      error: function(request, textStatus, error) {
+        form.find('textarea,input').removeAttr('disabled');
+        showError('Oops, there was a problem adding the comment.');
+      }
+    });
+  }
+
+  /**
+   * Recursively append comments to the main comment list and children
+   * lists, creating the comment tree.
+   */
+  function appendComments(comments, ul) {
+    $.each(comments, function() {
+      var div = createCommentDiv(this);
+      ul.append($(document.createElement('li')).html(div));
+      appendComments(this.children, div.find('ul.comment-children'));
+      // To avoid stagnating data, don't store the comments children in data.
+      this.children = null;
+      div.data('comment', this);
+    });
+  }
+
+  /**
+   * After adding a new comment, it must be inserted in the correct
+   * location in the comment tree.
+   */
+  function insertComment(comment) {
+    var div = createCommentDiv(comment);
+
+    // To avoid stagnating data, don't store the comments children in data.
+    comment.children = null;
+    div.data('comment', comment);
+
+    var ul = $('#cl' + (comment.node || comment.parent));
+    var siblings = getChildren(ul);
+
+    var li = $(document.createElement('li'));
+    li.hide();
+
+    // Determine where in the parents children list to insert this comment.
+    for(i=0; i < siblings.length; i++) {
+      if (comp(comment, siblings[i]) <= 0) {
+        $('#cd' + siblings[i].id)
+          .parent()
+          .before(li.html(div));
+        li.slideDown('fast');
+        return;
+      }
+    }
+
+    // If we get here, this comment rates lower than all the others,
+    // or it is the only comment in the list.
+    ul.append(li.html(div));
+    li.slideDown('fast');
+  }
+
+  function acceptComment(id) {
+    $.ajax({
+      type: 'POST',
+      url: opts.acceptCommentURL,
+      data: {id: id},
+      success: function(data, textStatus, request) {
+        $('#cm' + id).fadeOut('fast');
+        $('#cd' + id).removeClass('moderate');
+      },
+      error: function(request, textStatus, error) {
+        showError('Oops, there was a problem accepting the comment.');
+      }
+    });
+  }
+
+  function deleteComment(id) {
+    $.ajax({
+      type: 'POST',
+      url: opts.deleteCommentURL,
+      data: {id: id},
+      success: function(data, textStatus, request) {
+        var div = $('#cd' + id);
+        if (data == 'delete') {
+          // Moderator mode: remove the comment and all children immediately
+          div.slideUp('fast', function() {
+            div.remove();
+          });
+          return;
+        }
+        // User mode: only mark the comment as deleted
+        div
+          .find('span.user-id:first')
+          .text('[deleted]').end()
+          .find('div.comment-text:first')
+          .text('[deleted]').end()
+          .find('#cm' + id + ', #dc' + id + ', #ac' + id + ', #rc' + id +
+                ', #sp' + id + ', #hp' + id + ', #cr' + id + ', #rl' + id)
+          .remove();
+        var comment = div.data('comment');
+        comment.username = '[deleted]';
+        comment.text = '[deleted]';
+        div.data('comment', comment);
+      },
+      error: function(request, textStatus, error) {
+        showError('Oops, there was a problem deleting the comment.');
+      }
+    });
+  }
+
+  function showProposal(id) {
+    $('#sp' + id).hide();
+    $('#hp' + id).show();
+    $('#pr' + id).slideDown('fast');
+  }
+
+  function hideProposal(id) {
+    $('#hp' + id).hide();
+    $('#sp' + id).show();
+    $('#pr' + id).slideUp('fast');
+  }
+
+  function showProposeChange(id) {
+    $('#pc' + id).hide();
+    $('#hc' + id).show();
+    var textarea = $('#pt' + id);
+    textarea.val(textarea.data('source'));
+    $.fn.autogrow.resize(textarea[0]);
+    textarea.slideDown('fast');
+  }
+
+  function hideProposeChange(id) {
+    $('#hc' + id).hide();
+    $('#pc' + id).show();
+    var textarea = $('#pt' + id);
+    textarea.val('').removeAttr('disabled');
+    textarea.slideUp('fast');
+  }
+
+  function toggleCommentMarkupBox(id) {
+    $('#mb' + id).toggle();
+  }
+
+  /** Handle when the user clicks on a sort by link. */
+  function handleReSort(link) {
+    var classes = link.attr('class').split(/\s+/);
+    for (var i=0; i<classes.length; i++) {
+      if (classes[i] != 'sort-option') {
+	by = classes[i].substring(2);
+      }
+    }
+    setComparator();
+    // Save/update the sortBy cookie.
+    var expiration = new Date();
+    expiration.setDate(expiration.getDate() + 365);
+    document.cookie= 'sortBy=' + escape(by) +
+                     ';expires=' + expiration.toUTCString();
+    $('ul.comment-ul').each(function(index, ul) {
+      var comments = getChildren($(ul), true);
+      comments = sortComments(comments);
+      appendComments(comments, $(ul).empty());
+    });
+  }
+
+  /**
+   * Function to process a vote when a user clicks an arrow.
+   */
+  function handleVote(link) {
+    if (!opts.voting) {
+      showError("You'll need to login to vote.");
+      return;
+    }
+
+    var id = link.attr('id');
+    if (!id) {
+      // Didn't click on one of the voting arrows.
+      return;
+    }
+    // If it is an unvote, the new vote value is 0,
+    // Otherwise it's 1 for an upvote, or -1 for a downvote.
+    var value = 0;
+    if (id.charAt(1) != 'u') {
+      value = id.charAt(0) == 'u' ? 1 : -1;
+    }
+    // The data to be sent to the server.
+    var d = {
+      comment_id: id.substring(2),
+      value: value
+    };
+
+    // Swap the vote and unvote links.
+    link.hide();
+    $('#' + id.charAt(0) + (id.charAt(1) == 'u' ? 'v' : 'u') + d.comment_id)
+      .show();
+
+    // The div the comment is displayed in.
+    var div = $('div#cd' + d.comment_id);
+    var data = div.data('comment');
+
+    // If this is not an unvote, and the other vote arrow has
+    // already been pressed, unpress it.
+    if ((d.value !== 0) && (data.vote === d.value * -1)) {
+      $('#' + (d.value == 1 ? 'd' : 'u') + 'u' + d.comment_id).hide();
+      $('#' + (d.value == 1 ? 'd' : 'u') + 'v' + d.comment_id).show();
+    }
+
+    // Update the comments rating in the local data.
+    data.rating += (data.vote === 0) ? d.value : (d.value - data.vote);
+    data.vote = d.value;
+    div.data('comment', data);
+
+    // Change the rating text.
+    div.find('.rating:first')
+      .text(data.rating + ' point' + (data.rating == 1 ? '' : 's'));
+
+    // Send the vote information to the server.
+    $.ajax({
+      type: "POST",
+      url: opts.processVoteURL,
+      data: d,
+      error: function(request, textStatus, error) {
+        showError('Oops, there was a problem casting that vote.');
+      }
+    });
+  }
+
+  /**
+   * Open a reply form used to reply to an existing comment.
+   */
+  function openReply(id) {
+    // Swap out the reply link for the hide link
+    $('#rl' + id).hide();
+    $('#cr' + id).show();
+
+    // Add the reply li to the children ul.
+    var div = $(renderTemplate(replyTemplate, {id: id})).hide();
+    $('#cl' + id)
+      .prepend(div)
+      // Setup the submit handler for the reply form.
+      .find('#rf' + id)
+      .submit(function(event) {
+        event.preventDefault();
+        addComment($('#rf' + id));
+        closeReply(id);
+      })
+      .find('input[type=button]')
+      .click(function() {
+        closeReply(id);
+      });
+    div.slideDown('fast', function() {
+      $('#rf' + id).find('textarea').focus();
+    });
+  }
+
+  /**
+   * Close the reply form opened with openReply.
+   */
+  function closeReply(id) {
+    // Remove the reply div from the DOM.
+    $('#rd' + id).slideUp('fast', function() {
+      $(this).remove();
+    });
+
+    // Swap out the hide link for the reply link
+    $('#cr' + id).hide();
+    $('#rl' + id).show();
+  }
+
+  /**
+   * Recursively sort a tree of comments using the comp comparator.
+   */
+  function sortComments(comments) {
+    comments.sort(comp);
+    $.each(comments, function() {
+      this.children = sortComments(this.children);
+    });
+    return comments;
+  }
+
+  /**
+   * Get the children comments from a ul. If recursive is true,
+   * recursively include childrens' children.
+   */
+  function getChildren(ul, recursive) {
+    var children = [];
+    ul.children().children("[id^='cd']")
+      .each(function() {
+        var comment = $(this).data('comment');
+        if (recursive)
+          comment.children = getChildren($(this).find('#cl' + comment.id), true);
+        children.push(comment);
+      });
+    return children;
+  }
+
+  /** Create a div to display a comment in. */
+  function createCommentDiv(comment) {
+    if (!comment.displayed && !opts.moderator) {
+      return $('<div class="moderate">Thank you!  Your comment will show up '
+               + 'once it is has been approved by a moderator.</div>');
+    }
+    // Prettify the comment rating.
+    comment.pretty_rating = comment.rating + ' point' +
+      (comment.rating == 1 ? '' : 's');
+    // Make a class (for displaying not yet moderated comments differently)
+    comment.css_class = comment.displayed ? '' : ' moderate';
+    // Create a div for this comment.
+    var context = $.extend({}, opts, comment);
+    var div = $(renderTemplate(commentTemplate, context));
+
+    // If the user has voted on this comment, highlight the correct arrow.
+    if (comment.vote) {
+      var direction = (comment.vote == 1) ? 'u' : 'd';
+      div.find('#' + direction + 'v' + comment.id).hide();
+      div.find('#' + direction + 'u' + comment.id).show();
+    }
+
+    if (opts.moderator || comment.text != '[deleted]') {
+      div.find('a.reply').show();
+      if (comment.proposal_diff)
+        div.find('#sp' + comment.id).show();
+      if (opts.moderator && !comment.displayed)
+        div.find('#cm' + comment.id).show();
+      if (opts.moderator || (opts.username == comment.username))
+        div.find('#dc' + comment.id).show();
+    }
+    return div;
+  }
+
+  /**
+   * A simple template renderer. Placeholders such as <%id%> are replaced
+   * by context['id'] with items being escaped. Placeholders such as <#id#>
+   * are not escaped.
+   */
+  function renderTemplate(template, context) {
+    var esc = $(document.createElement('div'));
+
+    function handle(ph, escape) {
+      var cur = context;
+      $.each(ph.split('.'), function() {
+        cur = cur[this];
+      });
+      return escape ? esc.text(cur || "").html() : cur;
+    }
+
+    return template.replace(/<([%#])([\w\.]*)\1>/g, function() {
+      return handle(arguments[2], arguments[1] == '%' ? true : false);
+    });
+  }
+
+  /** Flash an error message briefly. */
+  function showError(message) {
+    $(document.createElement('div')).attr({'class': 'popup-error'})
+      .append($(document.createElement('div'))
+               .attr({'class': 'error-message'}).text(message))
+      .appendTo('body')
+      .fadeIn("slow")
+      .delay(2000)
+      .fadeOut("slow");
+  }
+
+  /** Add a link the user uses to open the comments popup. */
+  $.fn.comment = function() {
+    return this.each(function() {
+      var id = $(this).attr('id').substring(1);
+      var count = COMMENT_METADATA[id];
+      var title = count + ' comment' + (count == 1 ? '' : 's');
+      var image = count > 0 ? opts.commentBrightImage : opts.commentImage;
+      var addcls = count == 0 ? ' nocomment' : '';
+      $(this)
+        .append(
+          $(document.createElement('a')).attr({
+            href: '#',
+            'class': 'sphinx-comment-open' + addcls,
+            id: 'ao' + id
+          })
+            .append($(document.createElement('img')).attr({
+              src: image,
+              alt: 'comment',
+              title: title
+            }))
+            .click(function(event) {
+              event.preventDefault();
+              show($(this).attr('id').substring(2));
+            })
+        )
+        .append(
+          $(document.createElement('a')).attr({
+            href: '#',
+            'class': 'sphinx-comment-close hidden',
+            id: 'ah' + id
+          })
+            .append($(document.createElement('img')).attr({
+              src: opts.closeCommentImage,
+              alt: 'close',
+              title: 'close'
+            }))
+            .click(function(event) {
+              event.preventDefault();
+              hide($(this).attr('id').substring(2));
+            })
+        );
+    });
+  };
+
+  var opts = {
+    processVoteURL: '/_process_vote',
+    addCommentURL: '/_add_comment',
+    getCommentsURL: '/_get_comments',
+    acceptCommentURL: '/_accept_comment',
+    deleteCommentURL: '/_delete_comment',
+    commentImage: '/static/_static/comment.png',
+    closeCommentImage: '/static/_static/comment-close.png',
+    loadingImage: '/static/_static/ajax-loader.gif',
+    commentBrightImage: '/static/_static/comment-bright.png',
+    upArrow: '/static/_static/up.png',
+    downArrow: '/static/_static/down.png',
+    upArrowPressed: '/static/_static/up-pressed.png',
+    downArrowPressed: '/static/_static/down-pressed.png',
+    voting: false,
+    moderator: false
+  };
+
+  if (typeof COMMENT_OPTIONS != "undefined") {
+    opts = jQuery.extend(opts, COMMENT_OPTIONS);
+  }
+
+  var popupTemplate = '\
+    <div class="sphinx-comments" id="sc<%id%>">\
+      <p class="sort-options">\
+        Sort by:\
+        <a href="#" class="sort-option byrating">best rated</a>\
+        <a href="#" class="sort-option byascage">newest</a>\
+        <a href="#" class="sort-option byage">oldest</a>\
+      </p>\
+      <div class="comment-header">Comments</div>\
+      <div class="comment-loading" id="cn<%id%>">\
+        loading comments... <img src="<%loadingImage%>" alt="" /></div>\
+      <ul id="cl<%id%>" class="comment-ul"></ul>\
+      <div id="ca<%id%>">\
+      <p class="add-a-comment">Add a comment\
+        (<a href="#" class="comment-markup" id="ab<%id%>">markup</a>):</p>\
+      <div class="comment-markup-box" id="mb<%id%>">\
+        reStructured text markup: <i>*emph*</i>, <b>**strong**</b>, \
+        <tt>``code``</tt>, \
+        code blocks: <tt>::</tt> and an indented block after blank line</div>\
+      <form method="post" id="cf<%id%>" class="comment-form" action="">\
+        <textarea name="comment" cols="80"></textarea>\
+        <p class="propose-button">\
+          <a href="#" id="pc<%id%>" class="show-propose-change">\
+            Propose a change &#9657;\
+          </a>\
+          <a href="#" id="hc<%id%>" class="hide-propose-change">\
+            Propose a change &#9663;\
+          </a>\
+        </p>\
+        <textarea name="proposal" id="pt<%id%>" cols="80"\
+                  spellcheck="false"></textarea>\
+        <input type="submit" value="Add comment" />\
+        <input type="hidden" name="node" value="<%id%>" />\
+        <input type="hidden" name="parent" value="" />\
+      </form>\
+      </div>\
+    </div>';
+
+  var commentTemplate = '\
+    <div id="cd<%id%>" class="sphinx-comment<%css_class%>">\
+      <div class="vote">\
+        <div class="arrow">\
+          <a href="#" id="uv<%id%>" class="vote" title="vote up">\
+            <img src="<%upArrow%>" />\
+          </a>\
+          <a href="#" id="uu<%id%>" class="un vote" title="vote up">\
+            <img src="<%upArrowPressed%>" />\
+          </a>\
+        </div>\
+        <div class="arrow">\
+          <a href="#" id="dv<%id%>" class="vote" title="vote down">\
+            <img src="<%downArrow%>" id="da<%id%>" />\
+          </a>\
+          <a href="#" id="du<%id%>" class="un vote" title="vote down">\
+            <img src="<%downArrowPressed%>" />\
+          </a>\
+        </div>\
+      </div>\
+      <div class="comment-content">\
+        <p class="tagline comment">\
+          <span class="user-id"><%username%></span>\
+          <span class="rating"><%pretty_rating%></span>\
+          <span class="delta"><%time.delta%></span>\
+        </p>\
+        <div class="comment-text comment"><#text#></div>\
+        <p class="comment-opts comment">\
+          <a href="#" class="reply hidden" id="rl<%id%>">reply &#9657;</a>\
+          <a href="#" class="close-reply" id="cr<%id%>">reply &#9663;</a>\
+          <a href="#" id="sp<%id%>" class="show-proposal">proposal &#9657;</a>\
+          <a href="#" id="hp<%id%>" class="hide-proposal">proposal &#9663;</a>\
+          <a href="#" id="dc<%id%>" class="delete-comment hidden">delete</a>\
+          <span id="cm<%id%>" class="moderation hidden">\
+            <a href="#" id="ac<%id%>" class="accept-comment">accept</a>\
+          </span>\
+        </p>\
+        <pre class="proposal" id="pr<%id%>">\
+<#proposal_diff#>\
+        </pre>\
+          <ul class="comment-children" id="cl<%id%>"></ul>\
+        </div>\
+        <div class="clearleft"></div>\
+      </div>\
+    </div>';
+
+  var replyTemplate = '\
+    <li>\
+      <div class="reply-div" id="rd<%id%>">\
+        <form id="rf<%id%>">\
+          <textarea name="comment" cols="80"></textarea>\
+          <input type="submit" value="Add reply" />\
+          <input type="button" value="Cancel" />\
+          <input type="hidden" name="parent" value="<%id%>" />\
+          <input type="hidden" name="node" value="" />\
+        </form>\
+      </div>\
+    </li>';
+
+  $(document).ready(function() {
+    init();
+  });
+})(jQuery);
+
+$(document).ready(function() {
+  // add comment anchors for all paragraphs that are commentable
+  $('.sphinx-has-comment').comment();
+
+  // highlight search words in search results
+  $("div.context").each(function() {
+    var params = $.getQueryParameters();
+    var terms = (params.q) ? params.q[0].split(/\s+/) : [];
+    var result = $(this);
+    $.each(terms, function() {
+      result.highlightText(this.toLowerCase(), 'highlighted');
+    });
+  });
+
+  // directly open comment window if requested
+  var anchor = document.location.hash;
+  if (anchor.substring(0, 9) == '#comment-') {
+    $('#ao' + anchor.substring(9)).click();
+    document.location.hash = '#s' + anchor.substring(9);
+  }
+});
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/html/connection.html b/desktop/core/ext-py/cx_Oracle-5.1.2/html/connection.html
new file mode 100644
index 0000000..c822273
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/html/connection.html
@@ -0,0 +1,516 @@
+
+
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
+  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+
+
+<html xmlns="http://www.w3.org/1999/xhtml">
+  <head>
+    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
+    
+    <title>Connection Object &mdash; cx_Oracle 5.1.2 documentation</title>
+    
+    <link rel="stylesheet" href="_static/default.css" type="text/css" />
+    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
+    
+    <script type="text/javascript">
+      var DOCUMENTATION_OPTIONS = {
+        URL_ROOT:    '',
+        VERSION:     '5.1.2',
+        COLLAPSE_INDEX: false,
+        FILE_SUFFIX: '.html',
+        HAS_SOURCE:  false
+      };
+    </script>
+    <script type="text/javascript" src="_static/jquery.js"></script>
+    <script type="text/javascript" src="_static/underscore.js"></script>
+    <script type="text/javascript" src="_static/doctools.js"></script>
+    <link rel="top" title="cx_Oracle 5.1.2 documentation" href="index.html" />
+    <link rel="next" title="Cursor Object" href="cursor.html" />
+    <link rel="prev" title="Module Interface" href="module.html" /> 
+  </head>
+  <body>
+    <div class="related">
+      <h3>Navigation</h3>
+      <ul>
+        <li class="right" style="margin-right: 10px">
+          <a href="genindex.html" title="General Index"
+             accesskey="I">index</a></li>
+        <li class="right" >
+          <a href="py-modindex.html" title="Python Module Index"
+             >modules</a> |</li>
+        <li class="right" >
+          <a href="cursor.html" title="Cursor Object"
+             accesskey="N">next</a> |</li>
+        <li class="right" >
+          <a href="module.html" title="Module Interface"
+             accesskey="P">previous</a> |</li>
+        <li><a href="index.html">cx_Oracle 5.1.2 documentation</a> &raquo;</li> 
+      </ul>
+    </div>  
+
+    <div class="document">
+      <div class="documentwrapper">
+        <div class="bodywrapper">
+          <div class="body">
+            
+  <div class="section" id="connection-object">
+<span id="connobj"></span><h1>Connection Object<a class="headerlink" href="#connection-object" title="Permalink to this headline"></a></h1>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">Any outstanding changes will be rolled back when the connection object
+is destroyed or closed.</p>
+</div>
+<dl class="method">
+<dt id="Connection.__enter__">
+<tt class="descclassname">Connection.</tt><tt class="descname">__enter__</tt><big>(</big><big>)</big><a class="headerlink" href="#Connection.__enter__" title="Permalink to this definition"></a></dt>
+<dd><p>The entry point for the connection as a context manager, a feature available
+in Python 2.5 and higher. It returns itself.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This method is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="method">
+<dt id="Connection.__exit__">
+<tt class="descclassname">Connection.</tt><tt class="descname">__exit__</tt><big>(</big><big>)</big><a class="headerlink" href="#Connection.__exit__" title="Permalink to this definition"></a></dt>
+<dd><p>The exit point for the connection as a context manager, a feature available
+in Python 2.5 and higher. In the event of an exception, the transaction is
+rolled back; otherwise, the transaction is committed.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This method is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Connection.action">
+<tt class="descclassname">Connection.</tt><tt class="descname">action</tt><a class="headerlink" href="#Connection.action" title="Permalink to this definition"></a></dt>
+<dd><p>This write-only attribute sets the action column in the v$session table and
+is only available in Oracle 10g.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This attribute is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Connection.autocommit">
+<tt class="descclassname">Connection.</tt><tt class="descname">autocommit</tt><a class="headerlink" href="#Connection.autocommit" title="Permalink to this definition"></a></dt>
+<dd><p>This read-write attribute determines whether autocommit mode is on or off.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This attribute is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="method">
+<dt id="Connection.begin">
+<tt class="descclassname">Connection.</tt><tt class="descname">begin</tt><big>(</big><big>)</big><a class="headerlink" href="#Connection.begin" title="Permalink to this definition"></a></dt>
+<dt>
+<tt class="descclassname">Connection.</tt><tt class="descname">begin</tt><big>(</big><span class="optional">[</span><em>formatId</em>, <em>transactionId</em>, <em>branchId</em><span class="optional">]</span><big>)</big></dt>
+<dd><p>Explicitly begin a new transaction. Without parameters, this explicitly
+begins a local transaction; otherwise, this explicitly begins a distributed
+(global) transaction with the given parameters. See the Oracle documentation
+for more details.</p>
+<p>Note that in order to make use of global (distributed) transactions, the
+twophase argument to the Connection constructor must be a true value. See
+the comments on the Connection constructor for more information
+(<a class="reference internal" href="module.html#module"><em>Module Interface</em></a>).</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This method is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="method">
+<dt id="Connection.cancel">
+<tt class="descclassname">Connection.</tt><tt class="descname">cancel</tt><big>(</big><big>)</big><a class="headerlink" href="#Connection.cancel" title="Permalink to this definition"></a></dt>
+<dd><p>Cancel a long-running transaction.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This method is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="method">
+<dt id="Connection.changepassword">
+<tt class="descclassname">Connection.</tt><tt class="descname">changepassword</tt><big>(</big><em>oldpassword</em>, <em>newpassword</em><big>)</big><a class="headerlink" href="#Connection.changepassword" title="Permalink to this definition"></a></dt>
+<dd><p>Change the password of the logon. This method also modifies the attribute
+<a class="reference internal" href="#Connection.password" title="Connection.password"><tt class="xref py py-data docutils literal"><span class="pre">Connection.password</span></tt></a> upon successful completion.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This method is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Connection.client_identifier">
+<tt class="descclassname">Connection.</tt><tt class="descname">client_identifier</tt><a class="headerlink" href="#Connection.client_identifier" title="Permalink to this definition"></a></dt>
+<dd><p>This write-only attribute sets the client_identifier column in the
+v$session table.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This attribute is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Connection.clientinfo">
+<tt class="descclassname">Connection.</tt><tt class="descname">clientinfo</tt><a class="headerlink" href="#Connection.clientinfo" title="Permalink to this definition"></a></dt>
+<dd><p>This write-only attribute sets the client_info column in the v$session table
+and is only available in Oracle 10g.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This attribute is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="method">
+<dt id="Connection.close">
+<tt class="descclassname">Connection.</tt><tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#Connection.close" title="Permalink to this definition"></a></dt>
+<dd><p>Close the connection now, rather than whenever __del__ is called. The
+connection will be unusable from this point forward; an Error exception will
+be raised if any operation is attempted with the connection. The same
+applies to any cursor objects trying to use the connection.</p>
+</dd></dl>
+
+<dl class="method">
+<dt id="Connection.commit">
+<tt class="descclassname">Connection.</tt><tt class="descname">commit</tt><big>(</big><big>)</big><a class="headerlink" href="#Connection.commit" title="Permalink to this definition"></a></dt>
+<dd><p>Commit any pending transactions to the database.</p>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Connection.current_schema">
+<tt class="descclassname">Connection.</tt><tt class="descname">current_schema</tt><a class="headerlink" href="#Connection.current_schema" title="Permalink to this definition"></a></dt>
+<dd><p>This read-write attribute sets the current schema attribute for the session.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This attribute is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="method">
+<dt id="Connection.cursor">
+<tt class="descclassname">Connection.</tt><tt class="descname">cursor</tt><big>(</big><big>)</big><a class="headerlink" href="#Connection.cursor" title="Permalink to this definition"></a></dt>
+<dd><p>Return a new Cursor object (<a class="reference internal" href="cursor.html#cursorobj"><em>Cursor Object</em></a>) using the connection.</p>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Connection.dsn">
+<tt class="descclassname">Connection.</tt><tt class="descname">dsn</tt><a class="headerlink" href="#Connection.dsn" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute returns the TNS entry of the database to which a
+connection has been established.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This attribute is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Connection.encoding">
+<tt class="descclassname">Connection.</tt><tt class="descname">encoding</tt><a class="headerlink" href="#Connection.encoding" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute returns the IANA character set name of the
+character set in use by the Oracle client.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This attribute is an extension to the DB API definition and is only
+available in Python 2.x when not built in unicode mode.</p>
+</div>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Connection.inputtypehandler">
+<tt class="descclassname">Connection.</tt><tt class="descname">inputtypehandler</tt><a class="headerlink" href="#Connection.inputtypehandler" title="Permalink to this definition"></a></dt>
+<dd><p>This read-write attribute specifies a method called for each value that is
+bound to a statement executed on any cursor associated with this connection.
+The method signature is handler(cursor, value, arraysize) and the return
+value is expected to be a variable object or None in which case a default
+variable object will be created. If this attribute is None, the default
+behavior will take place for all values bound to statements.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This attribute is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Connection.maxBytesPerCharacter">
+<tt class="descclassname">Connection.</tt><tt class="descname">maxBytesPerCharacter</tt><a class="headerlink" href="#Connection.maxBytesPerCharacter" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute returns the maximum number of bytes each character
+can use for the client character set.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This attribute is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Connection.module">
+<tt class="descclassname">Connection.</tt><tt class="descname">module</tt><a class="headerlink" href="#Connection.module" title="Permalink to this definition"></a></dt>
+<dd><p>This write-only attribute sets the module column in the v$session table and
+is only available in Oracle 10g. The maximum length for this string is 48
+and if you exceed this length you will get ORA-24960.</p>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Connection.nencoding">
+<tt class="descclassname">Connection.</tt><tt class="descname">nencoding</tt><a class="headerlink" href="#Connection.nencoding" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute returns the IANA character set name of the national
+character set in use by the Oracle client.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This attribute is an extension to the DB API definition and is only
+available in Python 2.x when not built in unicode mode.</p>
+</div>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Connection.outputtypehandler">
+<tt class="descclassname">Connection.</tt><tt class="descname">outputtypehandler</tt><a class="headerlink" href="#Connection.outputtypehandler" title="Permalink to this definition"></a></dt>
+<dd><p>This read-write attribute specifies a method called for each value that is
+to be fetched from any cursor associated with this connection. The method
+signature is handler(cursor, name, defaultType, length, precision, scale)
+and the return value is expected to be a variable object or None in which
+case a default variable object will be created. If this attribute is None,
+the default behavior will take place for all values fetched from cursors.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This attribute is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Connection.password">
+<tt class="descclassname">Connection.</tt><tt class="descname">password</tt><a class="headerlink" href="#Connection.password" title="Permalink to this definition"></a></dt>
+<dd><p>This read-write attribute initially contains the password of the user which
+established the connection to the database.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This attribute is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="method">
+<dt id="Connection.ping">
+<tt class="descclassname">Connection.</tt><tt class="descname">ping</tt><big>(</big><big>)</big><a class="headerlink" href="#Connection.ping" title="Permalink to this definition"></a></dt>
+<dd><p>Ping the server which can be used to test if the connection is still active.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This method is an extension to the DB API definition and is only
+available in Oracle 10g R2 and higher.</p>
+</div>
+</dd></dl>
+
+<dl class="method">
+<dt id="Connection.prepare">
+<tt class="descclassname">Connection.</tt><tt class="descname">prepare</tt><big>(</big><big>)</big><a class="headerlink" href="#Connection.prepare" title="Permalink to this definition"></a></dt>
+<dd><p>Prepare the distributed (global) transaction for commit. Return a boolean
+indicating if a transaction was actually prepared in order to avoid the
+error ORA-24756 (transaction does not exist).</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This method is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="method">
+<dt id="Connection.register">
+<tt class="descclassname">Connection.</tt><tt class="descname">register</tt><big>(</big><em>code</em>, <em>when</em>, <em>function</em><big>)</big><a class="headerlink" href="#Connection.register" title="Permalink to this definition"></a></dt>
+<dd><p>Register the function as an OCI callback. The code is one of the function
+codes defined in the Oracle documentation of which the most common ones are
+defined as constants in this module. The when parameter is one of
+<tt class="xref py py-data docutils literal"><span class="pre">UCBTYPE_ENTRY</span></tt>, <tt class="xref py py-data docutils literal"><span class="pre">UCBTYPE_EXIT</span></tt> or <tt class="xref py py-data docutils literal"><span class="pre">UCBTYPE_REPLACE</span></tt>. The
+function is a Python function which will accept the parameters that the OCI
+function accepts, modified as needed to return Python objects that are of
+some use. Note that this is a highly experimental method and can cause
+cx_Oracle to crash if not used properly. In particular, the OCI does not
+provide sizing information to the callback so attempts to access a variable
+beyond the allocated size will crash cx_Oracle.  Use with caution.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This method is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="method">
+<dt id="Connection.rollback">
+<tt class="descclassname">Connection.</tt><tt class="descname">rollback</tt><big>(</big><big>)</big><a class="headerlink" href="#Connection.rollback" title="Permalink to this definition"></a></dt>
+<dd><p>Rollback any pending transactions.</p>
+</dd></dl>
+
+<dl class="method">
+<dt id="Connection.shutdown">
+<tt class="descclassname">Connection.</tt><tt class="descname">shutdown</tt><big>(</big><span class="optional">[</span><em>mode</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#Connection.shutdown" title="Permalink to this definition"></a></dt>
+<dd><p>Shutdown the database. In order to do this the connection must connected as
+<tt class="xref py py-data docutils literal"><span class="pre">SYSDBA</span></tt> or <tt class="xref py py-data docutils literal"><span class="pre">SYSOPER</span></tt>. First shutdown using one of the
+DBSHUTDOWN constants defined in the constants (<a class="reference internal" href="module.html#constants"><em>Constants</em></a>) section.
+Next issue the SQL statements required to close the database (&#8220;alter
+database close normal&#8221;) and dismount the database (&#8220;alter database
+dismount&#8221;) followed by a second call to this method with the
+<tt class="xref py py-data docutils literal"><span class="pre">DBSHUTDOWN_FINAL</span></tt> mode.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This method is an extension to the DB API definition and is only
+available in Oracle 10g R2 and higher.</p>
+</div>
+</dd></dl>
+
+<dl class="method">
+<dt id="Connection.startup">
+<tt class="descclassname">Connection.</tt><tt class="descname">startup</tt><big>(</big><em>force=False</em>, <em>restrict=False</em><big>)</big><a class="headerlink" href="#Connection.startup" title="Permalink to this definition"></a></dt>
+<dd><p>Startup the database. This is equivalent to the SQL*Plus command &#8220;startup
+nomount&#8221;. The connection must be connected as <tt class="xref py py-data docutils literal"><span class="pre">SYSDBA</span></tt> or
+<tt class="xref py py-data docutils literal"><span class="pre">SYSOPER</span></tt> with the <tt class="xref py py-data docutils literal"><span class="pre">PRELIM_AUTH</span></tt> option specified for this to
+work. Once this method has completed, connect again without the
+<tt class="xref py py-data docutils literal"><span class="pre">PRELIM_AUTH</span></tt> option and issue the statements required to mount
+(&#8220;alter database mount&#8221;) and open (&#8220;alter database open&#8221;) the database.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This method is an extension to the DB API definition and is only
+available in Oracle 10g R2 and higher.</p>
+</div>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Connection.stmtcachesize">
+<tt class="descclassname">Connection.</tt><tt class="descname">stmtcachesize</tt><a class="headerlink" href="#Connection.stmtcachesize" title="Permalink to this definition"></a></dt>
+<dd><p>This read-write attribute specifies the size of the statement cache. This
+value can make a significant difference in performance (up to 100x) if you
+have a small number of statements that you execute repeatedly.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This attribute is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="method">
+<dt id="Connection.subscribe">
+<tt class="descclassname">Connection.</tt><tt class="descname">subscribe</tt><big>(</big><em>namespace=cx_Oracle.SUBSCR_NAMESPACE_DBCHANGE</em>, <em>protocol=cx_Oracle.SUBSCR_PROTO_OCI</em>, <em>callback=None</em>, <em>timeout=0</em>, <em>operations=OPCODE_ALLOPS</em>, <em>rowids=False</em>, <em>port=0</em><big>)</big><a class="headerlink" href="#Connection.subscribe" title="Permalink to this definition"></a></dt>
+<dd><p>Return a new Subscription object (<a class="reference internal" href="subscription.html#subscrobj"><em>Subscription Object</em></a>) using the connection.
+Currently the namespace and protocol arguments cannot have any other
+meaningful values. The callback is expected to be a callable that accepts
+a single argument which is a message object. The timeout value specifies
+that the subscription expires after the given time in seconds. The default
+value of 0 indicates that the subscription does not expire. The operations
+argument enables filtering of the messages that are sent (insert, update,
+delete). The rowids flag specifies whether the rowids of affected rows
+should be included in the messages that are sent. The port specifies the
+listening port for callback notifications from the database server.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This method is an extension to the DB API definition and is only
+available in Oracle 10g R2 and higher.</p>
+</div>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">Do not close the connection before the subscription object is deleted or
+the subscription object will not be deregistered in the database. This is
+done automatically if connection.close() is never called.</p>
+</div>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Connection.tnsentry">
+<tt class="descclassname">Connection.</tt><tt class="descname">tnsentry</tt><a class="headerlink" href="#Connection.tnsentry" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute returns the TNS entry of the database to which a
+connection has been established.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This attribute is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="method">
+<dt id="Connection.unregister">
+<tt class="descclassname">Connection.</tt><tt class="descname">unregister</tt><big>(</big><em>code</em>, <em>when</em><big>)</big><a class="headerlink" href="#Connection.unregister" title="Permalink to this definition"></a></dt>
+<dd><p>Unregister the function as an OCI callback. The code is one of the function
+codes defined in the Oracle documentation of which the most common ones are
+defined as constants in this module. The when parameter is one of
+<tt class="xref py py-data docutils literal"><span class="pre">UCBTYPE_ENTRY</span></tt>, <tt class="xref py py-data docutils literal"><span class="pre">UCBTYPE_EXIT</span></tt> or <tt class="xref py py-data docutils literal"><span class="pre">UCBTYPE_REPLACE</span></tt>.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This method is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Connection.username">
+<tt class="descclassname">Connection.</tt><tt class="descname">username</tt><a class="headerlink" href="#Connection.username" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute returns the name of the user which established the
+connection to the database.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This attribute is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Connection.version">
+<tt class="descclassname">Connection.</tt><tt class="descname">version</tt><a class="headerlink" href="#Connection.version" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute returns the version of the database to which a
+connection has been established.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This attribute is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+</div>
+
+
+          </div>
+        </div>
+      </div>
+      <div class="sphinxsidebar">
+        <div class="sphinxsidebarwrapper">
+  <h4>Previous topic</h4>
+  <p class="topless"><a href="module.html"
+                        title="previous chapter">Module Interface</a></p>
+  <h4>Next topic</h4>
+  <p class="topless"><a href="cursor.html"
+                        title="next chapter">Cursor Object</a></p>
+<div id="searchbox" style="display: none">
+  <h3>Quick search</h3>
+    <form class="search" action="search.html" method="get">
+      <input type="text" name="q" />
+      <input type="submit" value="Go" />
+      <input type="hidden" name="check_keywords" value="yes" />
+      <input type="hidden" name="area" value="default" />
+    </form>
+    <p class="searchtip" style="font-size: 90%">
+    Enter search terms or a module, class or function name.
+    </p>
+</div>
+<script type="text/javascript">$('#searchbox').show(0);</script>
+        </div>
+      </div>
+      <div class="clearer"></div>
+    </div>
+    <div class="related">
+      <h3>Navigation</h3>
+      <ul>
+        <li class="right" style="margin-right: 10px">
+          <a href="genindex.html" title="General Index"
+             >index</a></li>
+        <li class="right" >
+          <a href="py-modindex.html" title="Python Module Index"
+             >modules</a> |</li>
+        <li class="right" >
+          <a href="cursor.html" title="Cursor Object"
+             >next</a> |</li>
+        <li class="right" >
+          <a href="module.html" title="Module Interface"
+             >previous</a> |</li>
+        <li><a href="index.html">cx_Oracle 5.1.2 documentation</a> &raquo;</li> 
+      </ul>
+    </div>
+    <div class="footer">
+        &copy; Copyright 2012, Anthony Tuininga.
+      Last updated on Jul 02, 2012.
+      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
+    </div>
+  </body>
+</html>
\ No newline at end of file
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/html/cursor.html b/desktop/core/ext-py/cx_Oracle-5.1.2/html/cursor.html
new file mode 100644
index 0000000..4fe3bbd
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/html/cursor.html
@@ -0,0 +1,533 @@
+
+
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
+  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+
+
+<html xmlns="http://www.w3.org/1999/xhtml">
+  <head>
+    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
+    
+    <title>Cursor Object &mdash; cx_Oracle 5.1.2 documentation</title>
+    
+    <link rel="stylesheet" href="_static/default.css" type="text/css" />
+    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
+    
+    <script type="text/javascript">
+      var DOCUMENTATION_OPTIONS = {
+        URL_ROOT:    '',
+        VERSION:     '5.1.2',
+        COLLAPSE_INDEX: false,
+        FILE_SUFFIX: '.html',
+        HAS_SOURCE:  false
+      };
+    </script>
+    <script type="text/javascript" src="_static/jquery.js"></script>
+    <script type="text/javascript" src="_static/underscore.js"></script>
+    <script type="text/javascript" src="_static/doctools.js"></script>
+    <link rel="top" title="cx_Oracle 5.1.2 documentation" href="index.html" />
+    <link rel="next" title="Variable Objects" href="variable.html" />
+    <link rel="prev" title="Connection Object" href="connection.html" /> 
+  </head>
+  <body>
+    <div class="related">
+      <h3>Navigation</h3>
+      <ul>
+        <li class="right" style="margin-right: 10px">
+          <a href="genindex.html" title="General Index"
+             accesskey="I">index</a></li>
+        <li class="right" >
+          <a href="py-modindex.html" title="Python Module Index"
+             >modules</a> |</li>
+        <li class="right" >
+          <a href="variable.html" title="Variable Objects"
+             accesskey="N">next</a> |</li>
+        <li class="right" >
+          <a href="connection.html" title="Connection Object"
+             accesskey="P">previous</a> |</li>
+        <li><a href="index.html">cx_Oracle 5.1.2 documentation</a> &raquo;</li> 
+      </ul>
+    </div>  
+
+    <div class="document">
+      <div class="documentwrapper">
+        <div class="bodywrapper">
+          <div class="body">
+            
+  <div class="section" id="cursor-object">
+<span id="cursorobj"></span><h1>Cursor Object<a class="headerlink" href="#cursor-object" title="Permalink to this headline"></a></h1>
+<dl class="attribute">
+<dt id="Cursor.arraysize">
+<tt class="descclassname">Cursor.</tt><tt class="descname">arraysize</tt><a class="headerlink" href="#Cursor.arraysize" title="Permalink to this definition"></a></dt>
+<dd><p>This read-write attribute specifies the number of rows to fetch at a time
+internally and is the default number of rows to fetch with the
+<a class="reference internal" href="#Cursor.fetchmany" title="Cursor.fetchmany"><tt class="xref py py-meth docutils literal"><span class="pre">fetchmany()</span></tt></a> call.  It defaults to 50 meaning to fetch 50
+rows at a time. Note that this attribute can drastically affect the
+performance of a query since it directly affects the number of network round
+trips that need to be performed. This is the reason for setting it to 50
+instead of the 1 that the DB API recommends.</p>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Cursor.bindarraysize">
+<tt class="descclassname">Cursor.</tt><tt class="descname">bindarraysize</tt><a class="headerlink" href="#Cursor.bindarraysize" title="Permalink to this definition"></a></dt>
+<dd><p>This read-write attribute specifies the number of rows to bind at a time and
+is used when creating variables via setinputsizes() or var(). It defaults to
+1 meaning to bind a single row at a time.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">The DB API definition does not define this attribute.</p>
+</div>
+</dd></dl>
+
+<dl class="method">
+<dt id="Cursor.arrayvar">
+<tt class="descclassname">Cursor.</tt><tt class="descname">arrayvar</tt><big>(</big><em>dataType</em>, <em>value</em><span class="optional">[</span>, <em>size</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#Cursor.arrayvar" title="Permalink to this definition"></a></dt>
+<dd><p>Create an array variable associated with the cursor of the given type and
+size and return a variable object (<a class="reference internal" href="variable.html#varobj"><em>Variable Objects</em></a>). The value is either an
+integer specifying the number of elements to allocate or it is a list and
+the number of elements allocated is drawn from the size of the list. If the
+value is a list, the variable is also set with the contents of the list. If
+the size is not specified and the type is a string or binary, 4000 bytes
+(maximum allowable by Oracle) is allocated. This is needed for passing
+arrays to PL/SQL (in cases where the list might be empty and the type cannot
+be determined automatically) or returning arrays from PL/SQL.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">The DB API definition does not define this method.</p>
+</div>
+</dd></dl>
+
+<dl class="method">
+<dt id="Cursor.bindnames">
+<tt class="descclassname">Cursor.</tt><tt class="descname">bindnames</tt><big>(</big><big>)</big><a class="headerlink" href="#Cursor.bindnames" title="Permalink to this definition"></a></dt>
+<dd><p>Return the list of bind variable names bound to the statement. Note that the
+statement must have been prepared first.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">The DB API definition does not define this method.</p>
+</div>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Cursor.bindvars">
+<tt class="descclassname">Cursor.</tt><tt class="descname">bindvars</tt><a class="headerlink" href="#Cursor.bindvars" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute specifies the bind variables used for the last
+execute. The value will be either a list or a dictionary depending on
+whether binding was done by position or name. Care should be taken when
+referencing this attribute. In particular, elements should not be removed.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">The DB API definition does not define this attribute.</p>
+</div>
+</dd></dl>
+
+<dl class="method">
+<dt id="Cursor.callfunc">
+<tt class="descclassname">Cursor.</tt><tt class="descname">callfunc</tt><big>(</big><em>name</em>, <em>returnType</em>, <em>parameters=</em><span class="optional">[</span><span class="optional">]</span>, <em>keywordParameters = {}</em><big>)</big><a class="headerlink" href="#Cursor.callfunc" title="Permalink to this definition"></a></dt>
+<dd><p>Call a function with the given name. The return type is specified in the
+same notation as is required by setinputsizes(). The sequence of parameters
+must contain one entry for each argument that the function expects. Any
+keyword parameters will be included after the positional parameters. The
+result of the call is the return value of the function.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">The DB API definition does not define this method.</p>
+</div>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">If you intend to call setinputsizes() on the cursor prior to making this
+call, then note that the first item in the argument list refers to the
+return value of the function.</p>
+</div>
+</dd></dl>
+
+<dl class="method">
+<dt id="Cursor.callproc">
+<tt class="descclassname">Cursor.</tt><tt class="descname">callproc</tt><big>(</big><em>name</em>, <em>parameters=</em><span class="optional">[</span><span class="optional">]</span>, <em>keyewordParameters = {}</em><big>)</big><a class="headerlink" href="#Cursor.callproc" title="Permalink to this definition"></a></dt>
+<dd><p>Call a procedure with the given name. The sequence of parameters must
+contain one entry for each argument that the procedure expects. The result
+of the call is a modified copy of the input sequence. Input parameters are
+left untouched; output and input/output parameters are replaced with
+possibly new values. Keyword parameters will be included after the
+positional parameters and are not returned as part of the output sequence.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">The DB API definition does not allow for keyword parameters.</p>
+</div>
+</dd></dl>
+
+<dl class="method">
+<dt id="Cursor.close">
+<tt class="descclassname">Cursor.</tt><tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#Cursor.close" title="Permalink to this definition"></a></dt>
+<dd><p>Close the cursor now, rather than whenever __del__ is called. The cursor
+will be unusable from this point forward; an Error exception will be raised
+if any operation is attempted with the cursor.</p>
+</dd></dl>
+
+<dl class="method">
+<dt id="Cursor.connection">
+<tt class="descclassname">Cursor.</tt><tt class="descname">connection</tt><big>(</big><big>)</big><a class="headerlink" href="#Cursor.connection" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute returns a reference to the connection object on
+which the cursor was created.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This attribute is an extension to the DB API definition but it is
+mentioned in PEP 249 as an optional extension.</p>
+</div>
+</dd></dl>
+
+<dl class="data">
+<dt id="Cursor.description">
+<tt class="descclassname">Cursor.</tt><tt class="descname">description</tt><a class="headerlink" href="#Cursor.description" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute is a sequence of 7-item sequences. Each of these
+sequences contains information describing one result column: (name, type,
+display_size, internal_size, precision, scale, null_ok). This attribute will
+be None for operations that do not return rows or if the cursor has not had
+an operation invoked via the execute() method yet.</p>
+<p>The type will be one of the type objects defined at the module level.</p>
+</dd></dl>
+
+<dl class="method">
+<dt id="Cursor.execute">
+<tt class="descclassname">Cursor.</tt><tt class="descname">execute</tt><big>(</big><em>statement</em><span class="optional">[</span>, <em>parameters</em><span class="optional">]</span>, <em>**keywordParameters</em><big>)</big><a class="headerlink" href="#Cursor.execute" title="Permalink to this definition"></a></dt>
+<dd><p>Execute a statement against the database. Parameters may be passed as a
+dictionary or sequence or as keyword arguments. If the arguments are a
+dictionary, the values will be bound by name and if the arguments are a
+sequence the values will be bound by position.</p>
+<p>A reference to the statement will be retained by the cursor. If None or the
+same string object is passed in again, the cursor will execute that
+statement again without performing a prepare or rebinding and redefining.
+This is most effective for algorithms where the same statement is used, but
+different parameters are bound to it (many times). Note that parameters that
+are not passed in during subsequent executions will retain the value passed
+in during the last execution that contained them.</p>
+<p>For maximum efficiency when reusing an statement, it is best to use the
+setinputsizes() method to specify the parameter types and sizes ahead of
+time; in particular, None is assumed to be a string of length 1 so any
+values that are later bound as numbers or dates will raise a TypeError
+exception.</p>
+<p>If the statement is a query, a list of variable objects (<a class="reference internal" href="variable.html#varobj"><em>Variable Objects</em></a>) will
+be returned corresponding to the list of variables into which data will be
+fetched with the <a class="reference internal" href="#Cursor.fetchone" title="Cursor.fetchone"><tt class="xref py py-meth docutils literal"><span class="pre">fetchone()</span></tt></a>, <a class="reference internal" href="#Cursor.fetchmany" title="Cursor.fetchmany"><tt class="xref py py-meth docutils literal"><span class="pre">fetchmany()</span></tt></a> and
+<a class="reference internal" href="#Cursor.fetchall" title="Cursor.fetchall"><tt class="xref py py-meth docutils literal"><span class="pre">fetchall()</span></tt></a> methods; otherwise, <tt class="docutils literal"><span class="pre">None</span></tt> will be returned.</p>
+</dd></dl>
+
+<dl class="method">
+<dt id="Cursor.executemany">
+<tt class="descclassname">Cursor.</tt><tt class="descname">executemany</tt><big>(</big><em>statement</em>, <em>parameters</em><big>)</big><a class="headerlink" href="#Cursor.executemany" title="Permalink to this definition"></a></dt>
+<dd><p>Prepare a statement for execution against a database and then execute it
+against all parameter mappings or sequences found in the sequence
+parameters. The statement is managed in the same way as the execute()
+method manages it.</p>
+</dd></dl>
+
+<dl class="method">
+<dt id="Cursor.executemanyprepared">
+<tt class="descclassname">Cursor.</tt><tt class="descname">executemanyprepared</tt><big>(</big><em>numIters</em><big>)</big><a class="headerlink" href="#Cursor.executemanyprepared" title="Permalink to this definition"></a></dt>
+<dd><p>Execute the previously prepared and bound statement the given number of
+times.  The variables that are bound must have already been set to their
+desired value before this call is made.  This method was designed for the
+case where optimal performance is required as it comes at the expense of
+compatibility with the DB API.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">The DB API definition does not define this method.</p>
+</div>
+</dd></dl>
+
+<dl class="method">
+<dt id="Cursor.fetchall">
+<tt class="descclassname">Cursor.</tt><tt class="descname">fetchall</tt><big>(</big><big>)</big><a class="headerlink" href="#Cursor.fetchall" title="Permalink to this definition"></a></dt>
+<dd><p>Fetch all (remaining) rows of a query result, returning them as a list of
+tuples. An empty list is returned if no more rows are available. Note that
+the cursor&#8217;s arraysize attribute can affect the performance of this
+operation, as internally reads from the database are done in batches
+corresponding to the arraysize.</p>
+<p>An exception is raised if the previous call to execute() did not produce any
+result set or no call was issued yet.</p>
+</dd></dl>
+
+<dl class="method">
+<dt id="Cursor.fetchmany">
+<tt class="descclassname">Cursor.</tt><tt class="descname">fetchmany</tt><big>(</big><span class="optional">[</span><em>numRows=cursor.arraysize</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#Cursor.fetchmany" title="Permalink to this definition"></a></dt>
+<dd><p>Fetch the next set of rows of a query result, returning a list of tuples. An
+empty list is returned if no more rows are available. Note that the cursor&#8217;s
+arraysize attribute can affect the performance of this operation.</p>
+<p>The number of rows to fetch is specified by the parameter. If it is not
+given, the cursor&#8217;s arrysize attribute determines the number of rows to be
+fetched. If the number of rows available to be fetched is fewer than the
+amount requested, fewer rows will be returned.</p>
+<p>An exception is raised if the previous call to execute() did not produce any
+result set or no call was issued yet.</p>
+</dd></dl>
+
+<dl class="method">
+<dt id="Cursor.fetchone">
+<tt class="descclassname">Cursor.</tt><tt class="descname">fetchone</tt><big>(</big><big>)</big><a class="headerlink" href="#Cursor.fetchone" title="Permalink to this definition"></a></dt>
+<dd><p>Fetch the next row of a query result set, returning a single tuple or None
+when no more data is available.</p>
+<p>An exception is raised if the previous call to execute() did not produce any
+result set or no call was issued yet.</p>
+</dd></dl>
+
+<dl class="method">
+<dt id="Cursor.fetchraw">
+<tt class="descclassname">Cursor.</tt><tt class="descname">fetchraw</tt><big>(</big><span class="optional">[</span><em>numRows=cursor.arraysize</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#Cursor.fetchraw" title="Permalink to this definition"></a></dt>
+<dd><p>Fetch the next set of rows of a query result into the internal buffers of
+the defined variables for the cursor. The number of rows actually fetched is
+returned.  This method was designed for the case where optimal performance
+is required as it comes at the expense of compatibility with the DB API.</p>
+<p>An exception is raised if the previous call to execute() did not produce any
+result set or no call was issued yet.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">The DB API definition does not define this method.</p>
+</div>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Cursor.fetchvars">
+<tt class="descclassname">Cursor.</tt><tt class="descname">fetchvars</tt><a class="headerlink" href="#Cursor.fetchvars" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute specifies the list of variables created for the
+last query that was executed on the cursor.  Care should be taken when
+referencing this attribute. In particular, elements should not be removed.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">The DB API definition does not define this attribute.</p>
+</div>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Cursor.inputtypehandler">
+<tt class="descclassname">Cursor.</tt><tt class="descname">inputtypehandler</tt><a class="headerlink" href="#Cursor.inputtypehandler" title="Permalink to this definition"></a></dt>
+<dd><p>This read-write attribute specifies a method called for each value that is
+bound to a statement executed on the cursor and overrides the attribute with
+the same name on the connection if specified. The method signature is
+handler(cursor, value, arraysize) and the return value is expected to be a
+variable object or None in which case a default variable object will be
+created. If this attribute is None, the value of the attribute with the same
+name on the connection is used.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This attribute is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="method">
+<dt id="Cursor.__iter__">
+<tt class="descclassname">Cursor.</tt><tt class="descname">__iter__</tt><big>(</big><big>)</big><a class="headerlink" href="#Cursor.__iter__" title="Permalink to this definition"></a></dt>
+<dd><p>Returns the cursor itself to be used as an iterator.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This method is an extension to the DB API definition but it is
+mentioned in PEP 249 as an optional extension.</p>
+</div>
+</dd></dl>
+
+<dl class="method">
+<dt id="Cursor.next">
+<tt class="descclassname">Cursor.</tt><tt class="descname">next</tt><big>(</big><big>)</big><a class="headerlink" href="#Cursor.next" title="Permalink to this definition"></a></dt>
+<dd><p>Fetch the next row of a query result set, using the same semantics as the
+method fetchone().</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This method is an extension to the DB API definition but it is
+mentioned in PEP 249 as an optional extension.</p>
+</div>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Cursor.numbersAsStrings">
+<tt class="descclassname">Cursor.</tt><tt class="descname">numbersAsStrings</tt><a class="headerlink" href="#Cursor.numbersAsStrings" title="Permalink to this definition"></a></dt>
+<dd><p>This integer attribute defines whether or not numbers should be returned as
+strings rather than integers or floating point numbers. This is useful to
+get around the fact that Oracle floating point numbers have considerably
+greater precision than C floating point numbers and not require a change to
+the SQL being executed.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">The DB API definition does not define this attribute.</p>
+</div>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Cursor.outputtypehandler">
+<tt class="descclassname">Cursor.</tt><tt class="descname">outputtypehandler</tt><a class="headerlink" href="#Cursor.outputtypehandler" title="Permalink to this definition"></a></dt>
+<dd><p>This read-write attribute specifies a method called for each value that is
+to be fetched from this cursor. The method signature is
+handler(cursor, name, defaultType, length, precision, scale) and the return
+value is expected to be a variable object or None in which case a default
+variable object will be created. If this attribute is None, the value of
+the attribute with the same name on the connection is used instead.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This attribute is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="method">
+<dt id="Cursor.parse">
+<tt class="descclassname">Cursor.</tt><tt class="descname">parse</tt><big>(</big><em>statement</em><big>)</big><a class="headerlink" href="#Cursor.parse" title="Permalink to this definition"></a></dt>
+<dd><p>This can be used to parse a statement without actually executing it (this
+step is done automatically by Oracle when a statement is executed).</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">The DB API definition does not define this method.</p>
+</div>
+</dd></dl>
+
+<dl class="method">
+<dt id="Cursor.prepare">
+<tt class="descclassname">Cursor.</tt><tt class="descname">prepare</tt><big>(</big><em>statement</em><span class="optional">[</span>, <em>tag</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#Cursor.prepare" title="Permalink to this definition"></a></dt>
+<dd><p>This can be used before a call to execute() to define the statement that
+will be executed. When this is done, the prepare phase will not be performed
+when the call to execute() is made with None or the same string object as
+the statement.  If specified (Oracle 9i and higher) the statement will be
+returned to the statement cache with the given tag. See the Oracle
+documentation for more information about the statement cache.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">The DB API definition does not define this method.</p>
+</div>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Cursor.rowcount">
+<tt class="descclassname">Cursor.</tt><tt class="descname">rowcount</tt><a class="headerlink" href="#Cursor.rowcount" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute specifies the number of rows that have currently
+been fetched from the cursor (for select statements) or that have been
+affected by the operation (for insert, update and delete statements).</p>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Cursor.rowfactory">
+<tt class="descclassname">Cursor.</tt><tt class="descname">rowfactory</tt><a class="headerlink" href="#Cursor.rowfactory" title="Permalink to this definition"></a></dt>
+<dd><p>This read-write attribute specifies a method to call for each row that is
+retrieved from the database. Ordinarily a tuple is returned for each row but
+if this attribute is set, the method is called with the argument tuple that
+would normally be returned and the result of the method is returned instead.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">The DB API definition does not define this attribute.</p>
+</div>
+</dd></dl>
+
+<dl class="method">
+<dt id="Cursor.setinputsizes">
+<tt class="descclassname">Cursor.</tt><tt class="descname">setinputsizes</tt><big>(</big><em>*args</em>, <em>**keywordArgs</em><big>)</big><a class="headerlink" href="#Cursor.setinputsizes" title="Permalink to this definition"></a></dt>
+<dd><p>This can be used before a call to execute(), callfunc() or callproc() to
+predefine memory areas for the operation&#8217;s parameters. Each parameter should
+be a type object corresponding to the input that will be used or it should
+be an integer specifying the maximum length of a string parameter. Use
+keyword arguments when binding by name and positional arguments when binding
+by position. The singleton None can be used as a parameter when using
+positional arguments to indicate that no space should be reserved for that
+position.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">If you plan to use callfunc() then be aware that the first argument in
+the list refers to the return value of the function.</p>
+</div>
+</dd></dl>
+
+<dl class="method">
+<dt id="Cursor.setoutputsize">
+<tt class="descclassname">Cursor.</tt><tt class="descname">setoutputsize</tt><big>(</big><em>size</em><span class="optional">[</span>, <em>column</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#Cursor.setoutputsize" title="Permalink to this definition"></a></dt>
+<dd><p>This can be used before a call to execute() to predefine memory areas for
+the long columns that will be fetched. The column is specified as an index
+into the result sequence. Not specifying the column will set the default
+size for all large columns in the cursor.</p>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Cursor.statement">
+<tt class="descclassname">Cursor.</tt><tt class="descname">statement</tt><a class="headerlink" href="#Cursor.statement" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute provides the string object that was previously
+prepared with prepare() or executed with execute().</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">The DB API definition does not define this attribute.</p>
+</div>
+</dd></dl>
+
+<dl class="method">
+<dt id="Cursor.var">
+<tt class="descclassname">Cursor.</tt><tt class="descname">var</tt><big>(</big><em>dataType</em><span class="optional">[</span>, <em>size</em>, <em>arraysize</em>, <em>inconverter</em>, <em>outconverter</em>, <em>typename</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#Cursor.var" title="Permalink to this definition"></a></dt>
+<dd><p>Create a variable associated with the cursor of the given type and
+characteristics and return a variable object (<a class="reference internal" href="variable.html#varobj"><em>Variable Objects</em></a>). If the size is
+not specified and the type is a string or binary, 4000 bytes (maximum
+allowable by Oracle) is allocated; if the size is not specified and the type
+is a long string or long binary, 128KB is allocated. If the arraysize is not
+specified, the bind array size (usually 1) is used. The inconverter and
+outconverter specify methods used for converting values to/from the
+database. More information can be found in the section on variable objects.</p>
+<p>To create an empty SQL object variable, specify the typename. Additional
+support for editing the attributes of this object is not yet available but
+will be forthcoming in a future release.</p>
+<p>This method was designed for use with PL/SQL in/out variables where the
+length or type cannot be determined automatically from the Python object
+passed in or for use in input and output type handlers defined on cursors
+or connections.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">The DB API definition does not define this method.</p>
+</div>
+</dd></dl>
+
+</div>
+
+
+          </div>
+        </div>
+      </div>
+      <div class="sphinxsidebar">
+        <div class="sphinxsidebarwrapper">
+  <h4>Previous topic</h4>
+  <p class="topless"><a href="connection.html"
+                        title="previous chapter">Connection Object</a></p>
+  <h4>Next topic</h4>
+  <p class="topless"><a href="variable.html"
+                        title="next chapter">Variable Objects</a></p>
+<div id="searchbox" style="display: none">
+  <h3>Quick search</h3>
+    <form class="search" action="search.html" method="get">
+      <input type="text" name="q" />
+      <input type="submit" value="Go" />
+      <input type="hidden" name="check_keywords" value="yes" />
+      <input type="hidden" name="area" value="default" />
+    </form>
+    <p class="searchtip" style="font-size: 90%">
+    Enter search terms or a module, class or function name.
+    </p>
+</div>
+<script type="text/javascript">$('#searchbox').show(0);</script>
+        </div>
+      </div>
+      <div class="clearer"></div>
+    </div>
+    <div class="related">
+      <h3>Navigation</h3>
+      <ul>
+        <li class="right" style="margin-right: 10px">
+          <a href="genindex.html" title="General Index"
+             >index</a></li>
+        <li class="right" >
+          <a href="py-modindex.html" title="Python Module Index"
+             >modules</a> |</li>
+        <li class="right" >
+          <a href="variable.html" title="Variable Objects"
+             >next</a> |</li>
+        <li class="right" >
+          <a href="connection.html" title="Connection Object"
+             >previous</a> |</li>
+        <li><a href="index.html">cx_Oracle 5.1.2 documentation</a> &raquo;</li> 
+      </ul>
+    </div>
+    <div class="footer">
+        &copy; Copyright 2012, Anthony Tuininga.
+      Last updated on Jul 02, 2012.
+      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
+    </div>
+  </body>
+</html>
\ No newline at end of file
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/html/genindex.html b/desktop/core/ext-py/cx_Oracle-5.1.2/html/genindex.html
new file mode 100644
index 0000000..2e3689f
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/html/genindex.html
@@ -0,0 +1,1157 @@
+
+
+
+
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
+  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+
+
+<html xmlns="http://www.w3.org/1999/xhtml">
+  <head>
+    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
+    
+    <title>Index &mdash; cx_Oracle 5.1.2 documentation</title>
+    
+    <link rel="stylesheet" href="_static/default.css" type="text/css" />
+    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
+    
+    <script type="text/javascript">
+      var DOCUMENTATION_OPTIONS = {
+        URL_ROOT:    '',
+        VERSION:     '5.1.2',
+        COLLAPSE_INDEX: false,
+        FILE_SUFFIX: '.html',
+        HAS_SOURCE:  false
+      };
+    </script>
+    <script type="text/javascript" src="_static/jquery.js"></script>
+    <script type="text/javascript" src="_static/underscore.js"></script>
+    <script type="text/javascript" src="_static/doctools.js"></script>
+    <link rel="top" title="cx_Oracle 5.1.2 documentation" href="index.html" /> 
+  </head>
+  <body>
+    <div class="related">
+      <h3>Navigation</h3>
+      <ul>
+        <li class="right" style="margin-right: 10px">
+          <a href="#" title="General Index"
+             accesskey="I">index</a></li>
+        <li class="right" >
+          <a href="py-modindex.html" title="Python Module Index"
+             >modules</a> |</li>
+        <li><a href="index.html">cx_Oracle 5.1.2 documentation</a> &raquo;</li> 
+      </ul>
+    </div>  
+
+    <div class="document">
+      <div class="documentwrapper">
+        <div class="bodywrapper">
+          <div class="body">
+            
+
+<h1 id="index">Index</h1>
+
+<div class="genindex-jumpbox">
+ <a href="#_"><strong>_</strong></a>
+ | <a href="#A"><strong>A</strong></a>
+ | <a href="#B"><strong>B</strong></a>
+ | <a href="#C"><strong>C</strong></a>
+ | <a href="#D"><strong>D</strong></a>
+ | <a href="#E"><strong>E</strong></a>
+ | <a href="#F"><strong>F</strong></a>
+ | <a href="#G"><strong>G</strong></a>
+ | <a href="#H"><strong>H</strong></a>
+ | <a href="#I"><strong>I</strong></a>
+ | <a href="#L"><strong>L</strong></a>
+ | <a href="#M"><strong>M</strong></a>
+ | <a href="#N"><strong>N</strong></a>
+ | <a href="#O"><strong>O</strong></a>
+ | <a href="#P"><strong>P</strong></a>
+ | <a href="#R"><strong>R</strong></a>
+ | <a href="#S"><strong>S</strong></a>
+ | <a href="#T"><strong>T</strong></a>
+ | <a href="#U"><strong>U</strong></a>
+ | <a href="#V"><strong>V</strong></a>
+ | <a href="#W"><strong>W</strong></a>
+ 
+</div>
+<h2 id="_">_</h2>
+<table style="width: 100%" class="indextable genindextable"><tr>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="connection.html#Connection.__enter__">__enter__() (Connection method)</a>
+  </dt>
+
+      
+  <dt><a href="connection.html#Connection.__exit__">__exit__() (Connection method)</a>
+  </dt>
+
+  </dl></td>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="cursor.html#Cursor.__iter__">__iter__() (Cursor method)</a>
+  </dt>
+
+  </dl></td>
+</tr></table>
+
+<h2 id="A">A</h2>
+<table style="width: 100%" class="indextable genindextable"><tr>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="session_pool.html#SessionPool.acquire">acquire() (SessionPool method)</a>
+  </dt>
+
+      
+  <dt><a href="connection.html#Connection.action">action (Connection attribute)</a>
+  </dt>
+
+      
+  <dt><a href="variable.html#Variable.allocelems">allocelems (Variable attribute)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.apilevel">apilevel (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="cursor.html#Cursor.arraysize">arraysize (Cursor attribute)</a>
+  </dt>
+
+  </dl></td>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="cursor.html#Cursor.arrayvar">arrayvar() (Cursor method)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.ATTR_PURITY_DEFAULT">ATTR_PURITY_DEFAULT (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.ATTR_PURITY_NEW">ATTR_PURITY_NEW (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.ATTR_PURITY_SELF">ATTR_PURITY_SELF (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="connection.html#Connection.autocommit">autocommit (Connection attribute)</a>
+  </dt>
+
+  </dl></td>
+</tr></table>
+
+<h2 id="B">B</h2>
+<table style="width: 100%" class="indextable genindextable"><tr>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="connection.html#Connection.begin">begin() (Connection method)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.BFILE">BFILE (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.BINARY">BINARY (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.Binary">Binary() (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="cursor.html#Cursor.bindarraysize">bindarraysize (Cursor attribute)</a>
+  </dt>
+
+      
+  <dt><a href="cursor.html#Cursor.bindnames">bindnames() (Cursor method)</a>
+  </dt>
+
+  </dl></td>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="cursor.html#Cursor.bindvars">bindvars (Cursor attribute)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.BLOB">BLOB (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="variable.html#Variable.bufferSize">bufferSize (Variable attribute)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.buildtime">buildtime (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="session_pool.html#SessionPool.busy">busy (SessionPool attribute)</a>
+  </dt>
+
+  </dl></td>
+</tr></table>
+
+<h2 id="C">C</h2>
+<table style="width: 100%" class="indextable genindextable"><tr>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="subscription.html#Subscription.callback">callback (Subscription attribute)</a>
+  </dt>
+
+      
+  <dt><a href="cursor.html#Cursor.callfunc">callfunc() (Cursor method)</a>
+  </dt>
+
+      
+  <dt><a href="cursor.html#Cursor.callproc">callproc() (Cursor method)</a>
+  </dt>
+
+      
+  <dt><a href="connection.html#Connection.cancel">cancel() (Connection method)</a>
+  </dt>
+
+      
+  <dt><a href="connection.html#Connection.changepassword">changepassword() (Connection method)</a>
+  </dt>
+
+      
+  <dt><a href="connection.html#Connection.client_identifier">client_identifier (Connection attribute)</a>
+  </dt>
+
+      
+  <dt><a href="connection.html#Connection.clientinfo">clientinfo (Connection attribute)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.clientversion">clientversion() (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.CLOB">CLOB (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="connection.html#Connection.close">close() (Connection method)</a>
+  </dt>
+
+      <dd><dl>
+        
+  <dt><a href="cursor.html#Cursor.close">(Cursor method)</a>
+  </dt>
+
+        
+  <dt><a href="lob.html#LOB.close">(LOB method)</a>
+  </dt>
+
+      </dl></dd>
+      
+  <dt><a href="module.html#cx_Oracle._Error.code">code (cx_Oracle._Error attribute)</a>
+  </dt>
+
+      
+  <dt><a href="connection.html#Connection.commit">commit() (Connection method)</a>
+  </dt>
+
+  </dl></td>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="module.html#cx_Oracle.connect">connect() (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="subscription.html#Subscription.connection">connection (Subscription attribute)</a>
+  </dt>
+
+      
+  <dt><a href="cursor.html#Cursor.connection">connection() (Cursor method)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.Connection">Connection() (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle._Error.context">context (cx_Oracle._Error attribute)</a>
+  </dt>
+
+      
+  <dt><a href="connection.html#Connection.current_schema">current_schema (Connection attribute)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.CURSOR">CURSOR (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="connection.html#Connection.cursor">cursor() (Connection method)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.Cursor">Cursor() (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="cursor.html#Cursor.description">Cursor.description (built-in variable)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#module-cx_Oracle">cx_Oracle (module)</a>
+  </dt>
+
+  </dl></td>
+</tr></table>
+
+<h2 id="D">D</h2>
+<table style="width: 100%" class="indextable genindextable"><tr>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="module.html#cx_Oracle.DatabaseError">DatabaseError</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.DataError">DataError</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.Date">Date() (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.DateFromTicks">DateFromTicks() (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.DATETIME">DATETIME (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="subscription.html#Message.dbname">dbname (Message attribute)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.DBSHUTDOWN_ABORT">DBSHUTDOWN_ABORT (in module cx_Oracle)</a>
+  </dt>
+
+  </dl></td>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="module.html#cx_Oracle.DBSHUTDOWN_FINAL">DBSHUTDOWN_FINAL (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.DBSHUTDOWN_IMMEDIATE">DBSHUTDOWN_IMMEDIATE (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.DBSHUTDOWN_TRANSACTIONAL">DBSHUTDOWN_TRANSACTIONAL (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.DBSHUTDOWN_TRANSACTIONAL_LOCAL">DBSHUTDOWN_TRANSACTIONAL_LOCAL (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="session_pool.html#SessionPool.drop">drop() (SessionPool method)</a>
+  </dt>
+
+      
+  <dt><a href="connection.html#Connection.dsn">dsn (Connection attribute)</a>
+  </dt>
+
+      <dd><dl>
+        
+  <dt><a href="session_pool.html#SessionPool.dsn">(SessionPool attribute)</a>
+  </dt>
+
+      </dl></dd>
+  </dl></td>
+</tr></table>
+
+<h2 id="E">E</h2>
+<table style="width: 100%" class="indextable genindextable"><tr>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="connection.html#Connection.encoding">encoding (Connection attribute)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.Error">Error</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.EVENT_DEREG">EVENT_DEREG (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.EVENT_NONE">EVENT_NONE (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.EVENT_OBJCHANGE">EVENT_OBJCHANGE (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.EVENT_SHUTDOWN">EVENT_SHUTDOWN (in module cx_Oracle)</a>
+  </dt>
+
+  </dl></td>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="module.html#cx_Oracle.EVENT_SHUTDOWN_ANY">EVENT_SHUTDOWN_ANY (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.EVENT_STARTUP">EVENT_STARTUP (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="cursor.html#Cursor.execute">execute() (Cursor method)</a>
+  </dt>
+
+      
+  <dt><a href="cursor.html#Cursor.executemany">executemany() (Cursor method)</a>
+  </dt>
+
+      
+  <dt><a href="cursor.html#Cursor.executemanyprepared">executemanyprepared() (Cursor method)</a>
+  </dt>
+
+  </dl></td>
+</tr></table>
+
+<h2 id="F">F</h2>
+<table style="width: 100%" class="indextable genindextable"><tr>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="cursor.html#Cursor.fetchall">fetchall() (Cursor method)</a>
+  </dt>
+
+      
+  <dt><a href="cursor.html#Cursor.fetchmany">fetchmany() (Cursor method)</a>
+  </dt>
+
+      
+  <dt><a href="cursor.html#Cursor.fetchone">fetchone() (Cursor method)</a>
+  </dt>
+
+      
+  <dt><a href="cursor.html#Cursor.fetchraw">fetchraw() (Cursor method)</a>
+  </dt>
+
+      
+  <dt><a href="cursor.html#Cursor.fetchvars">fetchvars (Cursor attribute)</a>
+  </dt>
+
+      
+  <dt><a href="lob.html#LOB.fileexists">fileexists() (LOB method)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.FIXED_CHAR">FIXED_CHAR (in module cx_Oracle)</a>
+  </dt>
+
+  </dl></td>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="module.html#cx_Oracle.FIXED_UNICODE">FIXED_UNICODE (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.FNCODE_BINDBYNAME">FNCODE_BINDBYNAME (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.FNCODE_BINDBYPOS">FNCODE_BINDBYPOS (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.FNCODE_DEFINEBYPOS">FNCODE_DEFINEBYPOS (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.FNCODE_STMTEXECUTE">FNCODE_STMTEXECUTE (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.FNCODE_STMTFETCH">FNCODE_STMTFETCH (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.FNCODE_STMTPREPARE">FNCODE_STMTPREPARE (in module cx_Oracle)</a>
+  </dt>
+
+  </dl></td>
+</tr></table>
+
+<h2 id="G">G</h2>
+<table style="width: 100%" class="indextable genindextable"><tr>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="lob.html#LOB.getchunksize">getchunksize() (LOB method)</a>
+  </dt>
+
+      
+  <dt><a href="lob.html#LOB.getfilename">getfilename() (LOB method)</a>
+  </dt>
+
+  </dl></td>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="variable.html#Variable.getvalue">getvalue() (Variable method)</a>
+  </dt>
+
+  </dl></td>
+</tr></table>
+
+<h2 id="H">H</h2>
+<table style="width: 100%" class="indextable genindextable"><tr>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="session_pool.html#SessionPool.homogeneous">homogeneous (SessionPool attribute)</a>
+  </dt>
+
+  </dl></td>
+</tr></table>
+
+<h2 id="I">I</h2>
+<table style="width: 100%" class="indextable genindextable"><tr>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="variable.html#Variable.inconverter">inconverter (Variable attribute)</a>
+  </dt>
+
+      
+  <dt><a href="session_pool.html#SessionPool.increment">increment (SessionPool attribute)</a>
+  </dt>
+
+      
+  <dt><a href="connection.html#Connection.inputtypehandler">inputtypehandler (Connection attribute)</a>
+  </dt>
+
+      <dd><dl>
+        
+  <dt><a href="cursor.html#Cursor.inputtypehandler">(Cursor attribute)</a>
+  </dt>
+
+      </dl></dd>
+      
+  <dt><a href="module.html#cx_Oracle.IntegrityError">IntegrityError</a>
+  </dt>
+
+  </dl></td>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="module.html#cx_Oracle.InterfaceError">InterfaceError</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.InternalError">InternalError</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.INTERVAL">INTERVAL (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="lob.html#LOB.isopen">isopen() (LOB method)</a>
+  </dt>
+
+  </dl></td>
+</tr></table>
+
+<h2 id="L">L</h2>
+<table style="width: 100%" class="indextable genindextable"><tr>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="module.html#cx_Oracle.LOB">LOB (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.LONG_BINARY">LONG_BINARY (in module cx_Oracle)</a>
+  </dt>
+
+  </dl></td>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="module.html#cx_Oracle.LONG_STRING">LONG_STRING (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.LONG_UNICODE">LONG_UNICODE (in module cx_Oracle)</a>
+  </dt>
+
+  </dl></td>
+</tr></table>
+
+<h2 id="M">M</h2>
+<table style="width: 100%" class="indextable genindextable"><tr>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="module.html#cx_Oracle.makedsn">makedsn() (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="session_pool.html#SessionPool.max">max (SessionPool attribute)</a>
+  </dt>
+
+      
+  <dt><a href="connection.html#Connection.maxBytesPerCharacter">maxBytesPerCharacter (Connection attribute)</a>
+  </dt>
+
+      
+  <dt><a href="variable.html#Variable.maxlength">maxlength (Variable attribute)</a>
+  </dt>
+
+  </dl></td>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="module.html#cx_Oracle._Error.message">message (cx_Oracle._Error attribute)</a>
+  </dt>
+
+      
+  <dt><a href="session_pool.html#SessionPool.min">min (SessionPool attribute)</a>
+  </dt>
+
+      
+  <dt><a href="connection.html#Connection.module">module (Connection attribute)</a>
+  </dt>
+
+  </dl></td>
+</tr></table>
+
+<h2 id="N">N</h2>
+<table style="width: 100%" class="indextable genindextable"><tr>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="subscription.html#MessageTable.name">name (MessageTable attribute)</a>
+  </dt>
+
+      <dd><dl>
+        
+  <dt><a href="session_pool.html#SessionPool.name">(SessionPool attribute)</a>
+  </dt>
+
+      </dl></dd>
+      
+  <dt><a href="subscription.html#Subscription.namespace">namespace (Subscription attribute)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.NATIVE_FLOAT">NATIVE_FLOAT (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.NCLOB">NCLOB (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="connection.html#Connection.nencoding">nencoding (Connection attribute)</a>
+  </dt>
+
+  </dl></td>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="cursor.html#Cursor.next">next() (Cursor method)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.NotSupportedError">NotSupportedError</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.NUMBER">NUMBER (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="cursor.html#Cursor.numbersAsStrings">numbersAsStrings (Cursor attribute)</a>
+  </dt>
+
+      
+  <dt><a href="variable.html#Variable.numElements">numElements (Variable attribute)</a>
+  </dt>
+
+  </dl></td>
+</tr></table>
+
+<h2 id="O">O</h2>
+<table style="width: 100%" class="indextable genindextable"><tr>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="module.html#cx_Oracle.OBJECT">OBJECT (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle._Error.offset">offset (cx_Oracle._Error attribute)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.OPCODE_ALLOPS">OPCODE_ALLOPS (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.OPCODE_ALLROWS">OPCODE_ALLROWS (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.OPCODE_ALTER">OPCODE_ALTER (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.OPCODE_DELETE">OPCODE_DELETE (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.OPCODE_DROP">OPCODE_DROP (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.OPCODE_INSERT">OPCODE_INSERT (in module cx_Oracle)</a>
+  </dt>
+
+  </dl></td>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="module.html#cx_Oracle.OPCODE_UPDATE">OPCODE_UPDATE (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="lob.html#LOB.open">open() (LOB method)</a>
+  </dt>
+
+      
+  <dt><a href="session_pool.html#SessionPool.opened">opened (SessionPool attribute)</a>
+  </dt>
+
+      
+  <dt><a href="subscription.html#MessageRow.operation">operation (MessageRow attribute)</a>
+  </dt>
+
+      <dd><dl>
+        
+  <dt><a href="subscription.html#MessageTable.operation">(MessageTable attribute)</a>
+  </dt>
+
+      </dl></dd>
+      
+  <dt><a href="module.html#cx_Oracle.OperationalError">OperationalError</a>
+  </dt>
+
+      
+  <dt><a href="subscription.html#Subscription.operations">operations (Subscription attribute)</a>
+  </dt>
+
+      
+  <dt><a href="variable.html#Variable.outconverter">outconverter (Variable attribute)</a>
+  </dt>
+
+      
+  <dt><a href="connection.html#Connection.outputtypehandler">outputtypehandler (Connection attribute)</a>
+  </dt>
+
+      <dd><dl>
+        
+  <dt><a href="cursor.html#Cursor.outputtypehandler">(Cursor attribute)</a>
+  </dt>
+
+      </dl></dd>
+  </dl></td>
+</tr></table>
+
+<h2 id="P">P</h2>
+<table style="width: 100%" class="indextable genindextable"><tr>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="module.html#cx_Oracle.paramstyle">paramstyle (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="cursor.html#Cursor.parse">parse() (Cursor method)</a>
+  </dt>
+
+      
+  <dt><a href="connection.html#Connection.password">password (Connection attribute)</a>
+  </dt>
+
+      <dd><dl>
+        
+  <dt><a href="session_pool.html#SessionPool.password">(SessionPool attribute)</a>
+  </dt>
+
+      </dl></dd>
+      
+  <dt><a href="connection.html#Connection.ping">ping() (Connection method)</a>
+  </dt>
+
+      
+  <dt><a href="subscription.html#Subscription.port">port (Subscription attribute)</a>
+  </dt>
+
+  </dl></td>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="module.html#cx_Oracle.PRELIM_AUTH">PRELIM_AUTH (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="connection.html#Connection.prepare">prepare() (Connection method)</a>
+  </dt>
+
+      <dd><dl>
+        
+  <dt><a href="cursor.html#Cursor.prepare">(Cursor method)</a>
+  </dt>
+
+      </dl></dd>
+      
+  <dt><a href="module.html#cx_Oracle.ProgrammingError">ProgrammingError</a>
+  </dt>
+
+      
+  <dt><a href="subscription.html#Subscription.protocol">protocol (Subscription attribute)</a>
+  </dt>
+
+  </dl></td>
+</tr></table>
+
+<h2 id="R">R</h2>
+<table style="width: 100%" class="indextable genindextable"><tr>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="lob.html#LOB.read">read() (LOB method)</a>
+  </dt>
+
+      
+  <dt><a href="connection.html#Connection.register">register() (Connection method)</a>
+  </dt>
+
+      
+  <dt><a href="subscription.html#Subscription.registerquery">registerquery() (Subscription method)</a>
+  </dt>
+
+      
+  <dt><a href="session_pool.html#SessionPool.release">release() (SessionPool method)</a>
+  </dt>
+
+      
+  <dt><a href="connection.html#Connection.rollback">rollback() (Connection method)</a>
+  </dt>
+
+      
+  <dt><a href="cursor.html#Cursor.rowcount">rowcount (Cursor attribute)</a>
+  </dt>
+
+  </dl></td>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="cursor.html#Cursor.rowfactory">rowfactory (Cursor attribute)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.ROWID">ROWID (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="subscription.html#MessageRow.rowid">rowid (MessageRow attribute)</a>
+  </dt>
+
+      
+  <dt><a href="subscription.html#Subscription.rowids">rowids (Subscription attribute)</a>
+  </dt>
+
+      
+  <dt><a href="subscription.html#MessageTable.rows">rows (MessageTable attribute)</a>
+  </dt>
+
+  </dl></td>
+</tr></table>
+
+<h2 id="S">S</h2>
+<table style="width: 100%" class="indextable genindextable"><tr>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="module.html#cx_Oracle.SessionPool">SessionPool() (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="lob.html#LOB.setfilename">setfilename() (LOB method)</a>
+  </dt>
+
+      
+  <dt><a href="cursor.html#Cursor.setinputsizes">setinputsizes() (Cursor method)</a>
+  </dt>
+
+      
+  <dt><a href="cursor.html#Cursor.setoutputsize">setoutputsize() (Cursor method)</a>
+  </dt>
+
+      
+  <dt><a href="variable.html#Variable.setvalue">setvalue() (Variable method)</a>
+  </dt>
+
+      
+  <dt><a href="connection.html#Connection.shutdown">shutdown() (Connection method)</a>
+  </dt>
+
+      
+  <dt><a href="variable.html#Variable.size">size (Variable attribute)</a>
+  </dt>
+
+      
+  <dt><a href="lob.html#LOB.size">size() (LOB method)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.SPOOL_ATTRVAL_FORCEGET">SPOOL_ATTRVAL_FORCEGET (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.SPOOL_ATTRVAL_NOWAIT">SPOOL_ATTRVAL_NOWAIT (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.SPOOL_ATTRVAL_WAIT">SPOOL_ATTRVAL_WAIT (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="connection.html#Connection.startup">startup() (Connection method)</a>
+  </dt>
+
+  </dl></td>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="cursor.html#Cursor.statement">statement (Cursor attribute)</a>
+  </dt>
+
+      
+  <dt><a href="connection.html#Connection.stmtcachesize">stmtcachesize (Connection attribute)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.STRING">STRING (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.SUBSCR_NAMESPACE_DBCHANGE">SUBSCR_NAMESPACE_DBCHANGE (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.SUBSCR_PROTO_HTTP">SUBSCR_PROTO_HTTP (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.SUBSCR_PROTO_MAIL">SUBSCR_PROTO_MAIL (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.SUBSCR_PROTO_OCI">SUBSCR_PROTO_OCI (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.SUBSCR_PROTO_SERVER">SUBSCR_PROTO_SERVER (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="connection.html#Connection.subscribe">subscribe() (Connection method)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.SYSDBA">SYSDBA (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.SYSOPER">SYSOPER (in module cx_Oracle)</a>
+  </dt>
+
+  </dl></td>
+</tr></table>
+
+<h2 id="T">T</h2>
+<table style="width: 100%" class="indextable genindextable"><tr>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="subscription.html#Message.tables">tables (Message attribute)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.threadsafety">threadsafety (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.Time">Time() (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.TimeFromTicks">TimeFromTicks() (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="session_pool.html#SessionPool.timeout">timeout (SessionPool attribute)</a>
+  </dt>
+
+      <dd><dl>
+        
+  <dt><a href="subscription.html#Subscription.timeout">(Subscription attribute)</a>
+  </dt>
+
+      </dl></dd>
+      
+  <dt><a href="module.html#cx_Oracle.TIMESTAMP">TIMESTAMP (in module cx_Oracle)</a>
+  </dt>
+
+  </dl></td>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="module.html#cx_Oracle.Timestamp">Timestamp() (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.TimestampFromTicks">TimestampFromTicks() (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="connection.html#Connection.tnsentry">tnsentry (Connection attribute)</a>
+  </dt>
+
+      <dd><dl>
+        
+  <dt><a href="session_pool.html#SessionPool.tnsentry">(SessionPool attribute)</a>
+  </dt>
+
+      </dl></dd>
+      
+  <dt><a href="lob.html#LOB.trim">trim() (LOB method)</a>
+  </dt>
+
+      
+  <dt><a href="subscription.html#Message.type">type (Message attribute)</a>
+  </dt>
+
+  </dl></td>
+</tr></table>
+
+<h2 id="U">U</h2>
+<table style="width: 100%" class="indextable genindextable"><tr>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="module.html#cx_Oracle.UCBTYPE_ENTRY">UCBTYPE_ENTRY (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.UCBTYPE_EXIT">UCBTYPE_EXIT (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="module.html#cx_Oracle.UCBTYPE_REPLACE">UCBTYPE_REPLACE (in module cx_Oracle)</a>
+  </dt>
+
+  </dl></td>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="module.html#cx_Oracle.UNICODE">UNICODE (in module cx_Oracle)</a>
+  </dt>
+
+      
+  <dt><a href="connection.html#Connection.unregister">unregister() (Connection method)</a>
+  </dt>
+
+      
+  <dt><a href="connection.html#Connection.username">username (Connection attribute)</a>
+  </dt>
+
+      <dd><dl>
+        
+  <dt><a href="session_pool.html#SessionPool.username">(SessionPool attribute)</a>
+  </dt>
+
+      </dl></dd>
+  </dl></td>
+</tr></table>
+
+<h2 id="V">V</h2>
+<table style="width: 100%" class="indextable genindextable"><tr>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="cursor.html#Cursor.var">var() (Cursor method)</a>
+  </dt>
+
+  </dl></td>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="connection.html#Connection.version">version (Connection attribute)</a>
+  </dt>
+
+      <dd><dl>
+        
+  <dt><a href="module.html#cx_Oracle.version">(in module cx_Oracle)</a>
+  </dt>
+
+      </dl></dd>
+  </dl></td>
+</tr></table>
+
+<h2 id="W">W</h2>
+<table style="width: 100%" class="indextable genindextable"><tr>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="module.html#cx_Oracle.Warning">Warning</a>
+  </dt>
+
+  </dl></td>
+  <td style="width: 33%" valign="top"><dl>
+      
+  <dt><a href="lob.html#LOB.write">write() (LOB method)</a>
+  </dt>
+
+  </dl></td>
+</tr></table>
+
+
+
+          </div>
+        </div>
+      </div>
+      <div class="sphinxsidebar">
+        <div class="sphinxsidebarwrapper">
+
+   
+
+<div id="searchbox" style="display: none">
+  <h3>Quick search</h3>
+    <form class="search" action="search.html" method="get">
+      <input type="text" name="q" />
+      <input type="submit" value="Go" />
+      <input type="hidden" name="check_keywords" value="yes" />
+      <input type="hidden" name="area" value="default" />
+    </form>
+    <p class="searchtip" style="font-size: 90%">
+    Enter search terms or a module, class or function name.
+    </p>
+</div>
+<script type="text/javascript">$('#searchbox').show(0);</script>
+        </div>
+      </div>
+      <div class="clearer"></div>
+    </div>
+    <div class="related">
+      <h3>Navigation</h3>
+      <ul>
+        <li class="right" style="margin-right: 10px">
+          <a href="#" title="General Index"
+             >index</a></li>
+        <li class="right" >
+          <a href="py-modindex.html" title="Python Module Index"
+             >modules</a> |</li>
+        <li><a href="index.html">cx_Oracle 5.1.2 documentation</a> &raquo;</li> 
+      </ul>
+    </div>
+    <div class="footer">
+        &copy; Copyright 2012, Anthony Tuininga.
+      Last updated on Jul 02, 2012.
+      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
+    </div>
+  </body>
+</html>
\ No newline at end of file
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/html/index.html b/desktop/core/ext-py/cx_Oracle-5.1.2/html/index.html
new file mode 100644
index 0000000..1b6806d
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/html/index.html
@@ -0,0 +1,162 @@
+
+
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
+  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+
+
+<html xmlns="http://www.w3.org/1999/xhtml">
+  <head>
+    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
+    
+    <title>cx_Oracle &mdash; cx_Oracle 5.1.2 documentation</title>
+    
+    <link rel="stylesheet" href="_static/default.css" type="text/css" />
+    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
+    
+    <script type="text/javascript">
+      var DOCUMENTATION_OPTIONS = {
+        URL_ROOT:    '',
+        VERSION:     '5.1.2',
+        COLLAPSE_INDEX: false,
+        FILE_SUFFIX: '.html',
+        HAS_SOURCE:  false
+      };
+    </script>
+    <script type="text/javascript" src="_static/jquery.js"></script>
+    <script type="text/javascript" src="_static/underscore.js"></script>
+    <script type="text/javascript" src="_static/doctools.js"></script>
+    <link rel="top" title="cx_Oracle 5.1.2 documentation" href="#" />
+    <link rel="next" title="Module Interface" href="module.html" /> 
+  </head>
+  <body>
+    <div class="related">
+      <h3>Navigation</h3>
+      <ul>
+        <li class="right" style="margin-right: 10px">
+          <a href="genindex.html" title="General Index"
+             accesskey="I">index</a></li>
+        <li class="right" >
+          <a href="py-modindex.html" title="Python Module Index"
+             >modules</a> |</li>
+        <li class="right" >
+          <a href="module.html" title="Module Interface"
+             accesskey="N">next</a> |</li>
+        <li><a href="#">cx_Oracle 5.1.2 documentation</a> &raquo;</li> 
+      </ul>
+    </div>  
+
+    <div class="document">
+      <div class="documentwrapper">
+        <div class="bodywrapper">
+          <div class="body">
+            
+  <div class="section" id="cx-oracle">
+<h1>cx_Oracle<a class="headerlink" href="#cx-oracle" title="Permalink to this headline"></a></h1>
+<table class="docutils field-list" frame="void" rules="none">
+<col class="field-name" />
+<col class="field-body" />
+<tbody valign="top">
+<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">Anthony Tuininga</td>
+</tr>
+<tr class="field-even field"><th class="field-name">Date:</th><td class="field-body">July 02, 2012</td>
+</tr>
+</tbody>
+</table>
+</div>
+<div class="section" id="front-matter">
+<span id="front"></span><h1>Front Matter<a class="headerlink" href="#front-matter" title="Permalink to this headline"></a></h1>
+<p>Copyright  2007-2012 Anthony Tuininga. All rights reserved.</p>
+<p>Copyright  2001-2007 Computronix. All rights reserved.</p>
+<p>See <a class="reference internal" href="license.html#license"><em>License</em></a> for complete license and permissions information.</p>
+<div class="topic">
+<p class="topic-title first">Abstract</p>
+<p>cx_Oracle is a Python extension module that allows access to Oracle and
+conforms to the Python database API 2.0 specifications with a few
+exceptions. See <a class="reference external" href="http://www.python.org/topics/database/DatabaseAPI-2.0.html">http://www.python.org/topics/database/DatabaseAPI-2.0.html</a>
+for more information on the Python database API specification.</p>
+</div>
+<p>Contents:</p>
+<div class="toctree-wrapper compound">
+<ul>
+<li class="toctree-l1"><a class="reference internal" href="module.html">Module Interface</a><ul>
+<li class="toctree-l2"><a class="reference internal" href="module.html#constants">Constants</a></li>
+<li class="toctree-l2"><a class="reference internal" href="module.html#types">Types</a></li>
+<li class="toctree-l2"><a class="reference internal" href="module.html#exceptions">Exceptions</a></li>
+<li class="toctree-l2"><a class="reference internal" href="module.html#exception-handling">Exception handling</a></li>
+</ul>
+</li>
+<li class="toctree-l1"><a class="reference internal" href="connection.html">Connection Object</a></li>
+<li class="toctree-l1"><a class="reference internal" href="cursor.html">Cursor Object</a></li>
+<li class="toctree-l1"><a class="reference internal" href="variable.html">Variable Objects</a></li>
+<li class="toctree-l1"><a class="reference internal" href="session_pool.html">SessionPool Object</a></li>
+<li class="toctree-l1"><a class="reference internal" href="subscription.html">Subscription Object</a><ul>
+<li class="toctree-l2"><a class="reference internal" href="subscription.html#message-objects">Message Objects</a></li>
+<li class="toctree-l2"><a class="reference internal" href="subscription.html#message-table-objects">Message Table Objects</a></li>
+<li class="toctree-l2"><a class="reference internal" href="subscription.html#message-row-objects">Message Row Objects</a></li>
+</ul>
+</li>
+<li class="toctree-l1"><a class="reference internal" href="lob.html">LOB Objects</a></li>
+<li class="toctree-l1"><a class="reference internal" href="license.html">License</a></li>
+</ul>
+</div>
+<ul class="simple">
+<li><a class="reference internal" href="genindex.html"><em>Index</em></a></li>
+</ul>
+</div>
+
+
+          </div>
+        </div>
+      </div>
+      <div class="sphinxsidebar">
+        <div class="sphinxsidebarwrapper">
+  <h3><a href="#">Table Of Contents</a></h3>
+  <ul>
+<li><a class="reference internal" href="#">cx_Oracle</a></li>
+<li><a class="reference internal" href="#front-matter">Front Matter</a><ul>
+</ul>
+</li>
+</ul>
+
+  <h4>Next topic</h4>
+  <p class="topless"><a href="module.html"
+                        title="next chapter">Module Interface</a></p>
+<div id="searchbox" style="display: none">
+  <h3>Quick search</h3>
+    <form class="search" action="search.html" method="get">
+      <input type="text" name="q" />
+      <input type="submit" value="Go" />
+      <input type="hidden" name="check_keywords" value="yes" />
+      <input type="hidden" name="area" value="default" />
+    </form>
+    <p class="searchtip" style="font-size: 90%">
+    Enter search terms or a module, class or function name.
+    </p>
+</div>
+<script type="text/javascript">$('#searchbox').show(0);</script>
+        </div>
+      </div>
+      <div class="clearer"></div>
+    </div>
+    <div class="related">
+      <h3>Navigation</h3>
+      <ul>
+        <li class="right" style="margin-right: 10px">
+          <a href="genindex.html" title="General Index"
+             >index</a></li>
+        <li class="right" >
+          <a href="py-modindex.html" title="Python Module Index"
+             >modules</a> |</li>
+        <li class="right" >
+          <a href="module.html" title="Module Interface"
+             >next</a> |</li>
+        <li><a href="#">cx_Oracle 5.1.2 documentation</a> &raquo;</li> 
+      </ul>
+    </div>
+    <div class="footer">
+        &copy; Copyright 2012, Anthony Tuininga.
+      Last updated on Jul 02, 2012.
+      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
+    </div>
+  </body>
+</html>
\ No newline at end of file
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/html/license.html b/desktop/core/ext-py/cx_Oracle-5.1.2/html/license.html
new file mode 100644
index 0000000..35976da
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/html/license.html
@@ -0,0 +1,131 @@
+
+
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
+  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+
+
+<html xmlns="http://www.w3.org/1999/xhtml">
+  <head>
+    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
+    
+    <title>License &mdash; cx_Oracle 5.1.2 documentation</title>
+    
+    <link rel="stylesheet" href="_static/default.css" type="text/css" />
+    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
+    
+    <script type="text/javascript">
+      var DOCUMENTATION_OPTIONS = {
+        URL_ROOT:    '',
+        VERSION:     '5.1.2',
+        COLLAPSE_INDEX: false,
+        FILE_SUFFIX: '.html',
+        HAS_SOURCE:  false
+      };
+    </script>
+    <script type="text/javascript" src="_static/jquery.js"></script>
+    <script type="text/javascript" src="_static/underscore.js"></script>
+    <script type="text/javascript" src="_static/doctools.js"></script>
+    <link rel="top" title="cx_Oracle 5.1.2 documentation" href="index.html" />
+    <link rel="prev" title="LOB Objects" href="lob.html" /> 
+  </head>
+  <body>
+    <div class="related">
+      <h3>Navigation</h3>
+      <ul>
+        <li class="right" style="margin-right: 10px">
+          <a href="genindex.html" title="General Index"
+             accesskey="I">index</a></li>
+        <li class="right" >
+          <a href="py-modindex.html" title="Python Module Index"
+             >modules</a> |</li>
+        <li class="right" >
+          <a href="lob.html" title="LOB Objects"
+             accesskey="P">previous</a> |</li>
+        <li><a href="index.html">cx_Oracle 5.1.2 documentation</a> &raquo;</li> 
+      </ul>
+    </div>  
+
+    <div class="document">
+      <div class="documentwrapper">
+        <div class="bodywrapper">
+          <div class="body">
+            
+  <div class="section" id="license">
+<span id="id1"></span><h1>License<a class="headerlink" href="#license" title="Permalink to this headline"></a></h1>
+<p class="centered">
+<strong><strong>LICENSE AGREEMENT FOR CX_ORACLE</strong></strong></p><p>Copyright  2007-2012, Anthony Tuininga. All rights reserved.</p>
+<p>Copyright  2001-2007, Computronix (Canada) Ltd., Edmonton, Alberta,
+Canada. All rights reserved.</p>
+<p>Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:</p>
+<ol class="arabic simple">
+<li>Redistributions of source code must retain the above copyright notice, this
+list of conditions, and the disclaimer that follows.</li>
+<li>Redistributions in binary form must reproduce the above copyright notice,
+this list of conditions, and the following disclaimer in the documentation
+and/or other materials provided with the distribution.</li>
+<li>Neither the names of the copyright holders nor the names of any contributors
+may be used to endorse or promote products derived from this software without
+specific prior written permission.</li>
+</ol>
+<p>DISCLAIMER: THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*AS IS* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
+<p>Computronix  is a registered trademark of Computronix (Canada) Ltd.</p>
+</div>
+
+
+          </div>
+        </div>
+      </div>
+      <div class="sphinxsidebar">
+        <div class="sphinxsidebarwrapper">
+  <h4>Previous topic</h4>
+  <p class="topless"><a href="lob.html"
+                        title="previous chapter">LOB Objects</a></p>
+<div id="searchbox" style="display: none">
+  <h3>Quick search</h3>
+    <form class="search" action="search.html" method="get">
+      <input type="text" name="q" />
+      <input type="submit" value="Go" />
+      <input type="hidden" name="check_keywords" value="yes" />
+      <input type="hidden" name="area" value="default" />
+    </form>
+    <p class="searchtip" style="font-size: 90%">
+    Enter search terms or a module, class or function name.
+    </p>
+</div>
+<script type="text/javascript">$('#searchbox').show(0);</script>
+        </div>
+      </div>
+      <div class="clearer"></div>
+    </div>
+    <div class="related">
+      <h3>Navigation</h3>
+      <ul>
+        <li class="right" style="margin-right: 10px">
+          <a href="genindex.html" title="General Index"
+             >index</a></li>
+        <li class="right" >
+          <a href="py-modindex.html" title="Python Module Index"
+             >modules</a> |</li>
+        <li class="right" >
+          <a href="lob.html" title="LOB Objects"
+             >previous</a> |</li>
+        <li><a href="index.html">cx_Oracle 5.1.2 documentation</a> &raquo;</li> 
+      </ul>
+    </div>
+    <div class="footer">
+        &copy; Copyright 2012, Anthony Tuininga.
+      Last updated on Jul 02, 2012.
+      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
+    </div>
+  </body>
+</html>
\ No newline at end of file
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/html/lob.html b/desktop/core/ext-py/cx_Oracle-5.1.2/html/lob.html
new file mode 100644
index 0000000..e676ce6
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/html/lob.html
@@ -0,0 +1,202 @@
+
+
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
+  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+
+
+<html xmlns="http://www.w3.org/1999/xhtml">
+  <head>
+    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
+    
+    <title>LOB Objects &mdash; cx_Oracle 5.1.2 documentation</title>
+    
+    <link rel="stylesheet" href="_static/default.css" type="text/css" />
+    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
+    
+    <script type="text/javascript">
+      var DOCUMENTATION_OPTIONS = {
+        URL_ROOT:    '',
+        VERSION:     '5.1.2',
+        COLLAPSE_INDEX: false,
+        FILE_SUFFIX: '.html',
+        HAS_SOURCE:  false
+      };
+    </script>
+    <script type="text/javascript" src="_static/jquery.js"></script>
+    <script type="text/javascript" src="_static/underscore.js"></script>
+    <script type="text/javascript" src="_static/doctools.js"></script>
+    <link rel="top" title="cx_Oracle 5.1.2 documentation" href="index.html" />
+    <link rel="next" title="License" href="license.html" />
+    <link rel="prev" title="Subscription Object" href="subscription.html" /> 
+  </head>
+  <body>
+    <div class="related">
+      <h3>Navigation</h3>
+      <ul>
+        <li class="right" style="margin-right: 10px">
+          <a href="genindex.html" title="General Index"
+             accesskey="I">index</a></li>
+        <li class="right" >
+          <a href="py-modindex.html" title="Python Module Index"
+             >modules</a> |</li>
+        <li class="right" >
+          <a href="license.html" title="License"
+             accesskey="N">next</a> |</li>
+        <li class="right" >
+          <a href="subscription.html" title="Subscription Object"
+             accesskey="P">previous</a> |</li>
+        <li><a href="index.html">cx_Oracle 5.1.2 documentation</a> &raquo;</li> 
+      </ul>
+    </div>  
+
+    <div class="document">
+      <div class="documentwrapper">
+        <div class="bodywrapper">
+          <div class="body">
+            
+  <div class="section" id="lob-objects">
+<span id="lobobj"></span><h1>LOB Objects<a class="headerlink" href="#lob-objects" title="Permalink to this headline"></a></h1>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This object is an extension the DB API. It is returned whenever Oracle
+<tt class="xref py py-data docutils literal"><span class="pre">CLOB</span></tt>, <tt class="xref py py-data docutils literal"><span class="pre">BLOB</span></tt> and <tt class="xref py py-data docutils literal"><span class="pre">BFILE</span></tt> columns are fetched.</p>
+</div>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">Internally, Oracle uses LOB locators which are allocated based on the
+cursor array size. Thus, it is important that the data in the LOB object be
+manipulated before another internal fetch takes place. The safest way to do
+this is to use the cursor as an iterator. In particular, do not use the
+fetchall() method. The exception &#8220;LOB variable no longer valid after
+subsequent fetch&#8221; will be raised if an attempt to access a LOB variable
+after a subsequent fetch is detected.</p>
+</div>
+<dl class="method">
+<dt id="LOB.close">
+<tt class="descclassname">LOB.</tt><tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#LOB.close" title="Permalink to this definition"></a></dt>
+<dd><p>Close the <tt class="xref py py-data docutils literal"><span class="pre">LOB</span></tt>. Call this when writing is completed so that the
+indexes associated with the LOB can be updated.</p>
+</dd></dl>
+
+<dl class="method">
+<dt id="LOB.fileexists">
+<tt class="descclassname">LOB.</tt><tt class="descname">fileexists</tt><big>(</big><big>)</big><a class="headerlink" href="#LOB.fileexists" title="Permalink to this definition"></a></dt>
+<dd><p>Return a boolean indicating if the file referenced by the <tt class="xref py py-data docutils literal"><span class="pre">BFILE</span></tt>
+type LOB exists.</p>
+</dd></dl>
+
+<dl class="method">
+<dt id="LOB.getchunksize">
+<tt class="descclassname">LOB.</tt><tt class="descname">getchunksize</tt><big>(</big><big>)</big><a class="headerlink" href="#LOB.getchunksize" title="Permalink to this definition"></a></dt>
+<dd><p>Return the chunk size for the internal LOB. Reading and writing to the LOB
+in chunks of multiples of this size will improve performance.</p>
+</dd></dl>
+
+<dl class="method">
+<dt id="LOB.getfilename">
+<tt class="descclassname">LOB.</tt><tt class="descname">getfilename</tt><big>(</big><big>)</big><a class="headerlink" href="#LOB.getfilename" title="Permalink to this definition"></a></dt>
+<dd><p>Return a two-tuple consisting of the directory alias and file name for a
+<tt class="xref py py-data docutils literal"><span class="pre">BFILE</span></tt> type LOB.</p>
+</dd></dl>
+
+<dl class="method">
+<dt id="LOB.isopen">
+<tt class="descclassname">LOB.</tt><tt class="descname">isopen</tt><big>(</big><big>)</big><a class="headerlink" href="#LOB.isopen" title="Permalink to this definition"></a></dt>
+<dd><p>Return a boolean indicating if the LOB is opened.</p>
+</dd></dl>
+
+<dl class="method">
+<dt id="LOB.open">
+<tt class="descclassname">LOB.</tt><tt class="descname">open</tt><big>(</big><big>)</big><a class="headerlink" href="#LOB.open" title="Permalink to this definition"></a></dt>
+<dd><p>Open the LOB for writing. This will improve performance when writing to a
+LOB in chunks and there are functional or extensible indexes associated with
+the LOB.</p>
+</dd></dl>
+
+<dl class="method">
+<dt id="LOB.read">
+<tt class="descclassname">LOB.</tt><tt class="descname">read</tt><big>(</big><span class="optional">[</span><em>offset=1</em><span class="optional">[</span>, <em>amount</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#LOB.read" title="Permalink to this definition"></a></dt>
+<dd><p>Return a portion (or all) of the data in the LOB object.</p>
+</dd></dl>
+
+<dl class="method">
+<dt id="LOB.setfilename">
+<tt class="descclassname">LOB.</tt><tt class="descname">setfilename</tt><big>(</big><em>dirAlias</em>, <em>name</em><big>)</big><a class="headerlink" href="#LOB.setfilename" title="Permalink to this definition"></a></dt>
+<dd><p>Set the directory alias and name of the <tt class="xref py py-data docutils literal"><span class="pre">BFILE</span></tt> type LOB.</p>
+</dd></dl>
+
+<dl class="method">
+<dt id="LOB.size">
+<tt class="descclassname">LOB.</tt><tt class="descname">size</tt><big>(</big><big>)</big><a class="headerlink" href="#LOB.size" title="Permalink to this definition"></a></dt>
+<dd><p>Returns the size of the data in the LOB object.</p>
+</dd></dl>
+
+<dl class="method">
+<dt id="LOB.trim">
+<tt class="descclassname">LOB.</tt><tt class="descname">trim</tt><big>(</big><span class="optional">[</span><em>newSize=0</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#LOB.trim" title="Permalink to this definition"></a></dt>
+<dd><p>Trim the LOB to the new size.</p>
+</dd></dl>
+
+<dl class="method">
+<dt id="LOB.write">
+<tt class="descclassname">LOB.</tt><tt class="descname">write</tt><big>(</big><em>data</em><span class="optional">[</span>, <em>offset=1</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#LOB.write" title="Permalink to this definition"></a></dt>
+<dd><p>Write the data to the LOB object at the given offset. Note that if you want
+to make the LOB value smaller, you must use the trim() function.</p>
+</dd></dl>
+
+</div>
+
+
+          </div>
+        </div>
+      </div>
+      <div class="sphinxsidebar">
+        <div class="sphinxsidebarwrapper">
+  <h4>Previous topic</h4>
+  <p class="topless"><a href="subscription.html"
+                        title="previous chapter">Subscription Object</a></p>
+  <h4>Next topic</h4>
+  <p class="topless"><a href="license.html"
+                        title="next chapter">License</a></p>
+<div id="searchbox" style="display: none">
+  <h3>Quick search</h3>
+    <form class="search" action="search.html" method="get">
+      <input type="text" name="q" />
+      <input type="submit" value="Go" />
+      <input type="hidden" name="check_keywords" value="yes" />
+      <input type="hidden" name="area" value="default" />
+    </form>
+    <p class="searchtip" style="font-size: 90%">
+    Enter search terms or a module, class or function name.
+    </p>
+</div>
+<script type="text/javascript">$('#searchbox').show(0);</script>
+        </div>
+      </div>
+      <div class="clearer"></div>
+    </div>
+    <div class="related">
+      <h3>Navigation</h3>
+      <ul>
+        <li class="right" style="margin-right: 10px">
+          <a href="genindex.html" title="General Index"
+             >index</a></li>
+        <li class="right" >
+          <a href="py-modindex.html" title="Python Module Index"
+             >modules</a> |</li>
+        <li class="right" >
+          <a href="license.html" title="License"
+             >next</a> |</li>
+        <li class="right" >
+          <a href="subscription.html" title="Subscription Object"
+             >previous</a> |</li>
+        <li><a href="index.html">cx_Oracle 5.1.2 documentation</a> &raquo;</li> 
+      </ul>
+    </div>
+    <div class="footer">
+        &copy; Copyright 2012, Anthony Tuininga.
+      Last updated on Jul 02, 2012.
+      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
+    </div>
+  </body>
+</html>
\ No newline at end of file
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/html/module.html b/desktop/core/ext-py/cx_Oracle-5.1.2/html/module.html
new file mode 100644
index 0000000..53ad15b
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/html/module.html
@@ -0,0 +1,1044 @@
+
+
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
+  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+
+
+<html xmlns="http://www.w3.org/1999/xhtml">
+  <head>
+    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
+    
+    <title>Module Interface &mdash; cx_Oracle 5.1.2 documentation</title>
+    
+    <link rel="stylesheet" href="_static/default.css" type="text/css" />
+    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
+    
+    <script type="text/javascript">
+      var DOCUMENTATION_OPTIONS = {
+        URL_ROOT:    '',
+        VERSION:     '5.1.2',
+        COLLAPSE_INDEX: false,
+        FILE_SUFFIX: '.html',
+        HAS_SOURCE:  false
+      };
+    </script>
+    <script type="text/javascript" src="_static/jquery.js"></script>
+    <script type="text/javascript" src="_static/underscore.js"></script>
+    <script type="text/javascript" src="_static/doctools.js"></script>
+    <link rel="top" title="cx_Oracle 5.1.2 documentation" href="index.html" />
+    <link rel="next" title="Connection Object" href="connection.html" />
+    <link rel="prev" title="cx_Oracle" href="index.html" /> 
+  </head>
+  <body>
+    <div class="related">
+      <h3>Navigation</h3>
+      <ul>
+        <li class="right" style="margin-right: 10px">
+          <a href="genindex.html" title="General Index"
+             accesskey="I">index</a></li>
+        <li class="right" >
+          <a href="py-modindex.html" title="Python Module Index"
+             >modules</a> |</li>
+        <li class="right" >
+          <a href="connection.html" title="Connection Object"
+             accesskey="N">next</a> |</li>
+        <li class="right" >
+          <a href="index.html" title="cx_Oracle"
+             accesskey="P">previous</a> |</li>
+        <li><a href="index.html">cx_Oracle 5.1.2 documentation</a> &raquo;</li> 
+      </ul>
+    </div>  
+
+    <div class="document">
+      <div class="documentwrapper">
+        <div class="bodywrapper">
+          <div class="body">
+            
+  <span class="target" id="module-cx_Oracle"></span><div class="section" id="module-interface">
+<span id="module"></span><h1>Module Interface<a class="headerlink" href="#module-interface" title="Permalink to this headline"></a></h1>
+<dl class="function">
+<dt id="cx_Oracle.Binary">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">Binary</tt><big>(</big><em>string</em><big>)</big><a class="headerlink" href="#cx_Oracle.Binary" title="Permalink to this definition"></a></dt>
+<dd><p>Construct an object holding a binary (long) string value.</p>
+</dd></dl>
+
+<dl class="function">
+<dt id="cx_Oracle.clientversion">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">clientversion</tt><big>(</big><big>)</big><a class="headerlink" href="#cx_Oracle.clientversion" title="Permalink to this definition"></a></dt>
+<dd><p>Return the version of the client library being used as a 5-tuple. The five
+values are the major version, minor version, update number, patch number and
+port update number.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This method is an extension to the DB API definition and is only
+available in Oracle 10g Release 2 and higher.</p>
+</div>
+</dd></dl>
+
+<dl class="function">
+<dt id="cx_Oracle.Connection">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">Connection</tt><big>(</big><span class="optional">[</span><em>user</em>, <em>password</em>, <em>dsn</em>, <em>mode</em>, <em>handle</em>, <em>pool</em>, <em>threaded</em>, <em>twophase</em>, <em>events</em>, <em>cclass</em>, <em>purity</em>, <em>newpassword</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#cx_Oracle.Connection" title="Permalink to this definition"></a></dt>
+<dt id="cx_Oracle.connect">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">connect</tt><big>(</big><span class="optional">[</span><em>user</em>, <em>password</em>, <em>dsn</em>, <em>mode</em>, <em>handle</em>, <em>pool</em>, <em>threaded</em>, <em>twophase</em>, <em>events</em>, <em>cclass</em>, <em>purity</em>, <em>newpassword</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#cx_Oracle.connect" title="Permalink to this definition"></a></dt>
+<dd><p>Constructor for creating a connection to the database. Return a Connection
+object (<a class="reference internal" href="connection.html#connobj"><em>Connection Object</em></a>). All arguments are optional and can be specified as
+keyword parameters.</p>
+<p>The dsn (data source name) is the TNS entry (from the Oracle names server or
+tnsnames.ora file) or is a string like the one returned from makedsn(). If
+only one parameter is passed, a connect string is assumed which is to be of
+the format <tt class="docutils literal"><span class="pre">user/password&#64;dsn</span></tt>, the same format accepted by Oracle
+applications such as SQL*Plus.</p>
+<p>If the mode is specified, it must be one of <a class="reference internal" href="#cx_Oracle.SYSDBA" title="cx_Oracle.SYSDBA"><tt class="xref py py-data docutils literal"><span class="pre">SYSDBA</span></tt></a> or
+<a class="reference internal" href="#cx_Oracle.SYSOPER" title="cx_Oracle.SYSOPER"><tt class="xref py py-data docutils literal"><span class="pre">SYSOPER</span></tt></a> which are defined at the module level; otherwise it defaults
+to the normal mode of connecting.</p>
+<p>If the handle is specified, it must be of type OCISvcCtx* and is only of
+use when embedding Python in an application (like PowerBuilder) which has
+already made the connection.</p>
+<p>The pool argument is expected to be a session pool object (<a class="reference internal" href="session_pool.html#sesspool"><em>SessionPool Object</em></a>)
+and the use of this argument is the equivalent of calling pool.acquire().</p>
+<p>The threaded argument is expected to be a boolean expression which
+indicates whether or not Oracle should use the mode OCI_THREADED to wrap
+accesses to connections with a mutex. Doing so in single threaded
+applications imposes a performance penalty of about 10-15% which is why the
+default is False.</p>
+<p>The twophase argument is expected to be a boolean expression which
+indicates whether or not the attributes should be set on the connection
+object to allow for two phase commit. The default for this value is also
+False because of bugs in Oracle prior to Oracle 10g.</p>
+<p>The events argument is expected to be a boolean expression which indicates
+whether or not to initialize Oracle in events mode (only available in Oracle
+11g and higher).</p>
+<p>The cclass argument is expected to be a string and defines the connection
+class for database resident connection pooling (DRCP) in Oracle 11g and
+higher.</p>
+<p>The purity argument is expected to be one of <a class="reference internal" href="#cx_Oracle.ATTR_PURITY_NEW" title="cx_Oracle.ATTR_PURITY_NEW"><tt class="xref py py-data docutils literal"><span class="pre">ATTR_PURITY_NEW</span></tt></a> (the
+session must be new without any prior session state),
+<a class="reference internal" href="#cx_Oracle.ATTR_PURITY_SELF" title="cx_Oracle.ATTR_PURITY_SELF"><tt class="xref py py-data docutils literal"><span class="pre">ATTR_PURITY_SELF</span></tt></a> (the session may have been used before) or
+<a class="reference internal" href="#cx_Oracle.ATTR_PURITY_DEFAULT" title="cx_Oracle.ATTR_PURITY_DEFAULT"><tt class="xref py py-data docutils literal"><span class="pre">ATTR_PURITY_DEFAULT</span></tt></a> (the default behavior which is defined by Oracle
+in its documentation). This argument is only relevant in Oracle 11g and
+higher.</p>
+<p>The newpassword argument is expected to be a string if specified and sets
+the password for the logon during the connection process.</p>
+</dd></dl>
+
+<dl class="function">
+<dt id="cx_Oracle.Cursor">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">Cursor</tt><big>(</big><em>connection</em><big>)</big><a class="headerlink" href="#cx_Oracle.Cursor" title="Permalink to this definition"></a></dt>
+<dd><p>Constructor for creating a cursor.  Return a new Cursor object
+(<a class="reference internal" href="cursor.html#cursorobj"><em>Cursor Object</em></a>) using the connection.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This method is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="function">
+<dt id="cx_Oracle.Date">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">Date</tt><big>(</big><em>year</em>, <em>month</em>, <em>day</em><big>)</big><a class="headerlink" href="#cx_Oracle.Date" title="Permalink to this definition"></a></dt>
+<dd><p>Construct an object holding a date value.</p>
+</dd></dl>
+
+<dl class="function">
+<dt id="cx_Oracle.DateFromTicks">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">DateFromTicks</tt><big>(</big><em>ticks</em><big>)</big><a class="headerlink" href="#cx_Oracle.DateFromTicks" title="Permalink to this definition"></a></dt>
+<dd><p>Construct an object holding a date value from the given ticks value (number
+of seconds since the epoch; see the documentation of the standard Python
+time module for details).</p>
+</dd></dl>
+
+<dl class="function">
+<dt id="cx_Oracle.makedsn">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">makedsn</tt><big>(</big><em>host</em>, <em>port</em>, <em>sid</em><span class="optional">[</span>, <em>service_name</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#cx_Oracle.makedsn" title="Permalink to this definition"></a></dt>
+<dd><p>Return a string suitable for use as the dsn for the connect() method. This
+string is identical to the strings that are defined by the Oracle names
+server or defined in the tnsnames.ora file. If you wish to use the service
+name instead of the sid, do not include a value for the parameter sid and
+use the keyword parameter service_name instead.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This method is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="function">
+<dt id="cx_Oracle.SessionPool">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">SessionPool</tt><big>(</big><em>user</em>, <em>password</em>, <em>database</em>, <em>min</em>, <em>max</em>, <em>increment</em><span class="optional">[</span>, <em>connectiontype</em>, <em>threaded</em>, <em>getmode=cx_Oracle.SPOOL_ATTRVAL_NOWAIT</em>, <em>homogeneous=True</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#cx_Oracle.SessionPool" title="Permalink to this definition"></a></dt>
+<dd><p>Create a session pool (see Oracle 9i documentation for more information) and
+return a session pool object (<a class="reference internal" href="session_pool.html#sesspool"><em>SessionPool Object</em></a>). This allows for very fast
+connections to the database and is of primary use in a server where the same
+connection is being made multiple times in rapid succession (a web server,
+for example). If the connection type is specified, all calls to acquire()
+will create connection objects of that type, rather than the base type
+defined at the module level. The threaded attribute is expected to be a
+boolean expression which indicates whether or not Oracle should use the mode
+OCI_THREADED to wrap accesses to connections with a mutex. Doing so in
+single threaded applications imposes a performance penalty of about 10-15%
+which is why the default is False.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This method is an extension to the DB API definition and is only
+available in Oracle 9i.</p>
+</div>
+</dd></dl>
+
+<dl class="function">
+<dt id="cx_Oracle.Time">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">Time</tt><big>(</big><em>hour</em>, <em>minute</em>, <em>second</em><big>)</big><a class="headerlink" href="#cx_Oracle.Time" title="Permalink to this definition"></a></dt>
+<dd><p>Construct an object holding a time value.</p>
+</dd></dl>
+
+<dl class="function">
+<dt id="cx_Oracle.TimeFromTicks">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">TimeFromTicks</tt><big>(</big><em>ticks</em><big>)</big><a class="headerlink" href="#cx_Oracle.TimeFromTicks" title="Permalink to this definition"></a></dt>
+<dd><p>Construct an object holding a time value from the given ticks value (number
+of seconds since the epoch; see the documentation of the standard Python
+time module for details).</p>
+</dd></dl>
+
+<dl class="function">
+<dt id="cx_Oracle.Timestamp">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">Timestamp</tt><big>(</big><em>year</em>, <em>month</em>, <em>day</em>, <em>hour</em>, <em>minute</em>, <em>second</em><big>)</big><a class="headerlink" href="#cx_Oracle.Timestamp" title="Permalink to this definition"></a></dt>
+<dd><p>Construct an object holding a time stamp value.</p>
+</dd></dl>
+
+<dl class="function">
+<dt id="cx_Oracle.TimestampFromTicks">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">TimestampFromTicks</tt><big>(</big><em>ticks</em><big>)</big><a class="headerlink" href="#cx_Oracle.TimestampFromTicks" title="Permalink to this definition"></a></dt>
+<dd><p>Construct an object holding a time stamp value from the given ticks value
+(number of seconds since the epoch; see the documentation of the standard
+Python time module for details).</p>
+</dd></dl>
+
+<div class="section" id="constants">
+<span id="id1"></span><h2>Constants<a class="headerlink" href="#constants" title="Permalink to this headline"></a></h2>
+<div class="section" id="global">
+<h3>Global<a class="headerlink" href="#global" title="Permalink to this headline"></a></h3>
+<dl class="data">
+<dt id="cx_Oracle.apilevel">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">apilevel</tt><a class="headerlink" href="#cx_Oracle.apilevel" title="Permalink to this definition"></a></dt>
+<dd><p>String constant stating the supported DB API level. Currently &#8216;2.0&#8217;.</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.buildtime">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">buildtime</tt><a class="headerlink" href="#cx_Oracle.buildtime" title="Permalink to this definition"></a></dt>
+<dd><p>String constant stating the time when the binary was built.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This constant is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.paramstyle">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">paramstyle</tt><a class="headerlink" href="#cx_Oracle.paramstyle" title="Permalink to this definition"></a></dt>
+<dd><p>String constant stating the type of parameter marker formatting expected by
+the interface. Currently &#8216;named&#8217; as in &#8216;where name = :name&#8217;.</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.SYSDBA">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">SYSDBA</tt><a class="headerlink" href="#cx_Oracle.SYSDBA" title="Permalink to this definition"></a></dt>
+<dd><p>Value to be passed to the connect() method which indicates that SYSDBA
+access is to be acquired. See the Oracle documentation for more details.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This constant is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.SYSOPER">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">SYSOPER</tt><a class="headerlink" href="#cx_Oracle.SYSOPER" title="Permalink to this definition"></a></dt>
+<dd><p>Value to be passed to the connect() method which indicates that SYSOPER
+access is to be acquired. See the Oracle documentation for more details.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This constant is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.threadsafety">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">threadsafety</tt><a class="headerlink" href="#cx_Oracle.threadsafety" title="Permalink to this definition"></a></dt>
+<dd><p>Integer constant stating the level of thread safety that the interface
+supports.  Currently 2, which means that threads may share the module and
+connections, but not cursors. Sharing means that a thread may use a
+resource without wrapping it using a mutex semaphore to implement resource
+locking.</p>
+<p>Note that in order to make use of multiple threads in a program which
+intends to connect and disconnect in different threads, the threaded
+argument to the Connection constructor must be a true value. See the
+comments on the Connection constructor for more information (<a class="reference internal" href="#module"><em>Module Interface</em></a>).</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.version">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">version</tt><a class="headerlink" href="#cx_Oracle.version" title="Permalink to this definition"></a></dt>
+<dd><p>String constant stating the version of the module. Currently &#8216;5.1.2&#8216;.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This attribute is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+</div>
+<div class="section" id="database-callbacks">
+<h3>Database Callbacks<a class="headerlink" href="#database-callbacks" title="Permalink to this headline"></a></h3>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">These constants are extensions to the DB API definition.</p>
+</div>
+<dl class="data">
+<dt id="cx_Oracle.FNCODE_BINDBYNAME">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">FNCODE_BINDBYNAME</tt><a class="headerlink" href="#cx_Oracle.FNCODE_BINDBYNAME" title="Permalink to this definition"></a></dt>
+<dd><p>This constant is used to register callbacks on the OCIBindByName() function
+of the OCI.</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.FNCODE_BINDBYPOS">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">FNCODE_BINDBYPOS</tt><a class="headerlink" href="#cx_Oracle.FNCODE_BINDBYPOS" title="Permalink to this definition"></a></dt>
+<dd><p>This constant is used to register callbacks on the OCIBindByPos() function
+of the OCI.</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.FNCODE_DEFINEBYPOS">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">FNCODE_DEFINEBYPOS</tt><a class="headerlink" href="#cx_Oracle.FNCODE_DEFINEBYPOS" title="Permalink to this definition"></a></dt>
+<dd><p>This constant is used to register callbacks on the OCIDefineByPos() function
+of the OCI.</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.FNCODE_STMTEXECUTE">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">FNCODE_STMTEXECUTE</tt><a class="headerlink" href="#cx_Oracle.FNCODE_STMTEXECUTE" title="Permalink to this definition"></a></dt>
+<dd><p>This constant is used to register callbacks on the OCIStmtExecute() function
+of the OCI.</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.FNCODE_STMTFETCH">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">FNCODE_STMTFETCH</tt><a class="headerlink" href="#cx_Oracle.FNCODE_STMTFETCH" title="Permalink to this definition"></a></dt>
+<dd><p>This constant is used to register callbacks on the OCIStmtFetch() function
+of the OCI.</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.FNCODE_STMTPREPARE">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">FNCODE_STMTPREPARE</tt><a class="headerlink" href="#cx_Oracle.FNCODE_STMTPREPARE" title="Permalink to this definition"></a></dt>
+<dd><p>This constant is used to register callbacks on the OCIStmtPrepare() function
+of the OCI.</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.UCBTYPE_ENTRY">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">UCBTYPE_ENTRY</tt><a class="headerlink" href="#cx_Oracle.UCBTYPE_ENTRY" title="Permalink to this definition"></a></dt>
+<dd><p>This constant is used to register callbacks on entry to the function of the
+OCI.  In other words, the callback will be called prior to the execution of
+the OCI function.</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.UCBTYPE_EXIT">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">UCBTYPE_EXIT</tt><a class="headerlink" href="#cx_Oracle.UCBTYPE_EXIT" title="Permalink to this definition"></a></dt>
+<dd><p>This constant is used to register callbacks on exit from the function of the
+OCI. In other words, the callback will be called after the execution of the
+OCI function.</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.UCBTYPE_REPLACE">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">UCBTYPE_REPLACE</tt><a class="headerlink" href="#cx_Oracle.UCBTYPE_REPLACE" title="Permalink to this definition"></a></dt>
+<dd><p>This constant is used to register callbacks that completely replace the call
+to the OCI function.</p>
+</dd></dl>
+
+</div>
+<div class="section" id="database-change-notification">
+<h3>Database Change Notification<a class="headerlink" href="#database-change-notification" title="Permalink to this headline"></a></h3>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">These constants are extensions to the DB API definition.</p>
+</div>
+<dl class="data">
+<dt id="cx_Oracle.EVENT_DEREG">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">EVENT_DEREG</tt><a class="headerlink" href="#cx_Oracle.EVENT_DEREG" title="Permalink to this definition"></a></dt>
+<dd><p>This constant is a possible value for the type of a message and indicates
+that the subscription object has been deregistered.</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.EVENT_NONE">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">EVENT_NONE</tt><a class="headerlink" href="#cx_Oracle.EVENT_NONE" title="Permalink to this definition"></a></dt>
+<dd><p>This constant is a possible value for the type of a message and provides no
+additional information about the event.</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.EVENT_OBJCHANGE">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">EVENT_OBJCHANGE</tt><a class="headerlink" href="#cx_Oracle.EVENT_OBJCHANGE" title="Permalink to this definition"></a></dt>
+<dd><p>This constant is a possible value for the type of a message and indicates
+that an object change of some sort has taken place.</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.EVENT_SHUTDOWN">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">EVENT_SHUTDOWN</tt><a class="headerlink" href="#cx_Oracle.EVENT_SHUTDOWN" title="Permalink to this definition"></a></dt>
+<dd><p>This constant is a possible value for the type of a message and indicates
+that the instance is in the process of being shut down.</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.EVENT_SHUTDOWN_ANY">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">EVENT_SHUTDOWN_ANY</tt><a class="headerlink" href="#cx_Oracle.EVENT_SHUTDOWN_ANY" title="Permalink to this definition"></a></dt>
+<dd><p>This constant is a possible value for the type of a message and indicates
+that any instance (when running RAC) is in the process of being shut down.</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.EVENT_STARTUP">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">EVENT_STARTUP</tt><a class="headerlink" href="#cx_Oracle.EVENT_STARTUP" title="Permalink to this definition"></a></dt>
+<dd><p>This constant is a possible value for the type of a message and indicates
+that the instance is in the process of being started up.</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.OPCODE_ALLOPS">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">OPCODE_ALLOPS</tt><a class="headerlink" href="#cx_Oracle.OPCODE_ALLOPS" title="Permalink to this definition"></a></dt>
+<dd><p>This constant is the default value when creating a subscription and
+specifies that messages are to be sent for all operations.</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.OPCODE_ALLROWS">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">OPCODE_ALLROWS</tt><a class="headerlink" href="#cx_Oracle.OPCODE_ALLROWS" title="Permalink to this definition"></a></dt>
+<dd><p>This constant is a possible value for the operation attribute of one of the
+table objects that are part of a message. It specifies that the table has
+been completely invalidated.</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.OPCODE_ALTER">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">OPCODE_ALTER</tt><a class="headerlink" href="#cx_Oracle.OPCODE_ALTER" title="Permalink to this definition"></a></dt>
+<dd><p>This constant is a possible value for the operation attribute of one of the
+table objects that are part of a message. It specifies that the table has
+been altered in some fashion using DDL.</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.OPCODE_DELETE">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">OPCODE_DELETE</tt><a class="headerlink" href="#cx_Oracle.OPCODE_DELETE" title="Permalink to this definition"></a></dt>
+<dd><p>This constant can be used when creating a subscription and specifies that
+messages are to be sent only when data is deleted. It is also a possible
+value for the operation attribute of one of the table objects that are part
+of a message.</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.OPCODE_DROP">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">OPCODE_DROP</tt><a class="headerlink" href="#cx_Oracle.OPCODE_DROP" title="Permalink to this definition"></a></dt>
+<dd><p>This constant is a possible value for the operation attribute of one of the
+table objects that are part of a message. It specifies that the table has
+been dropped.</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.OPCODE_INSERT">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">OPCODE_INSERT</tt><a class="headerlink" href="#cx_Oracle.OPCODE_INSERT" title="Permalink to this definition"></a></dt>
+<dd><p>This constant can be used when creating a subscription and specifies that
+messages are to be sent only when data is inserted. It is also a possible
+value for the operation attribute of one of the table objects that are part
+of a message.</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.OPCODE_UPDATE">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">OPCODE_UPDATE</tt><a class="headerlink" href="#cx_Oracle.OPCODE_UPDATE" title="Permalink to this definition"></a></dt>
+<dd><p>This constant can be used when creating a subscription and specifies that
+messages are to be sent only when data is updated. It is also a possible
+value for the operation attribute of one of the table objects that are part
+of a message.</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.SUBSCR_NAMESPACE_DBCHANGE">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">SUBSCR_NAMESPACE_DBCHANGE</tt><a class="headerlink" href="#cx_Oracle.SUBSCR_NAMESPACE_DBCHANGE" title="Permalink to this definition"></a></dt>
+<dd><p>This constant is the default (and currently only) value for the namespace
+argument when creating a subscription.</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.SUBSCR_PROTO_HTTP">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">SUBSCR_PROTO_HTTP</tt><a class="headerlink" href="#cx_Oracle.SUBSCR_PROTO_HTTP" title="Permalink to this definition"></a></dt>
+<dd><p>This constant is a future possible value for the protocol argument when
+creating a subscription. It specifies that notification will be sent to the
+HTTP URL when a message is generated.</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.SUBSCR_PROTO_MAIL">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">SUBSCR_PROTO_MAIL</tt><a class="headerlink" href="#cx_Oracle.SUBSCR_PROTO_MAIL" title="Permalink to this definition"></a></dt>
+<dd><p>This constant is a future possible value for the protocol argument when
+creating a subscription. It specifies that an e-mail message should be sent
+to the target when a message is generated.</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.SUBSCR_PROTO_OCI">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">SUBSCR_PROTO_OCI</tt><a class="headerlink" href="#cx_Oracle.SUBSCR_PROTO_OCI" title="Permalink to this definition"></a></dt>
+<dd><p>This constant is the default (and currently only valid) value for the
+protocol argument when creating a subscription.</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.SUBSCR_PROTO_SERVER">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">SUBSCR_PROTO_SERVER</tt><a class="headerlink" href="#cx_Oracle.SUBSCR_PROTO_SERVER" title="Permalink to this definition"></a></dt>
+<dd><p>This constant is a future possible value for the protocol argument when
+creating a subscription. It specifies that the database procedure will be
+invoked when a message is generated.</p>
+</dd></dl>
+
+</div>
+<div class="section" id="database-resident-connection-pooling">
+<h3>Database Resident Connection Pooling<a class="headerlink" href="#database-resident-connection-pooling" title="Permalink to this headline"></a></h3>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">These constants are extensions to the DB API definition.</p>
+</div>
+<dl class="data">
+<dt id="cx_Oracle.ATTR_PURITY_DEFAULT">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">ATTR_PURITY_DEFAULT</tt><a class="headerlink" href="#cx_Oracle.ATTR_PURITY_DEFAULT" title="Permalink to this definition"></a></dt>
+<dd><p>This constant is used when using database resident connection pooling (DRCP)
+and specifies that the purity of the session is the default value used by
+Oracle (see Oracle&#8217;s documentation for more information).</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.ATTR_PURITY_NEW">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">ATTR_PURITY_NEW</tt><a class="headerlink" href="#cx_Oracle.ATTR_PURITY_NEW" title="Permalink to this definition"></a></dt>
+<dd><p>This constant is used when using database resident connection pooling (DRCP)
+and specifies that the session acquired from the pool should be new and not
+have any prior session state.</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.ATTR_PURITY_SELF">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">ATTR_PURITY_SELF</tt><a class="headerlink" href="#cx_Oracle.ATTR_PURITY_SELF" title="Permalink to this definition"></a></dt>
+<dd><p>This constant is used when using database resident connection pooling (DRCP)
+and specifies that the session acquired from the pool need not be new and
+may have prior session state.</p>
+</dd></dl>
+
+</div>
+<div class="section" id="database-startup-shutdown">
+<h3>Database Startup/Shutdown<a class="headerlink" href="#database-startup-shutdown" title="Permalink to this headline"></a></h3>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">These constants are extensions to the DB API definition.</p>
+</div>
+<dl class="data">
+<dt id="cx_Oracle.PRELIM_AUTH">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">PRELIM_AUTH</tt><a class="headerlink" href="#cx_Oracle.PRELIM_AUTH" title="Permalink to this definition"></a></dt>
+<dd><p>This constant is used to define the preliminary authentication mode required
+for performing database startup and shutdown.</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.DBSHUTDOWN_ABORT">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">DBSHUTDOWN_ABORT</tt><a class="headerlink" href="#cx_Oracle.DBSHUTDOWN_ABORT" title="Permalink to this definition"></a></dt>
+<dd><p>This constant is used in database shutdown to indicate that the program
+should not wait for current calls to complete or for users to disconnect
+from the database. Use only in unusual circumstances since database recovery
+may be necessary upon next startup.</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.DBSHUTDOWN_FINAL">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">DBSHUTDOWN_FINAL</tt><a class="headerlink" href="#cx_Oracle.DBSHUTDOWN_FINAL" title="Permalink to this definition"></a></dt>
+<dd><p>This constant is used in database shutdown to indicate that the instance can
+be truly halted. This should only be done after the database has been shut
+down in one of the other modes (except abort) and the database has been
+closed and dismounted using the appropriate SQL commands. See the method
+<a class="reference internal" href="connection.html#Connection.shutdown" title="Connection.shutdown"><tt class="xref py py-meth docutils literal"><span class="pre">shutdown()</span></tt></a> in the section on connections
+(<a class="reference internal" href="connection.html#connobj"><em>Connection Object</em></a>).</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.DBSHUTDOWN_IMMEDIATE">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">DBSHUTDOWN_IMMEDIATE</tt><a class="headerlink" href="#cx_Oracle.DBSHUTDOWN_IMMEDIATE" title="Permalink to this definition"></a></dt>
+<dd><p>This constant is used in database shutdown to indicate that all uncommitted
+transactions should be rolled back and any connected users should be
+disconnected.</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.DBSHUTDOWN_TRANSACTIONAL">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">DBSHUTDOWN_TRANSACTIONAL</tt><a class="headerlink" href="#cx_Oracle.DBSHUTDOWN_TRANSACTIONAL" title="Permalink to this definition"></a></dt>
+<dd><p>This constant is used in database shutdown to indicate that further
+connections should be prohibited and no new transactions should be allowed.
+It then waits for active transactions to complete.</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.DBSHUTDOWN_TRANSACTIONAL_LOCAL">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">DBSHUTDOWN_TRANSACTIONAL_LOCAL</tt><a class="headerlink" href="#cx_Oracle.DBSHUTDOWN_TRANSACTIONAL_LOCAL" title="Permalink to this definition"></a></dt>
+<dd><p>This constant is used in database shutdown to indicate that further
+connections should be prohibited and no new transactions should be allowed.
+It then waits for only local active transactions to complete.</p>
+</dd></dl>
+
+</div>
+<div class="section" id="session-pooling">
+<h3>Session Pooling<a class="headerlink" href="#session-pooling" title="Permalink to this headline"></a></h3>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">These constants are extensions to the DB API definition.</p>
+</div>
+<dl class="data">
+<dt id="cx_Oracle.SPOOL_ATTRVAL_FORCEGET">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">SPOOL_ATTRVAL_FORCEGET</tt><a class="headerlink" href="#cx_Oracle.SPOOL_ATTRVAL_FORCEGET" title="Permalink to this definition"></a></dt>
+<dd><p>This constant is used to define the &#8220;get&#8221; mode on session pools and
+indicates that a new connection will be returned if there are no free
+sessions available in the pool.</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.SPOOL_ATTRVAL_NOWAIT">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">SPOOL_ATTRVAL_NOWAIT</tt><a class="headerlink" href="#cx_Oracle.SPOOL_ATTRVAL_NOWAIT" title="Permalink to this definition"></a></dt>
+<dd><p>This constant is used to define the &#8220;get&#8221; mode on session pools and
+indicates that an exception is raised if there are no free sessions
+available in the pool.</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.SPOOL_ATTRVAL_WAIT">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">SPOOL_ATTRVAL_WAIT</tt><a class="headerlink" href="#cx_Oracle.SPOOL_ATTRVAL_WAIT" title="Permalink to this definition"></a></dt>
+<dd><p>This constant is used to define the &#8220;get&#8221; mode on session pools and
+indicates that the acquisition of a connection waits until a session is
+freed if there are no free sessions available in the pool.</p>
+</dd></dl>
+
+</div>
+</div>
+<div class="section" id="types">
+<h2>Types<a class="headerlink" href="#types" title="Permalink to this headline"></a></h2>
+<dl class="data">
+<dt id="cx_Oracle.BINARY">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">BINARY</tt><a class="headerlink" href="#cx_Oracle.BINARY" title="Permalink to this definition"></a></dt>
+<dd><p>This type object is used to describe columns in a database that are binary
+(in Oracle this is RAW columns).</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.BFILE">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">BFILE</tt><a class="headerlink" href="#cx_Oracle.BFILE" title="Permalink to this definition"></a></dt>
+<dd><p>This type object is used to describe columns in a database that are BFILEs.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This type is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.BLOB">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">BLOB</tt><a class="headerlink" href="#cx_Oracle.BLOB" title="Permalink to this definition"></a></dt>
+<dd><p>This type object is used to describe columns in a database that are BLOBs.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This type is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.CLOB">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">CLOB</tt><a class="headerlink" href="#cx_Oracle.CLOB" title="Permalink to this definition"></a></dt>
+<dd><p>This type object is used to describe columns in a database that are CLOBs.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This type is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.CURSOR">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">CURSOR</tt><a class="headerlink" href="#cx_Oracle.CURSOR" title="Permalink to this definition"></a></dt>
+<dd><p>This type object is used to describe columns in a database that are cursors
+(in PL/SQL these are known as ref cursors).</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This type is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.DATETIME">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">DATETIME</tt><a class="headerlink" href="#cx_Oracle.DATETIME" title="Permalink to this definition"></a></dt>
+<dd><p>This type object is used to describe columns in a database that are dates.</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.FIXED_CHAR">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">FIXED_CHAR</tt><a class="headerlink" href="#cx_Oracle.FIXED_CHAR" title="Permalink to this definition"></a></dt>
+<dd><p>This type object is used to describe columns in a database that are fixed
+length strings (in Oracle this is CHAR columns); these behave differently in
+Oracle than varchar2 so they are differentiated here even though the DB API
+does not differentiate them.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This attribute is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.FIXED_UNICODE">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">FIXED_UNICODE</tt><a class="headerlink" href="#cx_Oracle.FIXED_UNICODE" title="Permalink to this definition"></a></dt>
+<dd><p>This type object is used to describe columns in a database that are fixed
+length unicode strings (in Oracle this is NCHAR columns); these behave
+differently in Oracle than nvarchar2 so they are differentiated here even
+though the DB API does not differentiate them.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This type is an extension to the DB API definition and is only available
+in Python 2.x. In Python 3.x these types of columns are returned as
+FIXED_CHAR.</p>
+</div>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.INTERVAL">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">INTERVAL</tt><a class="headerlink" href="#cx_Oracle.INTERVAL" title="Permalink to this definition"></a></dt>
+<dd><p>This type object is used to describe columns in a database that are of type
+interval day to second.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This type is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.LOB">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">LOB</tt><a class="headerlink" href="#cx_Oracle.LOB" title="Permalink to this definition"></a></dt>
+<dd><p>This type object is the Python type of <a class="reference internal" href="#cx_Oracle.BLOB" title="cx_Oracle.BLOB"><tt class="xref py py-data docutils literal"><span class="pre">BLOB</span></tt></a> and <a class="reference internal" href="#cx_Oracle.CLOB" title="cx_Oracle.CLOB"><tt class="xref py py-data docutils literal"><span class="pre">CLOB</span></tt></a> data
+that is returned from cursors.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This type is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.LONG_BINARY">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">LONG_BINARY</tt><a class="headerlink" href="#cx_Oracle.LONG_BINARY" title="Permalink to this definition"></a></dt>
+<dd><p>This type object is used to describe columns in a database that are long
+binary (in Oracle these are LONG RAW columns).</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This type is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.LONG_STRING">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">LONG_STRING</tt><a class="headerlink" href="#cx_Oracle.LONG_STRING" title="Permalink to this definition"></a></dt>
+<dd><p>This type object is used to describe columns in a database that are long
+strings (in Oracle these are LONG columns).</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This type is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.LONG_UNICODE">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">LONG_UNICODE</tt><a class="headerlink" href="#cx_Oracle.LONG_UNICODE" title="Permalink to this definition"></a></dt>
+<dd><p>This type object is used to describe columns in a database that are long
+strings (in Oracle these are LONG columns). There is no direct support for
+this in Oracle but long unicode strings are bound this way in order to
+avoid the &#8220;unimplemented or unreasonable conversion requested&#8221; error.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This type is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.NATIVE_FLOAT">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">NATIVE_FLOAT</tt><a class="headerlink" href="#cx_Oracle.NATIVE_FLOAT" title="Permalink to this definition"></a></dt>
+<dd><p>This type object is used to describe columns in a database that are of type
+binary_double or binary_float and is only available in Oracle 10g.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This type is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.NCLOB">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">NCLOB</tt><a class="headerlink" href="#cx_Oracle.NCLOB" title="Permalink to this definition"></a></dt>
+<dd><p>This type object is used to describe columns in a database that are NCLOBs.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This type is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.NUMBER">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">NUMBER</tt><a class="headerlink" href="#cx_Oracle.NUMBER" title="Permalink to this definition"></a></dt>
+<dd><p>This type object is used to describe columns in a database that are numbers.</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.OBJECT">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">OBJECT</tt><a class="headerlink" href="#cx_Oracle.OBJECT" title="Permalink to this definition"></a></dt>
+<dd><p>This type object is used to describe columns in a database that are objects.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This type is an extension to the DB API definition.</p>
+</div>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.ROWID">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">ROWID</tt><a class="headerlink" href="#cx_Oracle.ROWID" title="Permalink to this definition"></a></dt>
+<dd><p>This type object is used to describe the pseudo column &#8220;rowid&#8221;.</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.STRING">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">STRING</tt><a class="headerlink" href="#cx_Oracle.STRING" title="Permalink to this definition"></a></dt>
+<dd><p>This type object is used to describe columns in a database that are strings
+(in Oracle this is VARCHAR2 columns).</p>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.TIMESTAMP">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">TIMESTAMP</tt><a class="headerlink" href="#cx_Oracle.TIMESTAMP" title="Permalink to this definition"></a></dt>
+<dd><p>This type object is used to describe columns in a database that are
+timestamps.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This attribute is an extension to the DB API definition and is only
+available in Oracle 9i.</p>
+</div>
+</dd></dl>
+
+<dl class="data">
+<dt id="cx_Oracle.UNICODE">
+<tt class="descclassname">cx_Oracle.</tt><tt class="descname">UNICODE</tt><a class="headerlink" href="#cx_Oracle.UNICODE" title="Permalink to this definition"></a></dt>
+<dd><p>This type object is used to describe columns in a database that are unicode
+(in Oracle this is NVARCHAR2 columns).</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This type is an extension to the DB API definition and is only available
+in Python 2.x. In Python 3.x these types of columns are returned as
+STRING.</p>
+</div>
+</dd></dl>
+
+</div>
+<div class="section" id="exceptions">
+<span id="id2"></span><h2>Exceptions<a class="headerlink" href="#exceptions" title="Permalink to this headline"></a></h2>
+<dl class="exception">
+<dt id="cx_Oracle.Warning">
+<em class="property">exception </em><tt class="descclassname">cx_Oracle.</tt><tt class="descname">Warning</tt><a class="headerlink" href="#cx_Oracle.Warning" title="Permalink to this definition"></a></dt>
+<dd><p>Exception raised for important warnings and defined by the DB API but not
+actually used by cx_Oracle.</p>
+</dd></dl>
+
+<dl class="exception">
+<dt id="cx_Oracle.Error">
+<em class="property">exception </em><tt class="descclassname">cx_Oracle.</tt><tt class="descname">Error</tt><a class="headerlink" href="#cx_Oracle.Error" title="Permalink to this definition"></a></dt>
+<dd><p>Exception that is the base class of all other exceptions defined by
+cx_Oracle and is a subclass of the Python StandardError exception (defined
+in the module exceptions).</p>
+</dd></dl>
+
+<dl class="exception">
+<dt id="cx_Oracle.InterfaceError">
+<em class="property">exception </em><tt class="descclassname">cx_Oracle.</tt><tt class="descname">InterfaceError</tt><a class="headerlink" href="#cx_Oracle.InterfaceError" title="Permalink to this definition"></a></dt>
+<dd><p>Exception raised for errors that are related to the database interface
+rather than the database itself. It is a subclass of Error.</p>
+</dd></dl>
+
+<dl class="exception">
+<dt id="cx_Oracle.DatabaseError">
+<em class="property">exception </em><tt class="descclassname">cx_Oracle.</tt><tt class="descname">DatabaseError</tt><a class="headerlink" href="#cx_Oracle.DatabaseError" title="Permalink to this definition"></a></dt>
+<dd><p>Exception raised for errors that are related to the database. It is a
+subclass of Error.</p>
+</dd></dl>
+
+<dl class="exception">
+<dt id="cx_Oracle.DataError">
+<em class="property">exception </em><tt class="descclassname">cx_Oracle.</tt><tt class="descname">DataError</tt><a class="headerlink" href="#cx_Oracle.DataError" title="Permalink to this definition"></a></dt>
+<dd><p>Exception raised for errors that are due to problems with the processed
+data. It is a subclass of DatabaseError.</p>
+</dd></dl>
+
+<dl class="exception">
+<dt id="cx_Oracle.OperationalError">
+<em class="property">exception </em><tt class="descclassname">cx_Oracle.</tt><tt class="descname">OperationalError</tt><a class="headerlink" href="#cx_Oracle.OperationalError" title="Permalink to this definition"></a></dt>
+<dd><p>Exception raised for errors that are related to the operation of the
+database but are not necessarily under the control of the progammer. It is a
+subclass of DatabaseError.</p>
+</dd></dl>
+
+<dl class="exception">
+<dt id="cx_Oracle.IntegrityError">
+<em class="property">exception </em><tt class="descclassname">cx_Oracle.</tt><tt class="descname">IntegrityError</tt><a class="headerlink" href="#cx_Oracle.IntegrityError" title="Permalink to this definition"></a></dt>
+<dd><p>Exception raised when the relational integrity of the database is affected.
+It is a subclass of DatabaseError.</p>
+</dd></dl>
+
+<dl class="exception">
+<dt id="cx_Oracle.InternalError">
+<em class="property">exception </em><tt class="descclassname">cx_Oracle.</tt><tt class="descname">InternalError</tt><a class="headerlink" href="#cx_Oracle.InternalError" title="Permalink to this definition"></a></dt>
+<dd><p>Exception raised when the database encounters an internal error. It is a
+subclass of DatabaseError.</p>
+</dd></dl>
+
+<dl class="exception">
+<dt id="cx_Oracle.ProgrammingError">
+<em class="property">exception </em><tt class="descclassname">cx_Oracle.</tt><tt class="descname">ProgrammingError</tt><a class="headerlink" href="#cx_Oracle.ProgrammingError" title="Permalink to this definition"></a></dt>
+<dd><p>Exception raised for programming errors. It is a subclass of DatabaseError.</p>
+</dd></dl>
+
+<dl class="exception">
+<dt id="cx_Oracle.NotSupportedError">
+<em class="property">exception </em><tt class="descclassname">cx_Oracle.</tt><tt class="descname">NotSupportedError</tt><a class="headerlink" href="#cx_Oracle.NotSupportedError" title="Permalink to this definition"></a></dt>
+<dd><p>Exception raised when a method or database API was used which is not
+supported by the database. It is a subclass of DatabaseError.</p>
+</dd></dl>
+
+</div>
+<div class="section" id="exception-handling">
+<h2>Exception handling<a class="headerlink" href="#exception-handling" title="Permalink to this headline"></a></h2>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p>PEP 249 (Python Database API Specification v2.0) says the following about
+exception values:</p>
+<blockquote>
+<div>[...] The values of these exceptions are not defined. They should
+give the user a fairly good idea of what went wrong, though. [...]</div></blockquote>
+<p class="last">With cx_Oracle every exception object has exactly one argument in the
+<tt class="docutils literal"><span class="pre">args</span></tt> tuple. This argument is a <tt class="docutils literal"><span class="pre">cx_Oracle._Error</span></tt> object which has
+the following three read-only attributes.</p>
+</div>
+<dl class="attribute">
+<dt id="cx_Oracle._Error.code">
+<tt class="descclassname">_Error.</tt><tt class="descname">code</tt><a class="headerlink" href="#cx_Oracle._Error.code" title="Permalink to this definition"></a></dt>
+<dd><p>Integer attribute representing the Oracle error number (ORA-XXXXX).</p>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="cx_Oracle._Error.offset">
+<tt class="descclassname">_Error.</tt><tt class="descname">offset</tt><a class="headerlink" href="#cx_Oracle._Error.offset" title="Permalink to this definition"></a></dt>
+<dd><p>Integer attribute representing the error offset when applicable.</p>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="cx_Oracle._Error.message">
+<tt class="descclassname">_Error.</tt><tt class="descname">message</tt><a class="headerlink" href="#cx_Oracle._Error.message" title="Permalink to this definition"></a></dt>
+<dd><p>String attribute representing the Oracle message of the error. This
+message is localized by the environment of the Oracle connection.</p>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="cx_Oracle._Error.context">
+<tt class="descclassname">_Error.</tt><tt class="descname">context</tt><a class="headerlink" href="#cx_Oracle._Error.context" title="Permalink to this definition"></a></dt>
+<dd><p>String attribute representing the context in which the exception was
+raised..</p>
+</dd></dl>
+
+<p>This allows you to use the exceptions for example in the following way:</p>
+<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">sys</span>
+<span class="kn">import</span> <span class="nn">cx_Oracle</span>
+
+<span class="n">connection</span> <span class="o">=</span> <span class="n">cx_Oracle</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="s">&quot;user/pw@tns&quot;</span><span class="p">)</span>
+<span class="n">cursor</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
+
+<span class="k">try</span><span class="p">:</span>
+    <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s">&quot;select 1 / 0 from dual&quot;</span><span class="p">)</span>
+<span class="k">except</span> <span class="n">cx_Oracle</span><span class="o">.</span><span class="n">DatabaseError</span><span class="p">,</span> <span class="n">exc</span><span class="p">:</span>
+    <span class="n">error</span><span class="p">,</span> <span class="o">=</span> <span class="n">exc</span><span class="o">.</span><span class="n">args</span>
+    <span class="k">print</span> <span class="o">&gt;&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Oracle-Error-Code:&quot;</span><span class="p">,</span> <span class="n">error</span><span class="o">.</span><span class="n">code</span>
+    <span class="k">print</span> <span class="o">&gt;&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Oracle-Error-Message:&quot;</span><span class="p">,</span> <span class="n">error</span><span class="o">.</span><span class="n">message</span>
+</pre></div>
+</div>
+</div>
+</div>
+
+
+          </div>
+        </div>
+      </div>
+      <div class="sphinxsidebar">
+        <div class="sphinxsidebarwrapper">
+  <h3><a href="index.html">Table Of Contents</a></h3>
+  <ul>
+<li><a class="reference internal" href="#">Module Interface</a><ul>
+<li><a class="reference internal" href="#constants">Constants</a><ul>
+<li><a class="reference internal" href="#global">Global</a></li>
+<li><a class="reference internal" href="#database-callbacks">Database Callbacks</a></li>
+<li><a class="reference internal" href="#database-change-notification">Database Change Notification</a></li>
+<li><a class="reference internal" href="#database-resident-connection-pooling">Database Resident Connection Pooling</a></li>
+<li><a class="reference internal" href="#database-startup-shutdown">Database Startup/Shutdown</a></li>
+<li><a class="reference internal" href="#session-pooling">Session Pooling</a></li>
+</ul>
+</li>
+<li><a class="reference internal" href="#types">Types</a></li>
+<li><a class="reference internal" href="#exceptions">Exceptions</a></li>
+<li><a class="reference internal" href="#exception-handling">Exception handling</a></li>
+</ul>
+</li>
+</ul>
+
+  <h4>Previous topic</h4>
+  <p class="topless"><a href="index.html"
+                        title="previous chapter">cx_Oracle</a></p>
+  <h4>Next topic</h4>
+  <p class="topless"><a href="connection.html"
+                        title="next chapter">Connection Object</a></p>
+<div id="searchbox" style="display: none">
+  <h3>Quick search</h3>
+    <form class="search" action="search.html" method="get">
+      <input type="text" name="q" />
+      <input type="submit" value="Go" />
+      <input type="hidden" name="check_keywords" value="yes" />
+      <input type="hidden" name="area" value="default" />
+    </form>
+    <p class="searchtip" style="font-size: 90%">
+    Enter search terms or a module, class or function name.
+    </p>
+</div>
+<script type="text/javascript">$('#searchbox').show(0);</script>
+        </div>
+      </div>
+      <div class="clearer"></div>
+    </div>
+    <div class="related">
+      <h3>Navigation</h3>
+      <ul>
+        <li class="right" style="margin-right: 10px">
+          <a href="genindex.html" title="General Index"
+             >index</a></li>
+        <li class="right" >
+          <a href="py-modindex.html" title="Python Module Index"
+             >modules</a> |</li>
+        <li class="right" >
+          <a href="connection.html" title="Connection Object"
+             >next</a> |</li>
+        <li class="right" >
+          <a href="index.html" title="cx_Oracle"
+             >previous</a> |</li>
+        <li><a href="index.html">cx_Oracle 5.1.2 documentation</a> &raquo;</li> 
+      </ul>
+    </div>
+    <div class="footer">
+        &copy; Copyright 2012, Anthony Tuininga.
+      Last updated on Jul 02, 2012.
+      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
+    </div>
+  </body>
+</html>
\ No newline at end of file
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/html/objects.inv b/desktop/core/ext-py/cx_Oracle-5.1.2/html/objects.inv
new file mode 100644
index 0000000000000000000000000000000000000000..77d64d61135e809555fef072b969906ff1c84ae4
GIT binary patch
literal 2229
zcmV;m2uk-OAX9K?X>NERX>N99Zgg*Qc_4OWa&u{KZXhxWBOp+6Z)#;@bUGkocwbL)
zVPkA%3L_v^WpZ<AZ*DpuH7+p<BOp|0Wgv28ZDDC{WMy(7Z)PBLXlZjGW@&6?AZc?T
zV{dJ6a%FRKWn>_Ab7^j8AbM<RVlE1J+NE00lcTr}zUQw<)thUl-d^`ch%?Qr1SlZg
z(<jOSCt-(QYn$oL{`D&YAtoVM%)4}TjE!Yk`t(VHeMPL4Ns)`Wknx`>-LrK5^2a<Y
z;woi}lg!fpe4CSQ*6hggB#+rwfBJQ_SunTi|7X7_FZO@+C&E}l_qR8{wZG@i{x23u
zF-wz(<%0EBwS(71o95>XgdC8iJilBYwBl?phiRpXDlUpg!J6Ug4(8=oE7VLd%A-?%
zelyl?;5QRodStVx$n(dy!yvo~G}!IXjdZ(Idl5Yf)(j`5y4Y97uFIPn8@t6$4U+K#
zjo9qKi(K|sC~EsQUtgYYse}cf1R=_zNbl7k1PBq<Pde$EF}I%F3YQl9hl9abccIR*
zGXPMPkTjR025DX=&7!Z+;WUDCmFGWO9sIX9yZQg++x+D=dExJtzUhUo=LAmp8U${=
zJf@P)@3&G{t(N}lE?7D5c4%$4WMvrv8Clp^(Sm)ksFEzB`S~Iwlcyq{-<#aaYzuk=
z3koj&!HZ8(&j#i5WDm>d!=}*fa$qt#fqOlyy5Ht@oMn<zev#==<&7<lojxR-!;6Z;
zK`?p0%kyPM5P+h0o)vtAKH02Mn!XrmPSeYl^$K={pyzs~oYOOCU{uNdJHbrVz40dW
z+BTgP30Guo*<|_QIzH;G<c-)t=m&-u>~MDI2cBhrADODS;35|JgCPxgt@?h~BO7ZQ
z8oS_CZ{B;r42<2~5N{z)m5hteysy^>jC`40!@~kB?iWp~{)OEKlinVcs0}D%4`K~$
z(|Vp)d@hQTaeA>cob%n@HlXLBy;`kBX(7hV4?wX#_902x^&H(?1v}xgRmlK1k{F2`
zw+r8y%izN$p-0?}VG@)P21&*MgtHP2ASx1olNh^AfZEC2dA{R~S)yWEl5$y<TFZJo
zJ2;{DfpfnPf3-Al5d$XdsbDx9yU7`yXntfR72>nt@r2VTykh)Xl+Dy_u;xqCw0=1f
z8GGT@C*B+JQ0m(__V-YWc2}8tN5@FzI?g7nt@6#-gztuhGe^h0z`U{9c+UG6#P=Mt
z<b^CEphPIwteqdAD1Ywtiag8z5i`*1=Mo=9@(;r^gx<Y5riHb6rZc`~M*u4zqOxd6
z2u>vD3eZ?`a5G|Fr0JeUKPR};+WJ9Oq4{cfdi{oB0;DAj$4SL)yCg3wDbFPXUyoD9
zG4A(Zg)7fNa)#zAZDUJ(7cf3tE#X-9cY?lCNC&bYiGB(^vJ{p4f6l1zZDZ+p0Uk4U
zwpFVKwV;&&f2y42QJrBPQGj_HqtOtt7*|0<4p+n@2m}PWa51Xd$;GG{ss!;FQ_``-
zE|Hu<(jh)WD#UWB^Y|WkO5hq`OH*l$N;qutjwH;_!l6zdU0etVlC1n<TuiozHp^IA
z_G<Z2yED%Hm85*!(Cg6i$rCxkI295AVGT<H+B~Q8XdB12mTPN6rX*7B1{0P*1l3}p
zO3o_I!Gc2(ogk~92m)2k*)b84acvk<jdEX!GtMB@RW*fRlMT5EdU^=$va{pl?5y?N
zJ)01V6>rhrYg?-Tm}a_4g?h0?mL+n6NY@}tHY7l43OuHWSjw`86zx%6ZC1Ld!{=1w
ztMd*NEZ>&cyX_K5%Wn+WanS_04l$yHaDivQ$GWCf<v*{abr_9qMS=lt`>57#dR}ED
zy~HBKW%N?aOhy!Ze~?R$+6!ckj!O_+Qp*jW)5?r~Ezgn(mvQq%VP83wcC``454M5p
z5!dj@)aq#98Mbejf#ul7W@K@F$(+#`ljf|9fCLsY+)bh+Og23A!OWgi1of=;X$+L7
z`nZA~m^`Bn@=kf)GEJNtE0?z>f%&S@eqCN-Ul5PPNP$U-C>+3x-c_!K<B3{e;H;#4
z3f9*h0TekHpQzTxIsHUa;+PjD;)wlX*l*-V169DWDk!*i%JQQ;>GA4WmBV&4b&gwV
z9u<|IrYl9@3&5jQoa7N7OayeQrX`r{FP5V01I&(QLY|xckiMn~_~Hk~*2To~eRVi6
z?xTW^q9$}1MzNDA3FiO_f<*00+p+1+1vgXVK(+?r#^b?i41wnv2Eki-vWC~_<f-5M
z=pVgT_c~^SDeNG%=q;OA@V`$TY{wppNJ?knQkkFB(o-6TErQ0_+EVjKi!90tnG0~n
zfl8bvF`?1lRl?aMwDg>JYlY>F*L3Ocit&B}Rd+-CDoNwIbb#`GmlsC>iwxXsa$ymh
z(J5@(#78bj8jvY=OU!rf3e}kg2E2!)$`C%>cYd7EI#yT)`9aKGfK8p#q|Tg^82%=Q
z1jkHOCeeZ*wtTDBO2+%Ks!cyDH)->2FrKO5%r2x~m1O~N8>8&5w;%n&?Wd?P3|T%<
zryjRfBe32`xZXGht_a)Qvy!pn_z=kUl}LnWR|9V28p1WYb|sdkDJ0XfjnUSia)LcT
zL5|m~^3}>X257$?c}Dowj%SkZ1b1y+FZ2hp7iQT3skfP$Ag-<P#85qYku&7U%`WQc
zdryNo$<sGy^e1Z@{3w&rq5C}|Ci$U2MP4=J)%DkFKMPGNVs`s<>?Ys{m7rDKx4ag{
zbOK(!S{N<YsHKX=@_(oAW!XL%Z3y-7{0X;t0_Z&*_nOLjEvwu9PE)1Vaorl0u6mLP
zY@7I5c_!RACdL=RTQpy+sAoSFS#e}Jgi(Q0L09dpSvm3pmVSdBLg-WuU$?N1Jdx+g
z-)GP~V(FBxOtjVXw%|GOd!H_S5tDMCMZCx7OZ^~<#=uJ>RvSCJv=a!|guL@#Am?+9
DpJi0{

literal 0
HcmV?d00001

diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/html/py-modindex.html b/desktop/core/ext-py/cx_Oracle-5.1.2/html/py-modindex.html
new file mode 100644
index 0000000..ad4a0e7
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/html/py-modindex.html
@@ -0,0 +1,115 @@
+
+
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
+  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+
+
+<html xmlns="http://www.w3.org/1999/xhtml">
+  <head>
+    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
+    
+    <title>Python Module Index &mdash; cx_Oracle 5.1.2 documentation</title>
+    
+    <link rel="stylesheet" href="_static/default.css" type="text/css" />
+    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
+    
+    <script type="text/javascript">
+      var DOCUMENTATION_OPTIONS = {
+        URL_ROOT:    '',
+        VERSION:     '5.1.2',
+        COLLAPSE_INDEX: false,
+        FILE_SUFFIX: '.html',
+        HAS_SOURCE:  false
+      };
+    </script>
+    <script type="text/javascript" src="_static/jquery.js"></script>
+    <script type="text/javascript" src="_static/underscore.js"></script>
+    <script type="text/javascript" src="_static/doctools.js"></script>
+    <link rel="top" title="cx_Oracle 5.1.2 documentation" href="index.html" />
+ 
+
+    <script type="text/javascript">
+      DOCUMENTATION_OPTIONS.COLLAPSE_INDEX = true;
+    </script>
+
+
+  </head>
+  <body>
+    <div class="related">
+      <h3>Navigation</h3>
+      <ul>
+        <li class="right" style="margin-right: 10px">
+          <a href="genindex.html" title="General Index"
+             accesskey="I">index</a></li>
+        <li class="right" >
+          <a href="#" title="Python Module Index"
+             >modules</a> |</li>
+        <li><a href="index.html">cx_Oracle 5.1.2 documentation</a> &raquo;</li> 
+      </ul>
+    </div>  
+
+    <div class="document">
+      <div class="documentwrapper">
+        <div class="bodywrapper">
+          <div class="body">
+            
+
+   <h1>Python Module Index</h1>
+
+   <div class="modindex-jumpbox">
+   <a href="#cap-c"><strong>c</strong></a>
+   </div>
+
+   <table class="indextable modindextable" cellspacing="0" cellpadding="2">
+     <tr class="pcap"><td></td><td>&nbsp;</td><td></td></tr>
+     <tr class="cap" id="cap-c"><td></td><td>
+       <strong>c</strong></td><td></td></tr>
+     <tr>
+       <td></td>
+       <td>
+       <a href="module.html#module-cx_Oracle"><tt class="xref">cx_Oracle</tt></a></td><td>
+       <em></em></td></tr>
+   </table>
+
+
+          </div>
+        </div>
+      </div>
+      <div class="sphinxsidebar">
+        <div class="sphinxsidebarwrapper">
+<div id="searchbox" style="display: none">
+  <h3>Quick search</h3>
+    <form class="search" action="search.html" method="get">
+      <input type="text" name="q" />
+      <input type="submit" value="Go" />
+      <input type="hidden" name="check_keywords" value="yes" />
+      <input type="hidden" name="area" value="default" />
+    </form>
+    <p class="searchtip" style="font-size: 90%">
+    Enter search terms or a module, class or function name.
+    </p>
+</div>
+<script type="text/javascript">$('#searchbox').show(0);</script>
+        </div>
+      </div>
+      <div class="clearer"></div>
+    </div>
+    <div class="related">
+      <h3>Navigation</h3>
+      <ul>
+        <li class="right" style="margin-right: 10px">
+          <a href="genindex.html" title="General Index"
+             >index</a></li>
+        <li class="right" >
+          <a href="#" title="Python Module Index"
+             >modules</a> |</li>
+        <li><a href="index.html">cx_Oracle 5.1.2 documentation</a> &raquo;</li> 
+      </ul>
+    </div>
+    <div class="footer">
+        &copy; Copyright 2012, Anthony Tuininga.
+      Last updated on Jul 02, 2012.
+      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
+    </div>
+  </body>
+</html>
\ No newline at end of file
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/html/search.html b/desktop/core/ext-py/cx_Oracle-5.1.2/html/search.html
new file mode 100644
index 0000000..e4dc24d
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/html/search.html
@@ -0,0 +1,106 @@
+
+
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
+  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+
+
+<html xmlns="http://www.w3.org/1999/xhtml">
+  <head>
+    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
+    
+    <title>Search &mdash; cx_Oracle 5.1.2 documentation</title>
+    
+    <link rel="stylesheet" href="_static/default.css" type="text/css" />
+    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
+    
+    <script type="text/javascript">
+      var DOCUMENTATION_OPTIONS = {
+        URL_ROOT:    '',
+        VERSION:     '5.1.2',
+        COLLAPSE_INDEX: false,
+        FILE_SUFFIX: '.html',
+        HAS_SOURCE:  false
+      };
+    </script>
+    <script type="text/javascript" src="_static/jquery.js"></script>
+    <script type="text/javascript" src="_static/underscore.js"></script>
+    <script type="text/javascript" src="_static/doctools.js"></script>
+    <script type="text/javascript" src="_static/searchtools.js"></script>
+    <link rel="top" title="cx_Oracle 5.1.2 documentation" href="index.html" />
+  <script type="text/javascript">
+    jQuery(function() { Search.loadIndex("searchindex.js"); });
+  </script>
+   
+
+  </head>
+  <body>
+    <div class="related">
+      <h3>Navigation</h3>
+      <ul>
+        <li class="right" style="margin-right: 10px">
+          <a href="genindex.html" title="General Index"
+             accesskey="I">index</a></li>
+        <li class="right" >
+          <a href="py-modindex.html" title="Python Module Index"
+             >modules</a> |</li>
+        <li><a href="index.html">cx_Oracle 5.1.2 documentation</a> &raquo;</li> 
+      </ul>
+    </div>  
+
+    <div class="document">
+      <div class="documentwrapper">
+        <div class="bodywrapper">
+          <div class="body">
+            
+  <h1 id="search-documentation">Search</h1>
+  <div id="fallback" class="admonition warning">
+  <script type="text/javascript">$('#fallback').hide();</script>
+  <p>
+    Please activate JavaScript to enable the search
+    functionality.
+  </p>
+  </div>
+  <p>
+    From here you can search these documents. Enter your search
+    words into the box below and click "search". Note that the search
+    function will automatically search for all of the words. Pages
+    containing fewer words won't appear in the result list.
+  </p>
+  <form action="" method="get">
+    <input type="text" name="q" value="" />
+    <input type="submit" value="search" />
+    <span id="search-progress" style="padding-left: 10px"></span>
+  </form>
+  
+  <div id="search-results">
+  
+  </div>
+
+          </div>
+        </div>
+      </div>
+      <div class="sphinxsidebar">
+        <div class="sphinxsidebarwrapper">
+        </div>
+      </div>
+      <div class="clearer"></div>
+    </div>
+    <div class="related">
+      <h3>Navigation</h3>
+      <ul>
+        <li class="right" style="margin-right: 10px">
+          <a href="genindex.html" title="General Index"
+             >index</a></li>
+        <li class="right" >
+          <a href="py-modindex.html" title="Python Module Index"
+             >modules</a> |</li>
+        <li><a href="index.html">cx_Oracle 5.1.2 documentation</a> &raquo;</li> 
+      </ul>
+    </div>
+    <div class="footer">
+        &copy; Copyright 2012, Anthony Tuininga.
+      Last updated on Jul 02, 2012.
+      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
+    </div>
+  </body>
+</html>
\ No newline at end of file
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/html/searchindex.js b/desktop/core/ext-py/cx_Oracle-5.1.2/html/searchindex.js
new file mode 100644
index 0000000..1738f2b
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/html/searchindex.js
@@ -0,0 +1 @@
+Search.setIndex({objects:{"":{cx_Oracle:[4,0,1,""]},LOB:{fileexists:[0,2,1,""],trim:[0,2,1,""],isopen:[0,2,1,""],read:[0,2,1,""],getchunksize:[0,2,1,""],getfilename:[0,2,1,""],setfilename:[0,2,1,""],write:[0,2,1,""],close:[0,2,1,""],open:[0,2,1,""],size:[0,2,1,""]},cx_Oracle:{OBJECT:[4,1,1,""],SessionPool:[4,4,1,""],PRELIM_AUTH:[4,1,1,""],OPCODE_UPDATE:[4,1,1,""],SUBSCR_PROTO_MAIL:[4,1,1,""],TimestampFromTicks:[4,4,1,""],DataError:[4,5,1,""],DATETIME:[4,1,1,""],BINARY:[4,1,1,""],DBSHUTDOWN_TRANSACTIONAL_LOCAL:[4,1,1,""],EVENT_OBJCHANGE:[4,1,1,""],LONG_STRING:[4,1,1,""],CURSOR:[4,1,1,""],Warning:[4,5,1,""],UCBTYPE_REPLACE:[4,1,1,""],NCLOB:[4,1,1,""],DatabaseError:[4,5,1,""],makedsn:[4,4,1,""],DBSHUTDOWN_IMMEDIATE:[4,1,1,""],SYSOPER:[4,1,1,""],connect:[4,4,1,""],UCBTYPE_EXIT:[4,1,1,""],TimeFromTicks:[4,4,1,""],INTERVAL:[4,1,1,""],FNCODE_STMTFETCH:[4,1,1,""],version:[4,1,1,""],UNICODE:[4,1,1,""],FIXED_UNICODE:[4,1,1,""],IntegrityError:[4,5,1,""],buildtime:[4,1,1,""],DBSHUTDOWN_ABORT:[4,1,1,""],Cursor:[4,4,1,""],OPCODE_DELETE:[4,1,1,""],InterfaceError:[4,5,1,""],FNCODE_BINDBYNAME:[4,1,1,""],TIMESTAMP:[4,1,1,""],EVENT_STARTUP:[4,1,1,""],BLOB:[4,1,1,""],NATIVE_FLOAT:[4,1,1,""],FNCODE_STMTPREPARE:[4,1,1,""],Binary:[4,4,1,""],LONG_UNICODE:[4,1,1,""],FNCODE_DEFINEBYPOS:[4,1,1,""],SUBSCR_PROTO_OCI:[4,1,1,""],threadsafety:[4,1,1,""],EVENT_DEREG:[4,1,1,""],Timestamp:[4,4,1,""],LONG_BINARY:[4,1,1,""],FNCODE_BINDBYPOS:[4,1,1,""],OPCODE_ALLOPS:[4,1,1,""],SYSDBA:[4,1,1,""],ProgrammingError:[4,5,1,""],OPCODE_DROP:[4,1,1,""],ATTR_PURITY_NEW:[4,1,1,""],Time:[4,4,1,""],clientversion:[4,4,1,""],Date:[4,4,1,""],Connection:[4,4,1,""],Error:[4,5,1,""],SPOOL_ATTRVAL_WAIT:[4,1,1,""],SPOOL_ATTRVAL_FORCEGET:[4,1,1,""],DBSHUTDOWN_TRANSACTIONAL:[4,1,1,""],SPOOL_ATTRVAL_NOWAIT:[4,1,1,""],UCBTYPE_ENTRY:[4,1,1,""],DBSHUTDOWN_FINAL:[4,1,1,""],apilevel:[4,1,1,""],LOB:[4,1,1,""],FIXED_CHAR:[4,1,1,""],BFILE:[4,1,1,""],CLOB:[4,1,1,""],EVENT_SHUTDOWN:[4,1,1,""],InternalError:[4,5,1,""],NUMBER:[4,1,1,""],OPCODE_ALLROWS:[4,1,1,""],ATTR_PURITY_SELF:[4,1,1,""],ATTR_PURITY_DEFAULT:[4,1,1,""],EVENT_SHUTDOWN_ANY:[4,1,1,""],SUBSCR_PROTO_HTTP:[4,1,1,""],FNCODE_STMTEXECUTE:[4,1,1,""],paramstyle:[4,1,1,""],STRING:[4,1,1,""],OPCODE_ALTER:[4,1,1,""],NotSupportedError:[4,5,1,""],DateFromTicks:[4,4,1,""],EVENT_NONE:[4,1,1,""],SUBSCR_PROTO_SERVER:[4,1,1,""],OPCODE_INSERT:[4,1,1,""],OperationalError:[4,5,1,""],ROWID:[4,1,1,""],SUBSCR_NAMESPACE_DBCHANGE:[4,1,1,""]},SessionPool:{username:[3,3,1,""],tnsentry:[3,3,1,""],busy:[3,3,1,""],opened:[3,3,1,""],min:[3,3,1,""],max:[3,3,1,""],acquire:[3,2,1,""],drop:[3,2,1,""],timeout:[3,3,1,""],dsn:[3,3,1,""],increment:[3,3,1,""],release:[3,2,1,""],homogeneous:[3,3,1,""],password:[3,3,1,""],name:[3,3,1,""]},MessageTable:{operation:[8,3,1,""],rows:[8,3,1,""],name:[8,3,1,""]},Cursor:{outputtypehandler:[5,3,1,""],fetchall:[5,2,1,""],parse:[5,2,1,""],bindvars:[5,3,1,""],close:[5,2,1,""],rowfactory:[5,3,1,""],bindnames:[5,2,1,""],prepare:[5,2,1,""],executemanyprepared:[5,2,1,""],next:[5,2,1,""],inputtypehandler:[5,3,1,""],setoutputsize:[5,2,1,""],fetchraw:[5,2,1,""],fetchvars:[5,3,1,""],statement:[5,3,1,""],"var":[5,2,1,""],fetchone:[5,2,1,""],description:[5,1,1,""],bindarraysize:[5,3,1,""],"__iter__":[5,2,1,""],setinputsizes:[5,2,1,""],arraysize:[5,3,1,""],arrayvar:[5,2,1,""],fetchmany:[5,2,1,""],callproc:[5,2,1,""],execute:[5,2,1,""],executemany:[5,2,1,""],callfunc:[5,2,1,""],rowcount:[5,3,1,""],connection:[5,2,1,""],numbersAsStrings:[5,3,1,""]},Connection:{outputtypehandler:[6,3,1,""],"__enter__":[6,2,1,""],encoding:[6,3,1,""],"__exit__":[6,2,1,""],startup:[6,2,1,""],module:[6,3,1,""],subscribe:[6,2,1,""],shutdown:[6,2,1,""],cancel:[6,2,1,""],close:[6,2,1,""],client_identifier:[6,3,1,""],nencoding:[6,3,1,""],clientinfo:[6,3,1,""],prepare:[6,2,1,""],tnsentry:[6,3,1,""],ping:[6,2,1,""],inputtypehandler:[6,3,1,""],version:[6,3,1,""],changepassword:[6,2,1,""],stmtcachesize:[6,3,1,""],dsn:[6,3,1,""],username:[6,3,1,""],autocommit:[6,3,1,""],begin:[6,2,1,""],rollback:[6,2,1,""],password:[6,3,1,""],maxBytesPerCharacter:[6,3,1,""],unregister:[6,2,1,""],register:[6,2,1,""],cursor:[6,2,1,""],action:[6,3,1,""],commit:[6,2,1,""],current_schema:[6,3,1,""]},Variable:{allocelems:[7,3,1,""],getvalue:[7,2,1,""],numElements:[7,3,1,""],setvalue:[7,2,1,""],inconverter:[7,3,1,""],maxlength:[7,3,1,""],bufferSize:[7,3,1,""],outconverter:[7,3,1,""],size:[7,3,1,""]},Message:{tables:[8,3,1,""],type:[8,3,1,""],dbname:[8,3,1,""]},"cx_Oracle._Error":{message:[4,3,1,""],code:[4,3,1,""],context:[4,3,1,""],offset:[4,3,1,""]},MessageRow:{operation:[8,3,1,""],rowid:[8,3,1,""]},Subscription:{operations:[8,3,1,""],protocol:[8,3,1,""],rowids:[8,3,1,""],namespace:[8,3,1,""],callback:[8,3,1,""],connection:[8,3,1,""],timeout:[8,3,1,""],registerquery:[8,2,1,""],port:[8,3,1,""]}},terms:{"default":[5,6,4],all:[0,1,2,4,5,6,7],code:[6,4,2],consider:5,queri:[5,8],global:[6,4],month:4,rebind:5,signific:6,follow:[6,4,2],row:[5,1,6,8],attr_purity_self:4,dsn:[3,6,4],typeerror:5,depend:5,display_s:5,service_nam:4,specif:[1,4,2],send:8,client_info:6,nencod:6,program:4,stmtcaches:6,under:4,alberta:2,aris:2,neglig:2,sent:[6,4,8],merchant:2,sourc:[4,2],"__exit__":6,string:[5,7,6,4],fals:[6,4,8],null_ok:5,veri:4,affect:[5,6,4],relev:4,special:2,level:[5,4],did:5,list:[5,2,8],scalar:7,fewer:5,"try":[6,4],item:[5,7],opcode_insert:4,stderr:4,small:6,freed:4,round:5,databaseerror:4,impli:2,smaller:0,fncode_stmtfetch:4,"10g":[6,4,8],opcode_allop:[6,4],second:[3,6,4,8],design:5,pass:[5,4,8],further:4,port:[6,4,8],compat:5,index:[0,1,5],what:4,uncommit:4,long_unicod:4,section:[5,6,4,8],inputtypehandl:[5,6],current:[5,3,6,4],delet:[5,6,4],experiment:6,powerbuild:4,"new":[0,5,6,4],method:[0,4,5,6,7,8],event_shutdown_ani:4,client_identifi:6,deriv:2,gener:[4,8],never:6,here:4,disclaim:2,met:2,procur:2,modif:2,standard:4,modifi:[5,6],sinc:[5,4],valu:[0,4,5,6,7,8],wait:4,convert:[5,7],convers:[7,4],ahead:5,host:4,precis:[5,6],prior:[5,4,2],amount:[0,5],behav:[4,8],permit:[2,8],action:6,chang:[5,6,4,8],notsupportederror:4,unreason:4,control:[3,4],semant:5,via:5,iana:6,appli:6,modul:[5,1,6,4],releas:[5,3,4,8],"boolean":[0,3,6,4],marker:4,subscr_proto_http:4,establish:[3,6],select:[5,4],highli:6,long_binari:4,from:[2,3,4,5,6,7,8],describ:[5,4],would:5,memori:5,regist:[6,4,2,8],two:[0,4],next:[5,6,4],few:1,handler:[5,6],call:[0,5,6,4],recommend:5,taken:[5,4],care:5,type:[0,1,5,4,8],until:4,dbshutdown:6,more:[5,1,6,4],sort:4,integrityerror:4,desir:5,opcode_delet:4,numrow:5,notif:[6,4,8],notic:2,warn:4,flag:6,exce:6,indic:[0,3,4,5,6,8],particular:[0,5,6,2],known:4,timefromtick:4,hold:4,cach:[5,6],must:[0,2,4,5,6,8],none:[5,7,6],retriev:5,hour:4,alia:0,prepar:[5,6],work:6,remain:5,abort:4,returntyp:5,can:[0,3,4,5,6,7],www:1,purpos:2,logon:[6,4],fetch:[0,5,6,7],databaseapi:1,overrid:5,oldpassword:6,puriti:4,give:[4,8],process:4,lock:4,fetchvar:5,share:4,accept:[6,4],topic:1,tag:5,caution:6,want:0,setoutputs:5,setfilenam:0,differenti:4,multipl:[0,4],datefromtick:4,rather:[5,6,4],tuininga:[1,2],ping:6,write:[0,3,6,7,5],varchar2:4,recoveri:4,sid:4,sysdba:[6,4],instead:[5,7,4],updat:[0,5,6,4],binary_float:4,map:5,product:2,resourc:4,referenc:[0,5,8],max:[3,4],after:[0,3,6,5,4],minimum:3,setinputs:5,befor:[0,5,6,4],wrong:4,mai:[5,4,2],drastic:5,"\u215b":[1,2],associ:[0,5,6],alloc:[0,5,6,7],attempt:[0,5,6],bind:[5,7],correspond:5,assign:3,issu:[5,6],callback:[6,4,8],maintain:3,environ:4,allow:[5,1,4],anoth:0,callabl:6,nomount:6,order:[3,6,4],cx_oracl:[1,6,4,2],softwar:2,major:4,octob:[],untouch:5,still:6,paramet:[5,6,4],busi:[3,2],outputtypehandl:[5,6],disconnect:4,fit:2,fix:4,dbname:8,fetchal:[0,5],tort:2,pend:6,mail:4,tnsentri:[3,6],might:5,alter:[6,4],them:[5,4],good:[4,2],"return":[0,3,4,5,6,7,8],greater:5,thei:4,python:[5,1,6,7,4],timestamp:4,dai:4,initi:[6,4],nation:6,mention:5,front:1,opcode_allrow:4,setvalu:7,nor:2,down:4,name:[0,2,3,4,5,6,8],edit:5,drop:[3,4],authent:[3,4],getvalu:7,februari:[],exampl:4,mode:[6,4],timeout:[3,6,8],each:[5,3,6,7,8],found:[5,8],went:4,higher:[5,6,4,8],opcode_drop:4,mean:[5,4],prohibit:4,replac:[5,4],chunk:0,idea:4,procedur:[5,4,8],wrap:4,redistribut:2,connect:[1,3,4,5,6,8],year:4,beyond:6,spool_attrval_forceget:4,event:[6,4,2],buffers:7,out:[5,2],variabl:[0,1,6,7,5],safeti:4,network:5,space:5,profit:2,primari:4,content:[5,1],typenam:5,suitabl:4,"100x":6,print:4,attr_purity_new:4,ref:4,integr:4,shut:4,newsiz:0,branchid:6,manipul:0,differ:[5,3,6,4],free:4,diralia:0,getfilenam:0,reason:5,base:[0,4],theori:2,dictionari:[5,8],usual:5,spool_attrval_wait:4,org:1,"byte":[5,7,6],"\u215d":[1,2],ora:[6,4],executemanyprepar:5,thread:4,oci:[6,4],"\u03c9":[1,2],messaget:8,filter:6,length:[5,7,6,4],place:[0,6,4,8],allocelem:7,retain:[5,2],messagerow:8,first:[5,6],oper:[5,6,4,8],endors:2,singleton:5,directli:[5,7],dbshutdown_immedi:4,onc:6,arrai:[0,5,7],event_objchang:4,rowfactori:5,number:[5,3,6,7,4],event_non:4,restrict:6,acquisit:4,alreadi:[5,4],done:[5,3,6,4],subscr_namespace_dbchang:[6,4],open:[0,3,6],predefin:5,size:[0,5,6,7],datetim:4,given:[0,5,6,7,4],bindvar:5,start:4,data:[0,5,7,4,2],licens:[1,2],messag:[1,6,4,8],necessarili:4,statement:[5,6,8],similarli:8,termin:3,connectiontyp:4,semaphor:4,schema:6,forthcom:5,option:[5,6,4],deregist:[6,4],namespac:[6,4,8],juli:1,copi:5,fetchmani:5,circumst:4,specifi:[5,7,6,4,8],direct:[4,2],opcode_alt:4,part:[5,4],pars:5,computronix:[1,2],exactli:4,holder:2,than:[5,6,4],drcp:4,dbshutdown_transact:4,target:4,keyword:[5,4],whenev:[0,5,6],provid:[5,6,4,2],remov:5,zero:8,charact:[7,6],matter:1,reus:5,fncode_stmtexecut:4,posit:[5,7],minut:4,listen:6,sai:4,fashion:4,rac:4,dbshutdown_abort:4,argument:[5,6,4,8],raw:4,expir:6,have:[5,6,4],tabl:[1,6,4,8],need:[5,3,6,4],element:[5,7],caus:[6,2],date:[5,1,4],built:[6,4],equival:[6,4],inform:[5,1,6,4,8],destroi:6,dbshutdown_transactional_loc:4,note:[0,3,4,5,6,7,8],also:[5,6,4],fetchraw:5,without:[5,7,6,4,2],take:[0,6],which:[0,3,6,5,4],tupl:[0,5,4],singl:[5,6,4],even:[4,2],begin:6,nvarchar2:4,distribut:[6,2],shall:2,usernam:[3,6],object:[0,1,3,4,5,6,7,8],oracl:[0,1,3,4,5,6,7,8],sessionpool:[1,4,3],took:8,most:[5,6],larg:5,plan:5,phase:[5,4],why:4,homogen:[3,4],exc:4,url:4,later:5,request:[5,4],doe:[5,7,6,4],determin:[5,6],fixed_char:4,ordinarili:5,fact:5,"128kb":5,session:[3,6,4],permiss:[1,2],protocol:[6,4,8],progamm:4,ocibindbypo:4,penalti:4,access:[0,1,6,4],onli:[3,4,5,6,7,8],explicitli:6,locat:0,acquir:[3,4],copyright:[1,2],fncode_stmtprepar:4,transact:[6,4],"__enter__":6,activ:[6,4],state:4,should:[5,6,4],version:[6,4],mutex:4,local:[6,4],loss:2,unus:[5,6],get:[5,6,4],express:[4,2],dbshutdown_fin:[6,4],becaus:4,cannot:[5,6],"import":[0,4],liabl:2,neither:2,requir:[5,6,4],"\u215e":[1,2],characterist:5,arrys:5,enabl:6,isopen:0,inconvert:[5,7],twophas:[6,4],subscr_proto_serv:4,patch:4,whether:[5,3,6,4,2],common:6,though:4,contain:[5,6],usabl:3,where:[5,4],opcode_upd:4,clientvers:4,set:[0,4,5,6,7,8],getmod:4,truli:4,startup:[6,4],rollback:6,datatyp:5,see:[5,1,6,4,8],result:5,arg:[5,4,8],reserv:[5,1,2],close:[0,5,6,4],optimum:3,xxxxx:4,best:5,awar:5,detect:0,bindnam:5,databas:[1,3,4,5,6,7,8],timestampfromtick:4,written:2,outstand:6,drawn:5,subscript:[1,6,4,8],internalerror:4,attribut:[3,4,5,6,7,8],signatur:[5,7,6],ltd:2,extens:[0,1,3,4,5,6,8],incident:2,numel:7,come:5,problem:4,addit:[5,3,4,8],fncode_definebypo:4,last:5,howev:2,against:5,instanc:4,context:[6,4],maxlength:7,mani:5,nchar:4,comment:[6,4],ucbtype_exit:[6,4],tnsname:4,point:[5,6],threadsafeti:4,exemplari:2,shutdown:[6,4],cancel:6,assum:[5,4],damag:2,liabil:2,three:4,ocistmtexecut:4,ocisvcctx:4,stamp:4,spool_attrval_nowait:4,trademark:2,due:4,been:[5,3,6,4,8],subscrib:[6,8],ocibindbynam:4,"abstract":1,anthoni:[1,2],wish:4,everi:4,oci_thread:4,consequenti:2,ani:[5,7,6,4,2],fileexist:0,getchunks:0,"case":[5,6],ident:4,event_shutdown:4,servic:[4,2],batch:5,cursor:[0,1,4,5,6,8],defin:[5,7,6,4],invok:[5,4],executemani:5,abov:2,error:[5,6,4],subscr_proto_mail:4,apilevel:4,increment:[3,4],defaulttyp:[5,6],itself:[5,6,4],contract:2,dual:4,crash:6,halt:4,standarderror:4,author:1,perform:[0,5,6,4],make:[0,5,6,4],same:[5,7,6,4],binari:[5,4,2],epoch:4,html:1,changepassword:6,advis:2,transactionid:6,numit:5,document:[5,6,4,2],fetchon:5,complet:[0,1,6,4],fncode_bindbypo:4,http:[1,4],keyewordparamet:5,optim:5,upon:[6,4],effect:5,fairli:4,rais:[0,5,6,4],user:[3,6,4],improv:0,mount:6,redefin:5,appropri:4,off:6,unicod:[6,4],entri:[5,3,6,4],thu:0,min:[3,4],well:3,client:[6,4],command:[6,4],expens:5,thi:[0,2,3,4,5,6,7,8],programmingerror:4,left:5,construct:[4,8],ucbtype_replac:[6,4],clob:[0,4],unimpl:4,conform:1,edmonton:2,interrupt:2,kill:3,yet:5,previous:5,web:4,rapid:4,bfile:[0,4],ucbtype_entri:[6,4],regent:2,had:5,except:[0,1,6,5,4],valid:[0,4],blob:[0,4],input:5,subsequ:[0,5,8],applic:4,dataerror:4,march:[],around:5,format:4,read:[0,3,4,5,6,7,8],"__del__":[5,6],dismount:[6,4],five:4,keywordparamet:5,step:5,arrayvar:5,tick:4,"_error":4,insert:[5,6,4],event_dereg:4,resid:4,like:4,success:[6,4],deprec:7,safest:0,numbersasstr:5,integ:[5,4],server:[6,4,8],collect:3,api:[0,1,3,4,5,6,7,8],necessari:4,either:5,maxbytespercharact:6,bindarrays:5,output:5,buildtim:4,encount:4,makedsn:4,right:[1,2],interv:4,some:[6,4],back:[3,6,4],intern:[0,5,4,8],rowid:[6,4,8],indirect:2,librari:4,autocommit:6,scale:[5,6],implement:4,interfaceerror:4,registerqueri:8,ocistmtprepar:4,avoid:[6,4],preliminari:4,definit:[5,7,6,4],subclass:4,buffer:[5,7],substitut:2,event_startup:4,exit:[6,4],ddl:4,condit:2,now:[5,6],reproduc:2,operationalerror:4,refer:5,"11g":4,previou:5,run:[6,4],word:4,newpassword:[6,4],agreement:2,formatid:6,promot:2,offset:[0,4],outconvert:[5,7],impos:4,about:[5,4,8],pep:[5,4],actual:[5,6,4],ocistmtfetch:4,column:[0,5,6,4],materi:2,current_schema:6,rowcount:5,idl:3,internal_s:5,constructor:[6,4],commit:[6,4],produc:5,binary_doubl:4,effici:5,consid:3,"float":5,encod:6,bound:[5,7,6,4],automat:[5,3,6],unregist:6,warranti:2,empti:5,ocidefinebypo:4,contributor:2,nclob:4,manag:[5,6],lob:[0,1,4],fast:4,wai:[0,5,4,2],area:5,garbag:3,execut:[5,6,4,8],support:[5,4],iter:[0,5],"long":[5,6,4],"class":4,avail:[5,3,6,4,8],strict:2,interfac:[1,6,4],includ:[5,6,4,2,8],"var":5,fixed_unicod:4,"function":[0,5,6,4],head:1,properli:6,repeatedli:6,form:2,forc:6,handl:[1,4],forward:[5,6],paramstyl:4,"true":[6,4,8],bug:4,callproc:5,"\u215c":[1,2],made:[5,4],fncode_bindbynam:4,consist:0,possibl:[5,4,2],arrays:[5,6],notat:5,callfunc:5,maximum:[5,3,6,7],unusu:4,limit:2,minor:4,otherwis:[5,6,4,2],embed:4,expect:[5,7,6,4],trim:0,featur:6,constant:[1,6,4,8],creat:[5,3,6,4,8],pseudo:4,dure:[5,4,8],repres:4,"char":4,exist:[0,6],file:[0,4],behavior:[6,4],trip:5,fill:8,again:[5,6],password:[3,6,4],clientinfo:6,when:[0,3,4,5,6,8],detail:[6,4],invalid:4,sysop:[6,4],keywordarg:5,other:[7,6,4,2],futur:[5,4],normal:[5,6,4],cclass:4,test:6,you:[0,5,6,4],roll:[6,4],canada:2,relat:4,intend:[5,4],long_str:4,sequenc:[5,8],attr_purity_default:4,prelim_auth:[6,4],meaning:6,native_float:4,sql:[5,6,4],subscr_proto_oci:[6,4],pool:[3,4],receiv:8,longer:[0,3],algorithm:5,directori:0,descript:5,"__iter__":5,portion:0,time:[5,3,6,4],plu:[6,4]},objtypes:{"0":"py:module","1":"py:data","2":"py:method","3":"py:attribute","4":"py:function","5":"py:exception"},titles:["LOB Objects","cx_Oracle","License","SessionPool Object","Module Interface","Cursor Object","Connection Object","Variable Objects","Subscription Object"],objnames:{"0":["py","module","Python module"],"1":["py","data","Python data"],"2":["py","method","Python method"],"3":["py","attribute","Python attribute"],"4":["py","function","Python function"],"5":["py","exception","Python exception"]},filenames:["lob","index","license","session_pool","module","cursor","connection","variable","subscription"]})
\ No newline at end of file
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/html/session_pool.html b/desktop/core/ext-py/cx_Oracle-5.1.2/html/session_pool.html
new file mode 100644
index 0000000..e883cb3
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/html/session_pool.html
@@ -0,0 +1,225 @@
+
+
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
+  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+
+
+<html xmlns="http://www.w3.org/1999/xhtml">
+  <head>
+    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
+    
+    <title>SessionPool Object &mdash; cx_Oracle 5.1.2 documentation</title>
+    
+    <link rel="stylesheet" href="_static/default.css" type="text/css" />
+    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
+    
+    <script type="text/javascript">
+      var DOCUMENTATION_OPTIONS = {
+        URL_ROOT:    '',
+        VERSION:     '5.1.2',
+        COLLAPSE_INDEX: false,
+        FILE_SUFFIX: '.html',
+        HAS_SOURCE:  false
+      };
+    </script>
+    <script type="text/javascript" src="_static/jquery.js"></script>
+    <script type="text/javascript" src="_static/underscore.js"></script>
+    <script type="text/javascript" src="_static/doctools.js"></script>
+    <link rel="top" title="cx_Oracle 5.1.2 documentation" href="index.html" />
+    <link rel="next" title="Subscription Object" href="subscription.html" />
+    <link rel="prev" title="Variable Objects" href="variable.html" /> 
+  </head>
+  <body>
+    <div class="related">
+      <h3>Navigation</h3>
+      <ul>
+        <li class="right" style="margin-right: 10px">
+          <a href="genindex.html" title="General Index"
+             accesskey="I">index</a></li>
+        <li class="right" >
+          <a href="py-modindex.html" title="Python Module Index"
+             >modules</a> |</li>
+        <li class="right" >
+          <a href="subscription.html" title="Subscription Object"
+             accesskey="N">next</a> |</li>
+        <li class="right" >
+          <a href="variable.html" title="Variable Objects"
+             accesskey="P">previous</a> |</li>
+        <li><a href="index.html">cx_Oracle 5.1.2 documentation</a> &raquo;</li> 
+      </ul>
+    </div>  
+
+    <div class="document">
+      <div class="documentwrapper">
+        <div class="bodywrapper">
+          <div class="body">
+            
+  <div class="section" id="sessionpool-object">
+<span id="sesspool"></span><h1>SessionPool Object<a class="headerlink" href="#sessionpool-object" title="Permalink to this headline"></a></h1>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This object is an extension the DB API and is only available in Oracle 9i.</p>
+</div>
+<dl class="method">
+<dt id="SessionPool.acquire">
+<tt class="descclassname">SessionPool.</tt><tt class="descname">acquire</tt><big>(</big><big>)</big><a class="headerlink" href="#SessionPool.acquire" title="Permalink to this definition"></a></dt>
+<dd><p>Acquire a connection from the session pool and return a connection object
+(<a class="reference internal" href="connection.html#connobj"><em>Connection Object</em></a>).</p>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="SessionPool.busy">
+<tt class="descclassname">SessionPool.</tt><tt class="descname">busy</tt><a class="headerlink" href="#SessionPool.busy" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute returns the number of sessions currently acquired.</p>
+</dd></dl>
+
+<dl class="method">
+<dt id="SessionPool.drop">
+<tt class="descclassname">SessionPool.</tt><tt class="descname">drop</tt><big>(</big><em>connection</em><big>)</big><a class="headerlink" href="#SessionPool.drop" title="Permalink to this definition"></a></dt>
+<dd><p>Drop the connection from the pool which is useful if the connection is no
+longer usable (such as when the session is killed).</p>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="SessionPool.dsn">
+<tt class="descclassname">SessionPool.</tt><tt class="descname">dsn</tt><a class="headerlink" href="#SessionPool.dsn" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute returns the TNS entry of the database to which a
+connection has been established.</p>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="SessionPool.homogeneous">
+<tt class="descclassname">SessionPool.</tt><tt class="descname">homogeneous</tt><a class="headerlink" href="#SessionPool.homogeneous" title="Permalink to this definition"></a></dt>
+<dd><p>This read-write boolean attribute indicates whether the pool is considered
+homogeneous or not. If the pool is not homogeneous different authentication
+can be used for each connection acquired from the pool.</p>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="SessionPool.increment">
+<tt class="descclassname">SessionPool.</tt><tt class="descname">increment</tt><a class="headerlink" href="#SessionPool.increment" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute returns the number of sessions that will be
+established when additional sessions need to be created.</p>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="SessionPool.max">
+<tt class="descclassname">SessionPool.</tt><tt class="descname">max</tt><a class="headerlink" href="#SessionPool.max" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute returns the maximum number of sessions that the
+session pool can control.</p>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="SessionPool.min">
+<tt class="descclassname">SessionPool.</tt><tt class="descname">min</tt><a class="headerlink" href="#SessionPool.min" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute returns the number of sessions with which the
+session pool was created and the minimum number of sessions that will be
+controlled by the session pool.</p>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="SessionPool.name">
+<tt class="descclassname">SessionPool.</tt><tt class="descname">name</tt><a class="headerlink" href="#SessionPool.name" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute returns the name assigned to the session pool by
+Oracle.</p>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="SessionPool.opened">
+<tt class="descclassname">SessionPool.</tt><tt class="descname">opened</tt><a class="headerlink" href="#SessionPool.opened" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute returns the number of sessions currently opened by
+the session pool.</p>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="SessionPool.password">
+<tt class="descclassname">SessionPool.</tt><tt class="descname">password</tt><a class="headerlink" href="#SessionPool.password" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute returns the password of the user which established
+the connection to the database.</p>
+</dd></dl>
+
+<dl class="method">
+<dt id="SessionPool.release">
+<tt class="descclassname">SessionPool.</tt><tt class="descname">release</tt><big>(</big><em>connection</em><big>)</big><a class="headerlink" href="#SessionPool.release" title="Permalink to this definition"></a></dt>
+<dd><p>Release the connection back to the pool. This will be done automatically as
+well if the connection object is garbage collected.</p>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="SessionPool.timeout">
+<tt class="descclassname">SessionPool.</tt><tt class="descname">timeout</tt><a class="headerlink" href="#SessionPool.timeout" title="Permalink to this definition"></a></dt>
+<dd><p>This read-write attribute indicates the time (in seconds) after which idle
+sessions will be terminated in order to maintain an optimum number of open
+sessions.</p>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="SessionPool.tnsentry">
+<tt class="descclassname">SessionPool.</tt><tt class="descname">tnsentry</tt><a class="headerlink" href="#SessionPool.tnsentry" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute returns the TNS entry of the database to which a
+connection has been established.</p>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="SessionPool.username">
+<tt class="descclassname">SessionPool.</tt><tt class="descname">username</tt><a class="headerlink" href="#SessionPool.username" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute returns the name of the user which established the
+connection to the database.</p>
+</dd></dl>
+
+</div>
+
+
+          </div>
+        </div>
+      </div>
+      <div class="sphinxsidebar">
+        <div class="sphinxsidebarwrapper">
+  <h4>Previous topic</h4>
+  <p class="topless"><a href="variable.html"
+                        title="previous chapter">Variable Objects</a></p>
+  <h4>Next topic</h4>
+  <p class="topless"><a href="subscription.html"
+                        title="next chapter">Subscription Object</a></p>
+<div id="searchbox" style="display: none">
+  <h3>Quick search</h3>
+    <form class="search" action="search.html" method="get">
+      <input type="text" name="q" />
+      <input type="submit" value="Go" />
+      <input type="hidden" name="check_keywords" value="yes" />
+      <input type="hidden" name="area" value="default" />
+    </form>
+    <p class="searchtip" style="font-size: 90%">
+    Enter search terms or a module, class or function name.
+    </p>
+</div>
+<script type="text/javascript">$('#searchbox').show(0);</script>
+        </div>
+      </div>
+      <div class="clearer"></div>
+    </div>
+    <div class="related">
+      <h3>Navigation</h3>
+      <ul>
+        <li class="right" style="margin-right: 10px">
+          <a href="genindex.html" title="General Index"
+             >index</a></li>
+        <li class="right" >
+          <a href="py-modindex.html" title="Python Module Index"
+             >modules</a> |</li>
+        <li class="right" >
+          <a href="subscription.html" title="Subscription Object"
+             >next</a> |</li>
+        <li class="right" >
+          <a href="variable.html" title="Variable Objects"
+             >previous</a> |</li>
+        <li><a href="index.html">cx_Oracle 5.1.2 documentation</a> &raquo;</li> 
+      </ul>
+    </div>
+    <div class="footer">
+        &copy; Copyright 2012, Anthony Tuininga.
+      Last updated on Jul 02, 2012.
+      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
+    </div>
+  </body>
+</html>
\ No newline at end of file
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/html/subscription.html b/desktop/core/ext-py/cx_Oracle-5.1.2/html/subscription.html
new file mode 100644
index 0000000..7cd9fd2
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/html/subscription.html
@@ -0,0 +1,276 @@
+
+
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
+  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+
+
+<html xmlns="http://www.w3.org/1999/xhtml">
+  <head>
+    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
+    
+    <title>Subscription Object &mdash; cx_Oracle 5.1.2 documentation</title>
+    
+    <link rel="stylesheet" href="_static/default.css" type="text/css" />
+    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
+    
+    <script type="text/javascript">
+      var DOCUMENTATION_OPTIONS = {
+        URL_ROOT:    '',
+        VERSION:     '5.1.2',
+        COLLAPSE_INDEX: false,
+        FILE_SUFFIX: '.html',
+        HAS_SOURCE:  false
+      };
+    </script>
+    <script type="text/javascript" src="_static/jquery.js"></script>
+    <script type="text/javascript" src="_static/underscore.js"></script>
+    <script type="text/javascript" src="_static/doctools.js"></script>
+    <link rel="top" title="cx_Oracle 5.1.2 documentation" href="index.html" />
+    <link rel="next" title="LOB Objects" href="lob.html" />
+    <link rel="prev" title="SessionPool Object" href="session_pool.html" /> 
+  </head>
+  <body>
+    <div class="related">
+      <h3>Navigation</h3>
+      <ul>
+        <li class="right" style="margin-right: 10px">
+          <a href="genindex.html" title="General Index"
+             accesskey="I">index</a></li>
+        <li class="right" >
+          <a href="py-modindex.html" title="Python Module Index"
+             >modules</a> |</li>
+        <li class="right" >
+          <a href="lob.html" title="LOB Objects"
+             accesskey="N">next</a> |</li>
+        <li class="right" >
+          <a href="session_pool.html" title="SessionPool Object"
+             accesskey="P">previous</a> |</li>
+        <li><a href="index.html">cx_Oracle 5.1.2 documentation</a> &raquo;</li> 
+      </ul>
+    </div>  
+
+    <div class="document">
+      <div class="documentwrapper">
+        <div class="bodywrapper">
+          <div class="body">
+            
+  <div class="section" id="subscription-object">
+<span id="subscrobj"></span><h1>Subscription Object<a class="headerlink" href="#subscription-object" title="Permalink to this headline"></a></h1>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This object is an extension the DB API and is only available in Oracle 10g
+Release 2 and higher.</p>
+</div>
+<dl class="attribute">
+<dt id="Subscription.callback">
+<tt class="descclassname">Subscription.</tt><tt class="descname">callback</tt><a class="headerlink" href="#Subscription.callback" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute returns the callback that was registered when the
+subscription was created.</p>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Subscription.connection">
+<tt class="descclassname">Subscription.</tt><tt class="descname">connection</tt><a class="headerlink" href="#Subscription.connection" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute returns the connection that was used to register
+the subscription when it was created.</p>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Subscription.namespace">
+<tt class="descclassname">Subscription.</tt><tt class="descname">namespace</tt><a class="headerlink" href="#Subscription.namespace" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute returns the namespace used to register the
+subscription when it was created.</p>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Subscription.operations">
+<tt class="descclassname">Subscription.</tt><tt class="descname">operations</tt><a class="headerlink" href="#Subscription.operations" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute returns the operations that will send notifications
+for each table that is registered using this subscription.</p>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Subscription.port">
+<tt class="descclassname">Subscription.</tt><tt class="descname">port</tt><a class="headerlink" href="#Subscription.port" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute returns the port used for callback notifications
+from the database server. If not set during construction, this value is
+zero.</p>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Subscription.protocol">
+<tt class="descclassname">Subscription.</tt><tt class="descname">protocol</tt><a class="headerlink" href="#Subscription.protocol" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute returns the protocol used to register the
+subscription when it was created.</p>
+</dd></dl>
+
+<dl class="method">
+<dt id="Subscription.registerquery">
+<tt class="descclassname">Subscription.</tt><tt class="descname">registerquery</tt><big>(</big><em>statement</em><span class="optional">[</span>, <em>args</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#Subscription.registerquery" title="Permalink to this definition"></a></dt>
+<dd><p>Register the query for subsequent notification when tables referenced by the
+query are changed. This behaves similarly to cursor.execute() but only
+queries are permitted and the arguments must be a sequence or dictionary.</p>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Subscription.rowids">
+<tt class="descclassname">Subscription.</tt><tt class="descname">rowids</tt><a class="headerlink" href="#Subscription.rowids" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute returns True or False specifying if rowids will be
+included in notifications sent using this subscription.</p>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Subscription.timeout">
+<tt class="descclassname">Subscription.</tt><tt class="descname">timeout</tt><a class="headerlink" href="#Subscription.timeout" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute returns the timeout (in seconds) used to register
+the subscription when it was created. A timeout value of 0 indicates that
+there is no timeout.</p>
+</dd></dl>
+
+<div class="section" id="message-objects">
+<h2>Message Objects<a class="headerlink" href="#message-objects" title="Permalink to this headline"></a></h2>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This object is created internally when notification is received and passed
+to the callback procedure specified when a subscription is created.</p>
+</div>
+<dl class="attribute">
+<dt id="Message.dbname">
+<tt class="descclassname">Message.</tt><tt class="descname">dbname</tt><a class="headerlink" href="#Message.dbname" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute returns the name of the database that generated the
+notification.</p>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Message.tables">
+<tt class="descclassname">Message.</tt><tt class="descname">tables</tt><a class="headerlink" href="#Message.tables" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute returns a list of message table objects that give
+information about the tables changed for this notification.</p>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Message.type">
+<tt class="descclassname">Message.</tt><tt class="descname">type</tt><a class="headerlink" href="#Message.type" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute returns the type of message that has been sent.
+See the constants section on database change notification for additional
+information.</p>
+</dd></dl>
+
+</div>
+<div class="section" id="message-table-objects">
+<h2>Message Table Objects<a class="headerlink" href="#message-table-objects" title="Permalink to this headline"></a></h2>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This object is created internally for each table changed when notification
+is received and is found in the tables attribute of message objects.</p>
+</div>
+<dl class="attribute">
+<dt id="MessageTable.name">
+<tt class="descclassname">MessageTable.</tt><tt class="descname">name</tt><a class="headerlink" href="#MessageTable.name" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute returns the name of the table that was changed.</p>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="MessageTable.operation">
+<tt class="descclassname">MessageTable.</tt><tt class="descname">operation</tt><a class="headerlink" href="#MessageTable.operation" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute returns the operation that took place on the table
+that was changed.</p>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="MessageTable.rows">
+<tt class="descclassname">MessageTable.</tt><tt class="descname">rows</tt><a class="headerlink" href="#MessageTable.rows" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute returns a list of message row objects that give
+information about the rows changed on the table. This value is only filled
+in if the rowids argument to the Connection.subscribe() method is True.</p>
+</dd></dl>
+
+</div>
+<div class="section" id="message-row-objects">
+<h2>Message Row Objects<a class="headerlink" href="#message-row-objects" title="Permalink to this headline"></a></h2>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This object is created internally for each row changed on a table when
+notification is received and is found in the rows attribute of message table
+objects.</p>
+</div>
+<dl class="attribute">
+<dt id="MessageRow.operation">
+<tt class="descclassname">MessageRow.</tt><tt class="descname">operation</tt><a class="headerlink" href="#MessageRow.operation" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute returns the operation that took place on the row
+that was changed.</p>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="MessageRow.rowid">
+<tt class="descclassname">MessageRow.</tt><tt class="descname">rowid</tt><a class="headerlink" href="#MessageRow.rowid" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute returns the rowid of the row that was changed.</p>
+</dd></dl>
+
+</div>
+</div>
+
+
+          </div>
+        </div>
+      </div>
+      <div class="sphinxsidebar">
+        <div class="sphinxsidebarwrapper">
+  <h3><a href="index.html">Table Of Contents</a></h3>
+  <ul>
+<li><a class="reference internal" href="#">Subscription Object</a><ul>
+<li><a class="reference internal" href="#message-objects">Message Objects</a></li>
+<li><a class="reference internal" href="#message-table-objects">Message Table Objects</a></li>
+<li><a class="reference internal" href="#message-row-objects">Message Row Objects</a></li>
+</ul>
+</li>
+</ul>
+
+  <h4>Previous topic</h4>
+  <p class="topless"><a href="session_pool.html"
+                        title="previous chapter">SessionPool Object</a></p>
+  <h4>Next topic</h4>
+  <p class="topless"><a href="lob.html"
+                        title="next chapter">LOB Objects</a></p>
+<div id="searchbox" style="display: none">
+  <h3>Quick search</h3>
+    <form class="search" action="search.html" method="get">
+      <input type="text" name="q" />
+      <input type="submit" value="Go" />
+      <input type="hidden" name="check_keywords" value="yes" />
+      <input type="hidden" name="area" value="default" />
+    </form>
+    <p class="searchtip" style="font-size: 90%">
+    Enter search terms or a module, class or function name.
+    </p>
+</div>
+<script type="text/javascript">$('#searchbox').show(0);</script>
+        </div>
+      </div>
+      <div class="clearer"></div>
+    </div>
+    <div class="related">
+      <h3>Navigation</h3>
+      <ul>
+        <li class="right" style="margin-right: 10px">
+          <a href="genindex.html" title="General Index"
+             >index</a></li>
+        <li class="right" >
+          <a href="py-modindex.html" title="Python Module Index"
+             >modules</a> |</li>
+        <li class="right" >
+          <a href="lob.html" title="LOB Objects"
+             >next</a> |</li>
+        <li class="right" >
+          <a href="session_pool.html" title="SessionPool Object"
+             >previous</a> |</li>
+        <li><a href="index.html">cx_Oracle 5.1.2 documentation</a> &raquo;</li> 
+      </ul>
+    </div>
+    <div class="footer">
+        &copy; Copyright 2012, Anthony Tuininga.
+      Last updated on Jul 02, 2012.
+      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
+    </div>
+  </body>
+</html>
\ No newline at end of file
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/html/variable.html b/desktop/core/ext-py/cx_Oracle-5.1.2/html/variable.html
new file mode 100644
index 0000000..2896704
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/html/variable.html
@@ -0,0 +1,192 @@
+
+
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
+  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+
+
+<html xmlns="http://www.w3.org/1999/xhtml">
+  <head>
+    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
+    
+    <title>Variable Objects &mdash; cx_Oracle 5.1.2 documentation</title>
+    
+    <link rel="stylesheet" href="_static/default.css" type="text/css" />
+    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
+    
+    <script type="text/javascript">
+      var DOCUMENTATION_OPTIONS = {
+        URL_ROOT:    '',
+        VERSION:     '5.1.2',
+        COLLAPSE_INDEX: false,
+        FILE_SUFFIX: '.html',
+        HAS_SOURCE:  false
+      };
+    </script>
+    <script type="text/javascript" src="_static/jquery.js"></script>
+    <script type="text/javascript" src="_static/underscore.js"></script>
+    <script type="text/javascript" src="_static/doctools.js"></script>
+    <link rel="top" title="cx_Oracle 5.1.2 documentation" href="index.html" />
+    <link rel="next" title="SessionPool Object" href="session_pool.html" />
+    <link rel="prev" title="Cursor Object" href="cursor.html" /> 
+  </head>
+  <body>
+    <div class="related">
+      <h3>Navigation</h3>
+      <ul>
+        <li class="right" style="margin-right: 10px">
+          <a href="genindex.html" title="General Index"
+             accesskey="I">index</a></li>
+        <li class="right" >
+          <a href="py-modindex.html" title="Python Module Index"
+             >modules</a> |</li>
+        <li class="right" >
+          <a href="session_pool.html" title="SessionPool Object"
+             accesskey="N">next</a> |</li>
+        <li class="right" >
+          <a href="cursor.html" title="Cursor Object"
+             accesskey="P">previous</a> |</li>
+        <li><a href="index.html">cx_Oracle 5.1.2 documentation</a> &raquo;</li> 
+      </ul>
+    </div>  
+
+    <div class="document">
+      <div class="documentwrapper">
+        <div class="bodywrapper">
+          <div class="body">
+            
+  <div class="section" id="variable-objects">
+<span id="varobj"></span><h1>Variable Objects<a class="headerlink" href="#variable-objects" title="Permalink to this headline"></a></h1>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">The DB API definition does not define this object.</p>
+</div>
+<dl class="attribute">
+<dt id="Variable.allocelems">
+<tt class="descclassname">Variable.</tt><tt class="descname">allocelems</tt><a class="headerlink" href="#Variable.allocelems" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute returns the number of elements allocated in an
+array, or the number of scalar items that can be fetched into the variable.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This attribute is deprecated. Use attribute numElements instead.</p>
+</div>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Variable.bufferSize">
+<tt class="descclassname">Variable.</tt><tt class="descname">bufferSize</tt><a class="headerlink" href="#Variable.bufferSize" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute returns the size of the buffer allocated for each
+element in bytes.</p>
+</dd></dl>
+
+<dl class="method">
+<dt id="Variable.getvalue">
+<tt class="descclassname">Variable.</tt><tt class="descname">getvalue</tt><big>(</big><span class="optional">[</span><em>pos=0</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#Variable.getvalue" title="Permalink to this definition"></a></dt>
+<dd><p>Return the value at the given position in the variable.</p>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Variable.inconverter">
+<tt class="descclassname">Variable.</tt><tt class="descname">inconverter</tt><a class="headerlink" href="#Variable.inconverter" title="Permalink to this definition"></a></dt>
+<dd><p>This read-write attribute specifies the method used to convert data from
+Python to the Oracle database. The method signature is converter(value)
+and the expected return value is the value to bind to the database. If this
+attribute is None, the value is bound directly without any conversion.</p>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Variable.numElements">
+<tt class="descclassname">Variable.</tt><tt class="descname">numElements</tt><a class="headerlink" href="#Variable.numElements" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute returns the number of elements allocated in an
+array, or the number of scalar items that can be fetched into the variable
+or bound to the variable.</p>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Variable.maxlength">
+<tt class="descclassname">Variable.</tt><tt class="descname">maxlength</tt><a class="headerlink" href="#Variable.maxlength" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute returns the maximum length of the variable.</p>
+<div class="admonition note">
+<p class="first admonition-title">Note</p>
+<p class="last">This attribute is deprecated. Use attribute bufferSize instead.</p>
+</div>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Variable.outconverter">
+<tt class="descclassname">Variable.</tt><tt class="descname">outconverter</tt><a class="headerlink" href="#Variable.outconverter" title="Permalink to this definition"></a></dt>
+<dd><p>This read-write attribute specifies the method used to convert data from
+from the Oracle to Python. The method signature is converter(value)
+and the expected return value is the value to return to Python. If this
+attribute is None, the value is returned directly without any conversion.</p>
+</dd></dl>
+
+<dl class="method">
+<dt id="Variable.setvalue">
+<tt class="descclassname">Variable.</tt><tt class="descname">setvalue</tt><big>(</big><em>pos</em>, <em>value</em><big>)</big><a class="headerlink" href="#Variable.setvalue" title="Permalink to this definition"></a></dt>
+<dd><p>Set the value at the given position in the variable.</p>
+</dd></dl>
+
+<dl class="attribute">
+<dt id="Variable.size">
+<tt class="descclassname">Variable.</tt><tt class="descname">size</tt><a class="headerlink" href="#Variable.size" title="Permalink to this definition"></a></dt>
+<dd><p>This read-only attribute returns the size of the variable. For strings this
+value is the size in characters. For all others, this is same value as the
+attribute bufferSize.</p>
+</dd></dl>
+
+</div>
+
+
+          </div>
+        </div>
+      </div>
+      <div class="sphinxsidebar">
+        <div class="sphinxsidebarwrapper">
+  <h4>Previous topic</h4>
+  <p class="topless"><a href="cursor.html"
+                        title="previous chapter">Cursor Object</a></p>
+  <h4>Next topic</h4>
+  <p class="topless"><a href="session_pool.html"
+                        title="next chapter">SessionPool Object</a></p>
+<div id="searchbox" style="display: none">
+  <h3>Quick search</h3>
+    <form class="search" action="search.html" method="get">
+      <input type="text" name="q" />
+      <input type="submit" value="Go" />
+      <input type="hidden" name="check_keywords" value="yes" />
+      <input type="hidden" name="area" value="default" />
+    </form>
+    <p class="searchtip" style="font-size: 90%">
+    Enter search terms or a module, class or function name.
+    </p>
+</div>
+<script type="text/javascript">$('#searchbox').show(0);</script>
+        </div>
+      </div>
+      <div class="clearer"></div>
+    </div>
+    <div class="related">
+      <h3>Navigation</h3>
+      <ul>
+        <li class="right" style="margin-right: 10px">
+          <a href="genindex.html" title="General Index"
+             >index</a></li>
+        <li class="right" >
+          <a href="py-modindex.html" title="Python Module Index"
+             >modules</a> |</li>
+        <li class="right" >
+          <a href="session_pool.html" title="SessionPool Object"
+             >next</a> |</li>
+        <li class="right" >
+          <a href="cursor.html" title="Cursor Object"
+             >previous</a> |</li>
+        <li><a href="index.html">cx_Oracle 5.1.2 documentation</a> &raquo;</li> 
+      </ul>
+    </div>
+    <div class="footer">
+        &copy; Copyright 2012, Anthony Tuininga.
+      Last updated on Jul 02, 2012.
+      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
+    </div>
+  </body>
+</html>
\ No newline at end of file
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/samples/DatabaseChangeNotification.py b/desktop/core/ext-py/cx_Oracle-5.1.2/samples/DatabaseChangeNotification.py
new file mode 100644
index 0000000..c7332a3
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/samples/DatabaseChangeNotification.py
@@ -0,0 +1,42 @@
+#------------------------------------------------------------------------------
+# DatabaseChangeNotification.py
+#   This script demonstrates using database change notification in Python, a
+# feature that is available in Oracle 10g Release 2. Once this script is
+# running, use another session to insert, update or delete rows from the table
+# cx_Oracle.TestExecuteMany and you will see the notification of that change.
+#------------------------------------------------------------------------------
+
+import cx_Oracle
+import time
+
+def callback(message):
+    print "Message type:", message.type
+    print "Message database name:", message.dbname
+    print "Message tables:"
+    for table in message.tables:
+        print "--> Table Name:", table.name
+        print "--> Table Operation:", table.operation
+        if table.rows is not None:
+            print "--> Table Rows:"
+            for row in table.rows:
+                print "--> --> Row RowId:", row.rowid
+                print "--> --> Row Operation:", row.operation
+                print "-" * 60
+        print "=" * 60
+
+connection = cx_Oracle.Connection("cx_Oracle/password", events = True)
+sub = connection.subscribe(callback = callback, timeout = 1800, rowids = True)
+print "Subscription:", sub
+print "--> Connection:", sub.connection
+print "--> Callback:", sub.callback
+print "--> Namespace:", sub.namespace
+print "--> Protocol:", sub.protocol
+print "--> Timeout:", sub.timeout
+print "--> Operations:", sub.operations
+print "--> Rowids?:", sub.rowids
+sub.registerquery("select * from TestExecuteMany")
+
+while True:
+    print "Waiting for notifications...."
+    time.sleep(5)
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/samples/DatabaseShutdown.py b/desktop/core/ext-py/cx_Oracle-5.1.2/samples/DatabaseShutdown.py
new file mode 100644
index 0000000..d40b728
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/samples/DatabaseShutdown.py
@@ -0,0 +1,24 @@
+#------------------------------------------------------------------------------
+# DatabaseShutdown.py
+#   This script demonstrates shutting down a database using Python. It is only
+# possible in Oracle 10g Release 2 and higher. The connection used assumes that
+# the environment variable ORACLE_SID has been set.
+#------------------------------------------------------------------------------
+
+import cx_Oracle
+
+# need to connect as SYSDBA or SYSOPER
+connection = cx_Oracle.connect("/", mode = cx_Oracle.SYSDBA)
+
+# first shutdown() call must specify the mode, if DBSHUTDOWN_ABORT is used,
+# there is no need for any of the other steps
+connection.shutdown(mode = cx_Oracle.DBSHUTDOWN_IMMEDIATE)
+
+# now close and dismount the database
+cursor = connection.cursor()
+cursor.execute("alter database close normal")
+cursor.execute("alter database dismount")
+
+# perform the final shutdown call
+connection.shutdown(mode = cx_Oracle.DBSHUTDOWN_FINAL)
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/samples/DatabaseStartup.py b/desktop/core/ext-py/cx_Oracle-5.1.2/samples/DatabaseStartup.py
new file mode 100644
index 0000000..e22efd8
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/samples/DatabaseStartup.py
@@ -0,0 +1,20 @@
+#------------------------------------------------------------------------------
+# DatabaseStartup.py
+#   This script demonstrates starting up a database using Python. It is only
+# possible in Oracle 10g Release 2 and higher. The connection used assumes that
+# the environment variable ORACLE_SID has been set.
+#------------------------------------------------------------------------------
+
+import cx_Oracle
+
+# the connection must be in PRELIM_AUTH mode
+connection = cx_Oracle.connect("/",
+        mode = cx_Oracle.SYSDBA | cx_Oracle.PRELIM_AUTH)
+connection.startup()
+
+# the following statements must be issued in normal SYSDBA mode
+connection = cx_Oracle.connect("/", mode = cx_Oracle.SYSDBA)
+cursor = connection.cursor()
+cursor.execute("alter database mount")
+cursor.execute("alter database open")
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/samples/ReturnLongs.py b/desktop/core/ext-py/cx_Oracle-5.1.2/samples/ReturnLongs.py
new file mode 100644
index 0000000..722e99b
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/samples/ReturnLongs.py
@@ -0,0 +1,41 @@
+#------------------------------------------------------------------------------
+# ReturnLongs.py
+#   Returns all CLOB values as long strings and BLOB values as long raws. This
+# is only useful if the lengths of the CLOB and BLOB values are well known but
+# it can improve performance because there is no need to return to the database
+# to get the actual values.
+#------------------------------------------------------------------------------
+
+import cx_Oracle
+
+def OutputTypeHandler(cursor, name, defaultType, size, precision, scale):
+    if defaultType == cx_Oracle.CLOB:
+        return cursor.var(cx_Oracle.LONG_STRING, 80000, cursor.arraysize)
+    if defaultType == cx_Oracle.BLOB:
+        return cursor.var(cx_Oracle.LONG_BINARY, 100004, cursor.arraysize)
+
+connection = cx_Oracle.Connection("cx_Oracle/password")
+connection.outputtypehandler = OutputTypeHandler
+cursor = connection.cursor()
+print "CLOBS returned as longs"
+cursor.execute("""
+        select
+          IntCol,
+          ClobCol
+        from TestClobs
+        where dbms_lob.getlength(ClobCol) <= 80000
+        order by IntCol""")
+for intCol, value in cursor:
+    print "Row:", intCol, "string of length", len(value)
+print
+print "BLOBS returned as longs"
+cursor.execute("""
+        select
+          IntCol,
+          BlobCol
+        from TestBlobs
+        where dbms_lob.getlength(BlobCol) <= 100000
+        order by IntCol""")
+for intCol, value in cursor:
+    print "Row:", intCol, "string of length", value and len(value) or 0
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/samples/ReturnUnicode.py b/desktop/core/ext-py/cx_Oracle-5.1.2/samples/ReturnUnicode.py
new file mode 100644
index 0000000..ecaca3a
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/samples/ReturnUnicode.py
@@ -0,0 +1,19 @@
+#------------------------------------------------------------------------------
+# ReturnUnicode.py
+#   Returns all strings as unicode. This also demonstrates the use of an output
+# type handler to change the way in which data is returned from a cursor.
+#------------------------------------------------------------------------------
+
+import cx_Oracle
+
+def OutputTypeHandler(cursor, name, defaultType, size, precision, scale):
+    if defaultType in (cx_Oracle.STRING, cx_Oracle.FIXED_CHAR):
+        return cursor.var(unicode, size, cursor.arraysize)
+
+connection = cx_Oracle.Connection("cx_Oracle/password")
+connection.outputtypehandler = OutputTypeHandler
+cursor = connection.cursor()
+cursor.execute("select * from teststrings")
+for row in cursor:
+    print "Row:", row
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/samples/RowsAsInstance.py b/desktop/core/ext-py/cx_Oracle-5.1.2/samples/RowsAsInstance.py
new file mode 100644
index 0000000..9af112c
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/samples/RowsAsInstance.py
@@ -0,0 +1,39 @@
+#------------------------------------------------------------------------------
+# RowsAsInstance.py
+#   Returns rows as instances instead of tuples. See the ceDatabase.Row class
+# in the cx_PyGenLib project (http://cx-pygenlib.sourceforge.net) for a more
+# advanced example.
+#------------------------------------------------------------------------------
+
+import cx_Oracle
+
+class Test(object):
+
+    def __init__(self, a, b, c):
+        self.a = a
+        self.b = b
+        self.c = c
+
+connection = cx_Oracle.Connection("cx_Oracle/password")
+cursor = connection.cursor()
+
+# change this to True if you want to create the table, or create it using
+# SQL*Plus instead; populate it with the data of your choice
+if False:
+    cursor.execute("""
+            create table TestInstances (
+              a varchar2(60) not null,
+              b number(9) not null,
+              c date not null
+            )""")
+    cursor.execute("insert into TestInstances values ('First', 5, sysdate)")
+    cursor.execute("insert into TestInstances values ('Second', 25, sysdate)")
+    connection.commit()
+
+# retrieve the data and display it
+cursor.execute("select * from TestInstances")
+cursor.rowfactory = Test
+print "Rows:"
+for row in cursor:
+    print "a = %s, b = %s, c = %s" % (row.a, row.b, row.c)
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/setup.py b/desktop/core/ext-py/cx_Oracle-5.1.2/setup.py
new file mode 100644
index 0000000..63a1459
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/setup.py
@@ -0,0 +1,351 @@
+"""Distutils script for cx_Oracle.
+
+Windows platforms:
+    python setup.py build --compiler=mingw32 install
+
+Unix platforms
+    python setup.py build install
+
+"""
+
+import distutils.command
+try:
+    import distutils.command.bdist_msi
+except ImportError:
+    distutils.command.bdist_msi = None
+try:
+    import distutils.command.bdist_wininst
+except ImportError:
+    distutils.command.bdist_wininst = None
+import distutils.command.bdist_rpm
+import distutils.command.build
+import distutils.core
+import distutils.dist
+import distutils.util
+import os
+import re
+import struct
+import sys
+
+from distutils.errors import DistutilsSetupError
+
+# if setuptools is detected, use it to add support for eggs
+try:
+    from setuptools import setup, Extension
+except:
+    from distutils.core import setup
+    from distutils.extension import Extension
+
+# define build constants
+BUILD_VERSION = "5.1.2"
+
+# define the list of files to be included as documentation for Windows
+dataFiles = None
+if sys.platform in ("win32", "cygwin"):
+    baseName = "cx_Oracle-doc"
+    dataFiles = [ (baseName,
+            [ "BUILD.txt", "LICENSE.TXT", "README.TXT", "HISTORY.txt"]) ]
+    for dir in ("html", "html/_static", "samples", "test"):
+        files = []
+        fullDirName = "%s/%s" % (baseName, dir)
+        for name in os.listdir(dir):
+            if name.startswith("."):
+                continue
+            if os.path.isdir(os.path.join(dir, name)):
+                continue
+            fullName = "%s/%s" % (dir, name)
+            files.append(fullName)
+        dataFiles.append((fullDirName, files))
+
+# define the list of files to be included as documentation for bdist_rpm
+docFiles = "LICENSE.txt README.txt BUILD.txt HISTORY.txt html samples test"
+
+# method for checking a potential Oracle home
+def CheckOracleHome(directoryToCheck):
+    global oracleHome, oracleVersion, oracleLibDir
+    import os
+    import struct
+    import sys
+    if sys.platform in ("win32", "cygwin"):
+        subDirs = ["bin"]
+        filesToCheck = [
+                ("11g", "oraocci11.dll"),
+                ("10g", "oraocci10.dll"),
+                ("9i", "oraclient9.dll")
+        ]
+    elif sys.platform == "darwin":
+        subDirs = ["lib"]
+        filesToCheck = [
+                ("11g", "libclntsh.dylib.11.1"),
+                ("10g", "libclntsh.dylib.10.1"),
+                ("9i", "libclntsh.dylib.9.0")
+        ]
+    else:
+        if struct.calcsize("P") == 4:
+            subDirs = ["lib", "lib32"]
+        else:
+            subDirs = ["lib", "lib64"]
+        filesToCheck = [
+                ("11g", "libclntsh.so.11.1"),
+                ("10g", "libclntsh.so.10.1"),
+                ("9i", "libclntsh.so.9.0")
+        ]
+    for version, baseFileName in filesToCheck:
+        fileName = os.path.join(directoryToCheck, baseFileName)
+        if os.path.exists(fileName):
+            if os.path.basename(directoryToCheck).lower() == "bin":
+                oracleHome = os.path.dirname(directoryToCheck)
+            else:
+                oracleHome = directoryToCheck
+            oracleLibDir = directoryToCheck
+            oracleVersion = version
+            return True
+        for subDir in subDirs:
+            fileName = os.path.join(directoryToCheck, subDir, baseFileName)
+            if os.path.exists(fileName):
+                oracleHome = directoryToCheck
+                oracleLibDir = os.path.join(directoryToCheck, subDir)
+                oracleVersion = version
+                return True
+            dirName = os.path.dirname(directoryToCheck)
+            fileName = os.path.join(dirName, subDir, baseFileName)
+            if os.path.exists(fileName):
+                oracleHome = dirName
+                oracleLibDir = os.path.join(dirName, subDir)
+                oracleVersion = version
+                return True
+    oracleHome = oracleVersion = oracleLibDir = None
+    return False
+
+# try to determine the Oracle home
+userOracleHome = os.environ.get("ORACLE_HOME")
+if userOracleHome is not None:
+    if not CheckOracleHome(userOracleHome):
+        messageFormat = "Oracle home (%s) does not refer to an " \
+                "9i, 10g or 11g installation."
+        raise DistutilsSetupError(messageFormat % userOracleHome)
+else:
+    for path in os.environ["PATH"].split(os.pathsep):
+        if CheckOracleHome(path):
+            break
+    if oracleHome is None:
+        raise DistutilsSetupError("cannot locate an Oracle software " \
+                "installation")
+
+# define some variables
+if sys.platform == "win32":
+    libDirs = [os.path.join(oracleHome, "bin"), oracleHome,
+            os.path.join(oracleHome, "oci", "lib", "msvc"),
+            os.path.join(oracleHome, "sdk", "lib", "msvc")]
+    possibleIncludeDirs = ["oci/include", "rdbms/demo", "sdk/include"]
+    includeDirs = []
+    for dir in possibleIncludeDirs:
+        path = os.path.normpath(os.path.join(oracleHome, dir))
+        if os.path.isdir(path):
+            includeDirs.append(path)
+    if not includeDirs:
+        message = "cannot locate Oracle include files in %s" % oracleHome
+        raise DistutilsSetupError(message)
+    libs = ["oci"]
+elif sys.platform == "cygwin":
+    includeDirs = ["/usr/include", "rdbms/demo", "rdbms/public", \
+            "network/public", "oci/include"]
+    libDirs = ["bin", "lib"]
+    for i in range(len(includeDirs)):
+        includeDirs[i] = os.path.join(oracleHome, includeDirs[i])
+    for i in range(len(libDirs)):
+        libDirs[i] = os.path.join(oracleHome, libDirs[i])
+    libs = ["oci"]
+else:
+    libDirs = [oracleLibDir]
+    libs = ["clntsh"]
+    possibleIncludeDirs = ["rdbms/demo", "rdbms/public", "network/public",
+            "sdk/include"]
+    if sys.platform == "darwin":
+        possibleIncludeDirs.append("plsql/public")
+    includeDirs = []
+    for dir in possibleIncludeDirs:
+        path = os.path.join(oracleHome, dir)
+        if os.path.isdir(path):
+            includeDirs.append(path)
+    if not includeDirs:
+        path = os.path.join(oracleLibDir, "include")
+        if os.path.isdir(path):
+            includeDirs.append(path)
+    if not includeDirs:
+        path = re.sub("lib(64)?", "include", oracleHome)
+        if os.path.isdir(path):
+            includeDirs.append(path)
+    if not includeDirs:
+        raise DistutilsSetupError("cannot locate Oracle include files")
+
+# NOTE: on HP-UX Itanium with Oracle 10g you need to add the library "ttsh10"
+# to the list of libraries along with "clntsh"; since I am unable to test, I'll
+# leave this as a comment until someone can verify when this is required
+# without making other cases where sys.platform == "hp-ux11" stop working
+
+# setup extra link and compile args
+extraCompileArgs = ["-DBUILD_VERSION=%s" % BUILD_VERSION]
+extraLinkArgs = []
+if sys.platform == "aix4":
+    extraCompileArgs.append("-qcpluscmt")
+elif sys.platform == "aix5":
+    extraCompileArgs.append("-DAIX5")
+elif sys.platform == "cygwin":
+    extraCompileArgs.append("-mno-cygwin")
+    extraLinkArgs.append("-Wl,--enable-runtime-pseudo-reloc")
+elif sys.platform == "darwin":
+    extraLinkArgs.append("-shared-libgcc")
+
+# force the inclusion of an RPATH linker directive if desired; this will
+# eliminate the need for setting LD_LIBRARY_PATH but it also means that this
+# location will be the only location searched for the Oracle client library
+if "FORCE_RPATH" in os.environ:
+    extraLinkArgs.append("-Wl,-rpath,%s" % oracleLibDir)
+
+# tweak distribution full name to include the Oracle version
+class Distribution(distutils.dist.Distribution):
+
+    def get_fullname_with_oracle_version(self):
+        name = self.metadata.get_fullname()
+        return "%s-%s" % (name, oracleVersion)
+
+
+# tweak the RPM build command to include the Python and Oracle version
+class bdist_rpm(distutils.command.bdist_rpm.bdist_rpm):
+
+    def run(self):
+        distutils.command.bdist_rpm.bdist_rpm.run(self)
+        specFile = os.path.join(self.rpm_base, "SPECS",
+                "%s.spec" % self.distribution.get_name())
+        queryFormat = "%{name}-%{version}-%{release}.%{arch}.rpm"
+        command = "rpm -q --qf '%s' --specfile %s" % (queryFormat, specFile)
+        origFileName = os.popen(command).read()
+        parts = origFileName.split("-")
+        parts.insert(2, oracleVersion)
+        parts.insert(3, "py%s%s" % sys.version_info[:2])
+        newFileName = "-".join(parts)
+        self.move_file(os.path.join("dist", origFileName),
+        os.path.join("dist", newFileName))
+
+
+# tweak the build directories to include the Oracle version
+class build(distutils.command.build.build):
+
+    def finalize_options(self):
+        import distutils.util
+        import os
+        import sys
+        platSpecifier = ".%s-%s-%s" % \
+                (distutils.util.get_platform(), sys.version[0:3],
+                 oracleVersion)
+        if self.build_platlib is None:
+            self.build_platlib = os.path.join(self.build_base,
+                    "lib%s" % platSpecifier)
+        if self.build_temp is None:
+            self.build_temp = os.path.join(self.build_base,
+                    "temp%s" % platSpecifier)
+        distutils.command.build.build.finalize_options(self)
+
+class test(distutils.core.Command):
+    description = "run the test suite for the extension"
+    user_options = []
+
+    def finalize_options(self):
+        pass
+
+    def initialize_options(self):
+        pass
+
+    def run(self):
+        self.run_command("build")
+        buildCommand = self.distribution.get_command_obj("build")
+        sys.path.insert(0, os.path.abspath("test"))
+        sys.path.insert(0, os.path.abspath(buildCommand.build_lib))
+        if sys.version_info[0] < 3:
+            execfile(os.path.join("test", "test.py"))
+        else:
+            fileName = os.path.join("test", "test3k.py")
+            exec(open(fileName).read())
+
+commandClasses = dict(build = build, bdist_rpm = bdist_rpm, test = test)
+
+# tweak the Windows installer names to include the Oracle version
+if distutils.command.bdist_msi is not None:
+
+    class bdist_msi(distutils.command.bdist_msi.bdist_msi):
+
+        def run(self):
+            origMethod = self.distribution.get_fullname
+            self.distribution.get_fullname = \
+                    self.distribution.get_fullname_with_oracle_version
+            distutils.command.bdist_msi.bdist_msi.run(self)
+            self.distribution.get_fullname = origMethod
+
+    commandClasses["bdist_msi"] = bdist_msi
+
+if distutils.command.bdist_wininst is not None:
+
+    class bdist_wininst(distutils.command.bdist_wininst.bdist_wininst):
+
+        def run(self):
+            origMethod = self.distribution.get_fullname
+            self.distribution.get_fullname = \
+                    self.distribution.get_fullname_with_oracle_version
+            distutils.command.bdist_wininst.bdist_wininst.run(self)
+            self.distribution.get_fullname = origMethod
+
+    commandClasses["bdist_wininst"] = bdist_wininst
+
+# define classifiers for the package index
+classifiers = [
+        "Development Status :: 6 - Mature",
+        "Intended Audience :: Developers",
+        "License :: OSI Approved :: Python Software Foundation License",
+        "Natural Language :: English",
+        "Operating System :: OS Independent",
+        "Programming Language :: C",
+        "Programming Language :: Python",
+        "Programming Language :: Python :: 2",
+        "Programming Language :: Python :: 3",
+        "Topic :: Database"
+]
+
+# setup the extension
+extension = Extension(
+        name = "cx_Oracle",
+        include_dirs = includeDirs,
+        libraries = libs,
+        library_dirs = libDirs,
+        extra_compile_args = extraCompileArgs,
+        extra_link_args = extraLinkArgs,
+        sources = ["cx_Oracle.c"],
+        depends = ["Buffer.c", "Callback.c", "Connection.c", "Cursor.c",
+                "CursorVar.c", "DateTimeVar.c", "Environment.c", "Error.c",
+                "ExternalLobVar.c", "ExternalObjectVar.c", "IntervalVar.c",
+                "LobVar.c", "LongVar.c", "NumberVar.c", "ObjectType.c",
+                "ObjectVar.c", "SessionPool.c", "StringVar.c",
+                "Subscription.c", "TimestampVar.c", "Transforms.c",
+                "Variable.c"])
+
+# perform the setup
+setup(
+        name = "cx_Oracle",
+        version = BUILD_VERSION,
+        distclass = Distribution,
+        description = "Python interface to Oracle",
+        data_files = dataFiles,
+        cmdclass = commandClasses,
+        options = dict(bdist_rpm = dict(doc_files = docFiles)),
+        long_description = \
+            "Python interface to Oracle conforming to the Python DB API 2.0 "
+            "specification.\n"
+            "See http://www.python.org/topics/database/DatabaseAPI-2.0.html.",
+        author = "Anthony Tuininga",
+        author_email = "anthony.tuininga@gmail.com",
+        url = "http://cx-oracle.sourceforge.net",
+        ext_modules = [extension],
+        keywords = "Oracle",
+        license = "Python Software Foundation License",
+        classifiers = classifiers)
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/test/3kNumberVar.py b/desktop/core/ext-py/cx_Oracle-5.1.2/test/3kNumberVar.py
new file mode 100644
index 0000000..8976a84
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/test/3kNumberVar.py
@@ -0,0 +1,254 @@
+"""Module for testing number variables."""
+
+import cx_Oracle
+import decimal
+
+class TestNumberVar(BaseTestCase):
+
+    def setUp(self):
+      BaseTestCase.setUp(self)
+      self.rawData = []
+      self.dataByKey = {}
+      for i in range(1, 11):
+          numberCol = i + i * 0.25
+          floatCol = i + i * 0.75
+          unconstrainedCol = i ** 3 + i * 0.5
+          if i % 2:
+              nullableCol = 143 ** i
+          else:
+              nullableCol = None
+          dataTuple = (i, numberCol, floatCol, unconstrainedCol, nullableCol)
+          self.rawData.append(dataTuple)
+          self.dataByKey[i] = dataTuple
+
+    def testBindDecimal(self):
+        "test binding in a decimal.Decimal"
+        self.cursor.execute("""
+                select * from TestNumbers
+                where NumberCol - :value1 - :value2 = trunc(NumberCol)""",
+                value1 = decimal.Decimal("0.20"),
+                value2 = decimal.Decimal("0.05"))
+        self.failUnlessEqual(self.cursor.fetchall(),
+                [self.dataByKey[1], self.dataByKey[5], self.dataByKey[9]])
+
+    def testBindFloat(self):
+        "test binding in a float"
+        self.cursor.execute("""
+                select * from TestNumbers
+                where NumberCol - :value = trunc(NumberCol)""",
+                value = 0.25)
+        self.failUnlessEqual(self.cursor.fetchall(),
+                [self.dataByKey[1], self.dataByKey[5], self.dataByKey[9]])
+
+    def testBindSmallLong(self):
+        "test binding in a small long integer"
+        self.cursor.execute("""
+                select * from TestNumbers
+                where IntCol = :value""",
+                value = 3)
+        self.failUnlessEqual(self.cursor.fetchall(), [self.dataByKey[3]])
+
+    def testBindLargeLong(self):
+        "test binding in a large long integer"
+        valueVar = self.cursor.var(cx_Oracle.NUMBER)
+        valueVar.setvalue(0, 6088343244)
+        self.cursor.execute("""
+                begin
+                  :value := :value + 5;
+                end;""",
+                value = valueVar)
+        value = valueVar.getvalue()
+        self.failUnlessEqual(value, 6088343249)
+
+    def testBindIntegerAfterString(self):
+        "test binding in an number after setting input sizes to a string"
+        self.cursor.setinputsizes(value = 15)
+        self.cursor.execute("""
+                select * from TestNumbers
+                where IntCol = :value""",
+                value = 3)
+        self.failUnlessEqual(self.cursor.fetchall(), [self.dataByKey[3]])
+
+    def testBindNull(self):
+        "test binding in a null"
+        self.cursor.execute("""
+                select * from TestNumbers
+                where IntCol = :value""",
+                value = None)
+        self.failUnlessEqual(self.cursor.fetchall(), [])
+
+    def testBindNumberArrayDirect(self):
+        "test binding in a number array"
+        returnValue = self.cursor.var(cx_Oracle.NUMBER)
+        array = [r[1] for r in self.rawData]
+        statement = """
+                begin
+                  :p_ReturnValue := pkg_TestNumberArrays.TestInArrays(
+                      :p_StartValue, :p_Array);
+                end;"""
+        self.cursor.execute(statement,
+                p_ReturnValue = returnValue,
+                p_StartValue = 5,
+                p_Array = array)
+        self.failUnlessEqual(returnValue.getvalue(), 73.75)
+        array = list(range(15))
+        self.cursor.execute(statement,
+                p_StartValue = 10,
+                p_Array = array)
+        self.failUnlessEqual(returnValue.getvalue(), 115.0)
+
+    def testBindNumberArrayBySizes(self):
+        "test binding in a number array (with setinputsizes)"
+        returnValue = self.cursor.var(cx_Oracle.NUMBER)
+        self.cursor.setinputsizes(p_Array = [cx_Oracle.NUMBER, 10])
+        array = [r[1] for r in self.rawData]
+        self.cursor.execute("""
+                begin
+                  :p_ReturnValue := pkg_TestNumberArrays.TestInArrays(
+                      :p_StartValue, :p_Array);
+                end;""",
+                p_ReturnValue = returnValue,
+                p_StartValue = 6,
+                p_Array = array)
+        self.failUnlessEqual(returnValue.getvalue(), 74.75)
+
+    def testBindNumberArrayByVar(self):
+        "test binding in a number array (with arrayvar)"
+        returnValue = self.cursor.var(cx_Oracle.NUMBER)
+        array = self.cursor.arrayvar(cx_Oracle.NUMBER,
+                [r[1] for r in self.rawData])
+        array.setvalue(0, [r[1] for r in self.rawData])
+        self.cursor.execute("""
+                begin
+                  :p_ReturnValue := pkg_TestNumberArrays.TestInArrays(
+                      :p_IntegerValue, :p_Array);
+                end;""",
+                p_ReturnValue = returnValue,
+                p_IntegerValue = 7,
+                p_Array = array)
+        self.failUnlessEqual(returnValue.getvalue(), 75.75)
+
+    def testBindZeroLengthNumberArrayByVar(self):
+        "test binding in a zero length number array (with arrayvar)"
+        returnValue = self.cursor.var(cx_Oracle.NUMBER)
+        array = self.cursor.arrayvar(cx_Oracle.NUMBER, 0)
+        self.cursor.execute("""
+                begin
+                  :p_ReturnValue := pkg_TestNumberArrays.TestInArrays(
+                      :p_IntegerValue, :p_Array);
+                end;""",
+                p_ReturnValue = returnValue,
+                p_IntegerValue = 8,
+                p_Array = array)
+        self.failUnlessEqual(returnValue.getvalue(), 8.0)
+        self.failUnlessEqual(array.getvalue(), [])
+
+    def testBindInOutNumberArrayByVar(self):
+        "test binding in/out a number array (with arrayvar)"
+        array = self.cursor.arrayvar(cx_Oracle.NUMBER, 10)
+        originalData = [r[1] for r in self.rawData]
+        expectedData = [originalData[i - 1] * 10 for i in range(1, 6)] + \
+                originalData[5:]
+        array.setvalue(0, originalData)
+        self.cursor.execute("""
+                begin
+                  pkg_TestNumberArrays.TestInOutArrays(:p_NumElems, :p_Array);
+                end;""",
+                p_NumElems = 5,
+                p_Array = array)
+        self.failUnlessEqual(array.getvalue(), expectedData)
+
+    def testBindOutNumberArrayByVar(self):
+        "test binding out a Number array (with arrayvar)"
+        array = self.cursor.arrayvar(cx_Oracle.NUMBER, 6)
+        expectedData = [i * 100 for i in range(1, 7)]
+        self.cursor.execute("""
+                begin
+                  pkg_TestNumberArrays.TestOutArrays(:p_NumElems, :p_Array);
+                end;""",
+                p_NumElems = 6,
+                p_Array = array)
+        self.failUnlessEqual(array.getvalue(), expectedData)
+
+    def testBindOutSetInputSizes(self):
+        "test binding out with set input sizes defined"
+        vars = self.cursor.setinputsizes(value = cx_Oracle.NUMBER)
+        self.cursor.execute("""
+                begin
+                  :value := 5;
+                end;""")
+        self.failUnlessEqual(vars["value"].getvalue(), 5)
+
+    def testBindInOutSetInputSizes(self):
+        "test binding in/out with set input sizes defined"
+        vars = self.cursor.setinputsizes(value = cx_Oracle.NUMBER)
+        self.cursor.execute("""
+                begin
+                  :value := :value + 5;
+                end;""",
+                value = 1.25)
+        self.failUnlessEqual(vars["value"].getvalue(), 6.25)
+
+    def testBindOutVar(self):
+        "test binding out with cursor.var() method"
+        var = self.cursor.var(cx_Oracle.NUMBER)
+        self.cursor.execute("""
+                begin
+                  :value := 5;
+                end;""",
+                value = var)
+        self.failUnlessEqual(var.getvalue(), 5)
+
+    def testBindInOutVarDirectSet(self):
+        "test binding in/out with cursor.var() method"
+        var = self.cursor.var(cx_Oracle.NUMBER)
+        var.setvalue(0, 2.25)
+        self.cursor.execute("""
+                begin
+                  :value := :value + 5;
+                end;""",
+                value = var)
+        self.failUnlessEqual(var.getvalue(), 7.25)
+
+    def testCursorDescription(self):
+        "test cursor description is accurate"
+        self.cursor.execute("select * from TestNumbers")
+        self.failUnlessEqual(self.cursor.description,
+                [ ('INTCOL', cx_Oracle.NUMBER, 10, 22, 9, 0, 0),
+                  ('NUMBERCOL', cx_Oracle.NUMBER, 13, 22, 9, 2, 0),
+                  ('FLOATCOL', cx_Oracle.NUMBER, 127, 22, 126, -127, 0),
+                  ('UNCONSTRAINEDCOL', cx_Oracle.NUMBER, 127, 22, 0, -127, 0),
+                  ('NULLABLECOL', cx_Oracle.NUMBER, 39, 22, 38, 0, 1) ])
+
+    def testFetchAll(self):
+        "test that fetching all of the data returns the correct results"
+        self.cursor.execute("select * From TestNumbers order by IntCol")
+        self.failUnlessEqual(self.cursor.fetchall(), self.rawData)
+        self.failUnlessEqual(self.cursor.fetchall(), [])
+
+    def testFetchMany(self):
+        "test that fetching data in chunks returns the correct results"
+        self.cursor.execute("select * From TestNumbers order by IntCol")
+        self.failUnlessEqual(self.cursor.fetchmany(3), self.rawData[0:3])
+        self.failUnlessEqual(self.cursor.fetchmany(2), self.rawData[3:5])
+        self.failUnlessEqual(self.cursor.fetchmany(4), self.rawData[5:9])
+        self.failUnlessEqual(self.cursor.fetchmany(3), self.rawData[9:])
+        self.failUnlessEqual(self.cursor.fetchmany(3), [])
+
+    def testFetchOne(self):
+        "test that fetching a single row returns the correct results"
+        self.cursor.execute("""
+                select *
+                from TestNumbers
+                where IntCol in (3, 4)
+                order by IntCol""")
+        self.failUnlessEqual(self.cursor.fetchone(), self.dataByKey[3])
+        self.failUnlessEqual(self.cursor.fetchone(), self.dataByKey[4])
+        self.failUnlessEqual(self.cursor.fetchone(), None)
+
+    def testReturnAsFloat(self):
+        "test that fetching a floating point number returns such in Python"
+        self.cursor.execute("select 1.25 from dual")
+        result, = self.cursor.fetchone()
+        self.failUnlessEqual(result, 1.25)
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/test/3kStringVar.py b/desktop/core/ext-py/cx_Oracle-5.1.2/test/3kStringVar.py
new file mode 100644
index 0000000..32faebb
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/test/3kStringVar.py
@@ -0,0 +1,286 @@
+"""Module for testing string variables."""
+
+class TestStringVar(BaseTestCase):
+
+    def setUp(self):
+        BaseTestCase.setUp(self)
+        self.rawData = []
+        self.dataByKey = {}
+        for i in range(1, 11):
+            stringCol = "String %d" % i
+            fixedCharCol = ("Fixed Char %d" % i).ljust(40)
+            rawCol = ("Raw %d" % i).encode("ascii")
+            if i % 2:
+                nullableCol = "Nullable %d" % i
+            else:
+                nullableCol = None
+            dataTuple = (i, stringCol, rawCol, fixedCharCol, nullableCol)
+            self.rawData.append(dataTuple)
+            self.dataByKey[i] = dataTuple
+
+    def testBindString(self):
+        "test binding in a string"
+        self.cursor.execute("""
+                select * from TestStrings
+                where StringCol = :p_Value""",
+                p_Value = "String 5")
+        self.failUnlessEqual(self.cursor.fetchall(), [self.dataByKey[5]])
+
+    def testBindDifferentVar(self):
+        "test binding a different variable on second execution"
+        retval_1 = self.cursor.var(cx_Oracle.STRING, 30)
+        retval_2 = self.cursor.var(cx_Oracle.STRING, 30)
+        self.cursor.execute("begin :retval := 'Called'; end;",
+                retval = retval_1)
+        self.failUnlessEqual(retval_1.getvalue(), "Called")
+        self.cursor.execute("begin :retval := 'Called'; end;",
+                retval = retval_2)
+        self.failUnlessEqual(retval_2.getvalue(), "Called")
+
+    def testBindStringAfterNumber(self):
+        "test binding in a string after setting input sizes to a number"
+        self.cursor.setinputsizes(p_Value = cx_Oracle.NUMBER)
+        self.cursor.execute("""
+                select * from TestStrings
+                where StringCol = :p_Value""",
+                p_Value = "String 6")
+        self.failUnlessEqual(self.cursor.fetchall(), [self.dataByKey[6]])
+
+    def testBindStringArrayDirect(self):
+        "test binding in a string array"
+        returnValue = self.cursor.var(cx_Oracle.NUMBER)
+        array = [r[1] for r in self.rawData]
+        statement = """
+                begin
+                  :p_ReturnValue := pkg_TestStringArrays.TestInArrays(
+                      :p_IntegerValue, :p_Array);
+                end;"""
+        self.cursor.execute(statement,
+                p_ReturnValue = returnValue,
+                p_IntegerValue = 5,
+                p_Array = array)
+        self.failUnlessEqual(returnValue.getvalue(), 86)
+        array = [ "String - %d" % i for i in range(15) ]
+        self.cursor.execute(statement,
+                p_IntegerValue = 8,
+                p_Array = array)
+        self.failUnlessEqual(returnValue.getvalue(), 163)
+
+    def testBindStringArrayBySizes(self):
+        "test binding in a string array (with setinputsizes)"
+        returnValue = self.cursor.var(cx_Oracle.NUMBER)
+        self.cursor.setinputsizes(p_Array = [cx_Oracle.STRING, 10])
+        array = [r[1] for r in self.rawData]
+        self.cursor.execute("""
+                begin
+                  :p_ReturnValue := pkg_TestStringArrays.TestInArrays(
+                      :p_IntegerValue, :p_Array);
+                end;""",
+                p_ReturnValue = returnValue,
+                p_IntegerValue = 6,
+                p_Array = array)
+        self.failUnlessEqual(returnValue.getvalue(), 87)
+
+    def testBindStringArrayByVar(self):
+        "test binding in a string array (with arrayvar)"
+        returnValue = self.cursor.var(cx_Oracle.NUMBER)
+        array = self.cursor.arrayvar(cx_Oracle.STRING, 10, 20)
+        array.setvalue(0, [r[1] for r in self.rawData])
+        self.cursor.execute("""
+                begin
+                  :p_ReturnValue := pkg_TestStringArrays.TestInArrays(
+                      :p_IntegerValue, :p_Array);
+                end;""",
+                p_ReturnValue = returnValue,
+                p_IntegerValue = 7,
+                p_Array = array)
+        self.failUnlessEqual(returnValue.getvalue(), 88)
+
+    def testBindInOutStringArrayByVar(self):
+        "test binding in/out a string array (with arrayvar)"
+        array = self.cursor.arrayvar(cx_Oracle.STRING, 10, 100)
+        originalData = [r[1] for r in self.rawData]
+        expectedData = ["Converted element # %d originally had length %d" % \
+                (i, len(originalData[i - 1])) for i in range(1, 6)] + \
+                originalData[5:]
+        array.setvalue(0, originalData)
+        self.cursor.execute("""
+                begin
+                  pkg_TestStringArrays.TestInOutArrays(:p_NumElems, :p_Array);
+                end;""",
+                p_NumElems = 5,
+                p_Array = array)
+        self.failUnlessEqual(array.getvalue(), expectedData)
+
+    def testBindOutStringArrayByVar(self):
+        "test binding out a string array (with arrayvar)"
+        array = self.cursor.arrayvar(cx_Oracle.STRING, 6, 100)
+        expectedData = ["Test out element # %d" % i for i in range(1, 7)]
+        self.cursor.execute("""
+                begin
+                  pkg_TestStringArrays.TestOutArrays(:p_NumElems, :p_Array);
+                end;""",
+                p_NumElems = 6,
+                p_Array = array)
+        self.failUnlessEqual(array.getvalue(), expectedData)
+
+    def testBindRaw(self):
+        "test binding in a raw"
+        self.cursor.setinputsizes(p_Value = cx_Oracle.BINARY)
+        self.cursor.execute("""
+                select * from TestStrings
+                where RawCol = :p_Value""",
+                p_Value = b"Raw 4")
+        self.failUnlessEqual(self.cursor.fetchall(), [self.dataByKey[4]])
+
+    def testBindAndFetchRowid(self):
+        "test binding (and fetching) a rowid"
+        self.cursor.execute("""
+                select rowid
+                from TestStrings
+                where IntCol = 3""")
+        rowid, = self.cursor.fetchone()
+        self.cursor.execute("""
+                select *
+                from TestStrings
+                where rowid = :p_Value""",
+                p_Value = rowid)
+        self.failUnlessEqual(self.cursor.fetchall(), [self.dataByKey[3]])
+
+    def testBindNull(self):
+        "test binding in a null"
+        self.cursor.execute("""
+                select * from TestStrings
+                where StringCol = :p_Value""",
+                p_Value = None)
+        self.failUnlessEqual(self.cursor.fetchall(), [])
+
+    def testBindOutSetInputSizesByType(self):
+        "test binding out with set input sizes defined (by type)"
+        vars = self.cursor.setinputsizes(p_Value = cx_Oracle.STRING)
+        self.cursor.execute("""
+                begin
+                  :p_Value := 'TSI';
+                end;""")
+        self.failUnlessEqual(vars["p_Value"].getvalue(), "TSI")
+
+    def testBindOutSetInputSizesByInteger(self):
+        "test binding out with set input sizes defined (by integer)"
+        vars = self.cursor.setinputsizes(p_Value = 30)
+        self.cursor.execute("""
+                begin
+                  :p_Value := 'TSI (I)';
+                end;""")
+        self.failUnlessEqual(vars["p_Value"].getvalue(), "TSI (I)")
+
+    def testBindInOutSetInputSizesByType(self):
+        "test binding in/out with set input sizes defined (by type)"
+        vars = self.cursor.setinputsizes(p_Value = cx_Oracle.STRING)
+        self.cursor.execute("""
+                begin
+                  :p_Value := :p_Value || ' TSI';
+                end;""",
+                p_Value = "InVal")
+        self.failUnlessEqual(vars["p_Value"].getvalue(), "InVal TSI")
+
+    def testBindInOutSetInputSizesByInteger(self):
+        "test binding in/out with set input sizes defined (by integer)"
+        vars = self.cursor.setinputsizes(p_Value = 30)
+        self.cursor.execute("""
+                begin
+                  :p_Value := :p_Value || ' TSI (I)';
+                end;""",
+                p_Value = "InVal")
+        self.failUnlessEqual(vars["p_Value"].getvalue(), "InVal TSI (I)")
+
+    def testBindOutVar(self):
+        "test binding out with cursor.var() method"
+        var = self.cursor.var(cx_Oracle.STRING)
+        self.cursor.execute("""
+                begin
+                  :p_Value := 'TSI (VAR)';
+                end;""",
+                p_Value = var)
+        self.failUnlessEqual(var.getvalue(), "TSI (VAR)")
+
+    def testBindInOutVarDirectSet(self):
+        "test binding in/out with cursor.var() method"
+        var = self.cursor.var(cx_Oracle.STRING)
+        var.setvalue(0, "InVal")
+        self.cursor.execute("""
+                begin
+                  :p_Value := :p_Value || ' TSI (VAR)';
+                end;""",
+                p_Value = var)
+        self.failUnlessEqual(var.getvalue(), "InVal TSI (VAR)")
+
+    def testBindLongString(self):
+        "test that binding a long string succeeds"
+        self.cursor.execute("""
+                declare
+                  t_Temp varchar2(10000);
+                begin
+                  t_Temp := :bigString;
+                end;""",
+                bigString = "X" * 10000)
+
+    def testBindLongStringAfterSettingSize(self):
+        "test that setinputsizes() returns a long variable"
+        var = self.cursor.setinputsizes(test = 90000)["test"]
+        self.failUnlessEqual(type(var), cx_Oracle.LONG_STRING)
+        inString = "1234567890" * 9000
+        var.setvalue(0, inString)
+        outString = var.getvalue()
+        self.failUnlessEqual(inString, outString,
+                "output does not match: in was %d, out was %d" % \
+                (len(inString), len(outString)))
+
+    def testStringMaximumReached(self):
+        "test that an error is raised when maximum string length exceeded"
+        var = self.cursor.setinputsizes(test = 100)["test"]
+        inString = "1234567890" * 400
+        var.setvalue(0, inString)
+        outString = var.getvalue()
+        self.failUnlessEqual(inString, outString,
+                "output does not match: in was %d, out was %d" % \
+                (len(inString), len(outString)))
+        badStringSize = 4000 * self.connection.maxBytesPerCharacter + 1
+        inString = "X" * badStringSize
+        self.failUnlessRaises(ValueError, var.setvalue, 0, inString)
+
+    def testCursorDescription(self):
+        "test cursor description is accurate"
+        self.cursor.execute("select * from TestStrings")
+        self.failUnlessEqual(self.cursor.description,
+                [ ('INTCOL', cx_Oracle.NUMBER, 10, 22, 9, 0, 0),
+                  ('STRINGCOL', cx_Oracle.STRING, 20, 20, 0, 0, 0),
+                  ('RAWCOL', cx_Oracle.BINARY, 30, 30, 0, 0, 0),
+                  ('FIXEDCHARCOL', cx_Oracle.FIXED_CHAR, 40, 40, 0, 0, 0),
+                  ('NULLABLECOL', cx_Oracle.STRING, 50, 50, 0, 0, 1) ])
+
+    def testFetchAll(self):
+        "test that fetching all of the data returns the correct results"
+        self.cursor.execute("select * From TestStrings order by IntCol")
+        self.failUnlessEqual(self.cursor.fetchall(), self.rawData)
+        self.failUnlessEqual(self.cursor.fetchall(), [])
+
+    def testFetchMany(self):
+        "test that fetching data in chunks returns the correct results"
+        self.cursor.execute("select * From TestStrings order by IntCol")
+        self.failUnlessEqual(self.cursor.fetchmany(3), self.rawData[0:3])
+        self.failUnlessEqual(self.cursor.fetchmany(2), self.rawData[3:5])
+        self.failUnlessEqual(self.cursor.fetchmany(4), self.rawData[5:9])
+        self.failUnlessEqual(self.cursor.fetchmany(3), self.rawData[9:])
+        self.failUnlessEqual(self.cursor.fetchmany(3), [])
+
+    def testFetchOne(self):
+        "test that fetching a single row returns the correct results"
+        self.cursor.execute("""
+                select *
+                from TestStrings
+                where IntCol in (3, 4)
+                order by IntCol""")
+        self.failUnlessEqual(self.cursor.fetchone(), self.dataByKey[3])
+        self.failUnlessEqual(self.cursor.fetchone(), self.dataByKey[4])
+        self.failUnlessEqual(self.cursor.fetchone(), None)
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/test/Connection.py b/desktop/core/ext-py/cx_Oracle-5.1.2/test/Connection.py
new file mode 100644
index 0000000..97a522d
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/test/Connection.py
@@ -0,0 +1,116 @@
+"""Module for testing connections."""
+
+import threading
+
+class TestConnection(TestCase):
+
+    def __ConnectAndDrop(self):
+        """Connect to the database, perform a query and drop the connection."""
+        connection = cx_Oracle.connect(self.username, self.password,
+                self.tnsentry, threaded = True)
+        cursor = connection.cursor()
+        cursor.execute("select count(*) from TestNumbers")
+        count, = cursor.fetchone()
+        self.failUnlessEqual(count, 10)
+
+    def setUp(self):
+        self.username = USERNAME
+        self.password = PASSWORD
+        self.tnsentry = TNSENTRY
+
+    def verifyArgs(self, connection):
+        self.failUnlessEqual(connection.username, self.username,
+                "user name differs")
+        self.failUnlessEqual(connection.password, self.password,
+                "password differs")
+        self.failUnlessEqual(connection.tnsentry, self.tnsentry,
+                "tnsentry differs")
+
+    def testAllArgs(self):
+        "connection to database with user, password, TNS separate"
+        connection = cx_Oracle.connect(self.username, self.password,
+                self.tnsentry)
+        self.verifyArgs(connection)
+
+    def testBadConnectString(self):
+        "connection to database with bad connect string"
+        self.failUnlessRaises(cx_Oracle.DatabaseError, cx_Oracle.connect,
+                self.username)
+        self.failUnlessRaises(cx_Oracle.DatabaseError, cx_Oracle.connect,
+                self.username + "@" + self.tnsentry)
+        self.failUnlessRaises(cx_Oracle.DatabaseError, cx_Oracle.connect,
+                self.username + "@" + self.tnsentry + "/" + self.password)
+
+    def testBadPassword(self):
+        "connection to database with bad password"
+        self.failUnlessRaises(cx_Oracle.DatabaseError, cx_Oracle.connect,
+                self.username, self.password + "X", self.tnsentry)
+
+    def testExceptionOnClose(self):
+        "confirm an exception is raised after closing a connection"
+        connection = cx_Oracle.connect(self.username, self.password,
+                self.tnsentry)
+        connection.close()
+        self.failUnlessRaises(cx_Oracle.InterfaceError, connection.rollback)
+
+    def testMakeDSN(self):
+        "test making a data source name from host, port and sid"
+        formatString = "(DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)" + \
+                "(HOST=%s)(PORT=%d)))(CONNECT_DATA=(SID=%s)))"
+        args = ("hostname", 1521, "TEST")
+        result = cx_Oracle.makedsn(*args)
+        self.failUnlessEqual(result, formatString % args)
+
+    def testSingleArg(self):
+        "connection to database with user, password, TNS together"
+        connection = cx_Oracle.connect("%s/%s@%s" % \
+                (self.username, self.password, self.tnsentry))
+        self.verifyArgs(connection)
+
+    def testVersion(self):
+        "connection version is a string"
+        connection = cx_Oracle.connect(self.username, self.password,
+                self.tnsentry)
+        self.failUnless(isinstance(connection.version, str))
+
+    def testRollbackOnClose(self):
+        "connection rolls back before close"
+        connection = cx_Oracle.connect(self.username, self.password,
+                self.tnsentry)
+        cursor = connection.cursor()
+        cursor.execute("truncate table TestExecuteMany")
+        otherConnection = cx_Oracle.connect(self.username, self.password,
+                self.tnsentry)
+        otherCursor = otherConnection.cursor()
+        otherCursor.execute("insert into TestExecuteMany (IntCol) values (1)")
+        otherConnection.close()
+        cursor.execute("select count(*) from TestExecuteMany")
+        count, = cursor.fetchone()
+        self.failUnlessEqual(count, 0)
+
+    def testRollbackOnDel(self):
+        "connection rolls back before destruction"
+        connection = cx_Oracle.connect(self.username, self.password,
+                self.tnsentry)
+        cursor = connection.cursor()
+        cursor.execute("truncate table TestExecuteMany")
+        otherConnection = cx_Oracle.connect(self.username, self.password,
+                self.tnsentry)
+        otherCursor = otherConnection.cursor()
+        otherCursor.execute("insert into TestExecuteMany (IntCol) values (1)")
+        del otherCursor
+        del otherConnection
+        cursor.execute("select count(*) from TestExecuteMany")
+        count, = cursor.fetchone()
+        self.failUnlessEqual(count, 0)
+
+    def testThreading(self):
+        "connection to database with multiple threads"
+        threads = []
+        for i in range(20):
+            thread = threading.Thread(None, self.__ConnectAndDrop)
+            threads.append(thread)
+            thread.start()
+        for thread in threads:
+            thread.join()
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/test/Cursor.py b/desktop/core/ext-py/cx_Oracle-5.1.2/test/Cursor.py
new file mode 100644
index 0000000..6853c24
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/test/Cursor.py
@@ -0,0 +1,253 @@
+"""Module for testing cursor objects."""
+
+import cx_Oracle
+import sys
+
+class TestCursor(BaseTestCase):
+
+    def testExecuteNoArgs(self):
+        """test executing a statement without any arguments"""
+        result = self.cursor.execute("begin null; end;")
+        self.failUnlessEqual(result, None)
+
+    def testExecuteNoStatementWithArgs(self):
+        """test executing a None statement with bind variables"""
+        self.failUnlessRaises(cx_Oracle.ProgrammingError, self.cursor.execute,
+                None, x = 5)
+
+    def testExecuteEmptyKeywordArgs(self):
+        """test executing a statement with args and empty keyword args"""
+        simpleVar = self.cursor.var(cx_Oracle.NUMBER)
+        args = [simpleVar]
+        kwArgs = {}
+        result = self.cursor.execute("begin :1 := 25; end;", args, **kwArgs)
+        self.failUnlessEqual(result, None)
+        self.failUnlessEqual(simpleVar.getvalue(), 25)
+
+    def testExecuteKeywordArgs(self):
+        """test executing a statement with keyword arguments"""
+        simpleVar = self.cursor.var(cx_Oracle.NUMBER)
+        result = self.cursor.execute("begin :p_Value := 5; end;",
+                p_Value = simpleVar)
+        self.failUnlessEqual(result, None)
+        self.failUnlessEqual(simpleVar.getvalue(), 5)
+
+    def testExecuteDictionaryArg(self):
+        """test executing a statement with a dictionary argument"""
+        simpleVar = self.cursor.var(cx_Oracle.NUMBER)
+        dictArg = { "p_Value" : simpleVar }
+        result = self.cursor.execute("begin :p_Value := 10; end;", dictArg)
+        self.failUnlessEqual(result, None)
+        self.failUnlessEqual(simpleVar.getvalue(), 10)
+
+    def testExecuteMultipleMethod(self):
+        """test executing a statement with both a dict arg and keyword args"""
+        simpleVar = self.cursor.var(cx_Oracle.NUMBER)
+        dictArg = { "p_Value" : simpleVar }
+        self.failUnlessRaises(cx_Oracle.InterfaceError, self.cursor.execute,
+                "begin :p_Value := 15; end;", dictArg, p_Value = simpleVar)
+
+    def testExecuteAndModifyArraySize(self):
+        """test executing a statement and then changing the array size"""
+        self.cursor.execute("select IntCol from TestNumbers")
+        self.cursor.arraysize = 20
+        self.failUnlessEqual(len(self.cursor.fetchall()), 10)
+
+    def testCallProc(self):
+        """test executing a stored procedure"""
+        var = self.cursor.var(cx_Oracle.NUMBER)
+        results = self.cursor.callproc("proc_Test", ("hi", 5, var))
+        self.failUnlessEqual(results, ["hi", 10, 2.0])
+
+    def testCallProcNoArgs(self):
+        """test executing a stored procedure without any arguments"""
+        results = self.cursor.callproc("proc_TestNoArgs")
+        self.failUnlessEqual(results, [])
+
+    def testCallFunc(self):
+        """test executing a stored function"""
+        results = self.cursor.callfunc("func_Test", cx_Oracle.NUMBER,
+                ("hi", 5))
+        self.failUnlessEqual(results, 7)
+
+    def testCallFuncNoArgs(self):
+        """test executing a stored function without any arguments"""
+        results = self.cursor.callfunc("func_TestNoArgs", cx_Oracle.NUMBER)
+        self.failUnlessEqual(results, 712)
+
+    def testExecuteManyByName(self):
+        """test executing a statement multiple times (named args)"""
+        self.cursor.execute("truncate table TestExecuteMany")
+        rows = [ { "value" : n } for n in range(250) ]
+        self.cursor.arraysize = 100
+        statement = "insert into TestExecuteMany (IntCol) values (:value)"
+        self.cursor.executemany(statement, rows)
+        self.connection.commit()
+        self.cursor.execute("select count(*) from TestExecuteMany")
+        count, = self.cursor.fetchone()
+        self.failUnlessEqual(count, len(rows))
+
+    def testExecuteManyByPosition(self):
+        """test executing a statement multiple times (positional args)"""
+        self.cursor.execute("truncate table TestExecuteMany")
+        rows = [ [n] for n in range(230) ]
+        self.cursor.arraysize = 100
+        statement = "insert into TestExecuteMany (IntCol) values (:1)"
+        self.cursor.executemany(statement, rows)
+        self.connection.commit()
+        self.cursor.execute("select count(*) from TestExecuteMany")
+        count, = self.cursor.fetchone()
+        self.failUnlessEqual(count, len(rows))
+
+    def testExecuteManyWithPrepare(self):
+        """test executing a statement multiple times (with prepare)"""
+        self.cursor.execute("truncate table TestExecuteMany")
+        rows = [ [n] for n in range(225) ]
+        self.cursor.arraysize = 100
+        statement = "insert into TestExecuteMany (IntCol) values (:1)"
+        self.cursor.prepare(statement)
+        self.cursor.executemany(None, rows)
+        self.connection.commit()
+        self.cursor.execute("select count(*) from TestExecuteMany")
+        count, = self.cursor.fetchone()
+        self.failUnlessEqual(count, len(rows))
+
+    def testExecuteManyWithRebind(self):
+        """test executing a statement multiple times (with rebind)"""
+        self.cursor.execute("truncate table TestExecuteMany")
+        rows = [ [n] for n in range(235) ]
+        self.cursor.arraysize = 100
+        statement = "insert into TestExecuteMany (IntCol) values (:1)"
+        self.cursor.executemany(statement, rows[:50])
+        self.cursor.executemany(statement, rows[50:])
+        self.connection.commit()
+        self.cursor.execute("select count(*) from TestExecuteMany")
+        count, = self.cursor.fetchone()
+        self.failUnlessEqual(count, len(rows))
+
+    def testExecuteManyWithResize(self):
+        """test executing a statement multiple times (with resize)"""
+        self.cursor.execute("truncate table TestExecuteMany")
+        rows = [ ( 1, "First" ),
+                 ( 2, "Second" ),
+                 ( 3, "Third" ),
+                 ( 4, "Fourth" ),
+                 ( 5, "Fifth" ),
+                 ( 6, "Sixth" ),
+                 ( 7, "Seventh" ) ]
+        self.cursor.bindarraysize = 5
+        self.cursor.setinputsizes(int, 100)
+        sql = "insert into TestExecuteMany (IntCol, StringCol) values (:1, :2)"
+        self.cursor.executemany(sql, rows)
+        var = self.cursor.bindvars[1]
+        self.cursor.execute("select count(*) from TestExecuteMany")
+        count, = self.cursor.fetchone()
+        self.failUnlessEqual(count, len(rows))
+        self.failUnlessEqual(var.maxlength,
+                100 * self.connection.maxBytesPerCharacter)
+
+    def testExecuteManyWithExecption(self):
+        """test executing a statement multiple times (with exception)"""
+        self.cursor.execute("truncate table TestExecuteMany")
+        rows = [ { "p_Value" : n } for n in (1, 2, 3, 2, 5) ]
+        statement = "insert into TestExecuteMany (IntCol) values (:p_Value)"
+        self.failUnlessRaises(cx_Oracle.DatabaseError, self.cursor.executemany,
+                statement, rows)
+        self.failUnlessEqual(self.cursor.rowcount, 3)
+
+    def testPrepare(self):
+        """test preparing a statement and executing it multiple times"""
+        self.failUnlessEqual(self.cursor.statement, None)
+        statement = "begin :p_Value := :p_Value + 5; end;"
+        self.cursor.prepare(statement)
+        var = self.cursor.var(cx_Oracle.NUMBER)
+        self.failUnlessEqual(self.cursor.statement, statement)
+        var.setvalue(0, 2)
+        self.cursor.execute(None, p_Value = var)
+        self.failUnlessEqual(var.getvalue(), 7)
+        self.cursor.execute(None, p_Value = var)
+        self.failUnlessEqual(var.getvalue(), 12)
+        self.cursor.execute("begin :p_Value2 := 3; end;", p_Value2 = var)
+        self.failUnlessEqual(var.getvalue(), 3)
+
+    def testExceptionOnClose(self):
+        "confirm an exception is raised after closing a cursor"
+        self.cursor.close()
+        self.failUnlessRaises(cx_Oracle.InterfaceError, self.cursor.execute,
+                "select 1 from dual")
+
+    def testIterators(self):
+        """test iterators"""
+        self.cursor.execute("""
+                select IntCol
+                from TestNumbers
+                where IntCol between 1 and 3
+                order by IntCol""")
+        rows = []
+        for row in self.cursor:
+            rows.append(row[0])
+        self.failUnlessEqual(rows, [1, 2, 3])
+
+    def testIteratorsInterrupted(self):
+        """test iterators (with intermediate execute)"""
+        self.cursor.execute("truncate table TestExecuteMany")
+        self.cursor.execute("""
+                select IntCol
+                from TestNumbers
+                where IntCol between 1 and 3
+                order by IntCol""")
+        testIter = iter(self.cursor)
+        if sys.version_info[0] >= 3:
+            value, = next(testIter)
+        else:
+            value, = testIter.next()
+        self.cursor.execute("insert into TestExecuteMany (IntCol) values (1)")
+        if sys.version_info[0] >= 3:
+            self.failUnlessRaises(cx_Oracle.InterfaceError, next, testIter) 
+        else:
+            self.failUnlessRaises(cx_Oracle.InterfaceError, testIter.next) 
+
+    def testBindNames(self):
+        """test that bindnames() works correctly."""
+        self.failUnlessRaises(cx_Oracle.ProgrammingError,
+                self.cursor.bindnames)
+        self.cursor.prepare("begin null; end;")
+        self.failUnlessEqual(self.cursor.bindnames(), [])
+        self.cursor.prepare("begin :retval := :inval + 5; end;")
+        self.failUnlessEqual(self.cursor.bindnames(), ["RETVAL", "INVAL"])
+        self.cursor.prepare("begin :retval := :a * :a + :b * :b; end;")
+        self.failUnlessEqual(self.cursor.bindnames(), ["RETVAL", "A", "B"])
+        self.cursor.prepare("begin :a := :b + :c + :d + :e + :f + :g + " + \
+                ":h + :i + :j + :k + :l; end;")
+        self.failUnlessEqual(self.cursor.bindnames(),
+                ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L"])
+
+    def testBadPrepare(self):
+        """test that subsequent executes succeed after bad prepare"""
+        self.failUnlessRaises(cx_Oracle.DatabaseError,
+                self.cursor.execute,
+                "begin raise_application_error(-20000, 'this); end;")
+        self.cursor.execute("begin null; end;")
+
+    def testBadExecute(self):
+        """test that subsequent fetches fail after bad execute"""
+        self.failUnlessRaises(cx_Oracle.DatabaseError,
+                self.cursor.execute, "select y from dual")
+        self.failUnlessRaises(cx_Oracle.InterfaceError,
+                self.cursor.fetchall)
+
+    def testSetInputSizesMultipleMethod(self):
+        """test setting input sizes with both positional and keyword args"""
+        self.failUnlessRaises(cx_Oracle.InterfaceError,
+                self.cursor.setinputsizes, 5, x = 5)
+
+    def testSetInputSizesByPosition(self):
+        """test setting input sizes with positional args"""
+        var = self.cursor.var(cx_Oracle.STRING, 100)
+        self.cursor.setinputsizes(None, 5, None, 10, None, cx_Oracle.NUMBER)
+        self.cursor.execute("""
+                begin
+                  :1 := :2 || to_char(:3) || :4 || to_char(:5) || to_char(:6);
+                end;""", [var, 'test_', 5, '_second_', 3, 7])
+        self.failUnlessEqual(var.getvalue(), "test_5_second_37")
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/test/CursorVar.py b/desktop/core/ext-py/cx_Oracle-5.1.2/test/CursorVar.py
new file mode 100644
index 0000000..8bc1796
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/test/CursorVar.py
@@ -0,0 +1,48 @@
+"""Module for testing cursor variables."""
+
+import struct
+import sys
+
+class TestCursorVar(BaseTestCase):
+
+    def testBindCursor(self):
+        "test binding in a cursor"
+        cursor = self.connection.cursor()
+        self.failUnlessEqual(cursor.description, None)
+        self.cursor.execute("""
+                begin
+                  open :p_Cursor for select 'X' StringValue from dual;
+                end;""",
+                p_Cursor = cursor)
+        self.failUnlessEqual(cursor.description,
+                [ ('STRINGVALUE', cx_Oracle.FIXED_CHAR, 1, 1, 0, 0, 1) ])
+        self.failUnlessEqual(cursor.fetchall(), [('X',)])
+
+    def testBindCursorInPackage(self):
+        "test binding in a cursor from a package"
+        cursor = self.connection.cursor()
+        self.failUnlessEqual(cursor.description, None)
+        self.cursor.callproc("pkg_TestOutCursors.TestOutCursor", (2, cursor))
+        self.failUnlessEqual(cursor.description,
+                [ ('INTCOL', cx_Oracle.NUMBER, 10, 22, 9, 0, 0),
+                  ('STRINGCOL', cx_Oracle.STRING, 20, 20, 0, 0, 0) ])
+        self.failUnlessEqual(cursor.fetchall(),
+                [ (1, 'String 1'), (2, 'String 2') ])
+
+    def testFetchCursor(self):
+        "test fetching a cursor"
+        self.cursor.execute("""
+                select
+                  IntCol,
+                  cursor(select IntCol + 1 from dual) CursorValue
+                from TestNumbers
+                order by IntCol""")
+        size = struct.calcsize('P')
+        self.failUnlessEqual(self.cursor.description,
+                [ ('INTCOL', cx_Oracle.NUMBER, 10, 22, 9, 0, 0),
+                  ('CURSORVALUE', cx_Oracle.CURSOR, -1, size, 0, 0, 1) ])
+        for i in range(1, 11):
+            number, cursor = self.cursor.fetchone()
+            self.failUnlessEqual(number, i)
+            self.failUnlessEqual(cursor.fetchall(), [(i + 1,)])
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/test/DateTimeVar.py b/desktop/core/ext-py/cx_Oracle-5.1.2/test/DateTimeVar.py
new file mode 100644
index 0000000..5c5e603
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/test/DateTimeVar.py
@@ -0,0 +1,228 @@
+"""Module for testing date/time variables."""
+
+import datetime
+import time
+
+class TestDateTimeVar(BaseTestCase):
+
+    def setUp(self):
+        BaseTestCase.setUp(self)
+        self.rawData = []
+        self.dataByKey = {}
+        for i in range(1, 11):
+            timeTuple = (2002, 12, 9, 0, 0, 0, 0, 0, -1)
+            timeInTicks = time.mktime(timeTuple) + i * 86400 + i * 8640
+            dateCol = cx_Oracle.TimestampFromTicks(int(timeInTicks))
+            if i % 2:
+                timeInTicks = time.mktime(timeTuple) + i * 86400 * 2 + \
+                        i * 12960
+                nullableCol = cx_Oracle.TimestampFromTicks(int(timeInTicks))
+            else:
+                nullableCol = None
+            tuple = (i, dateCol, nullableCol)
+            self.rawData.append(tuple)
+            self.dataByKey[i] = tuple
+
+    def testBindDate(self):
+        "test binding in a date"
+        self.cursor.execute("""
+                select * from TestDates
+                where DateCol = :p_Value""",
+                p_Value = cx_Oracle.Timestamp(2002, 12, 13, 9, 36, 0))
+        self.failUnlessEqual(self.cursor.fetchall(), [self.dataByKey[4]])
+
+    def testBindDateTime(self):
+        "test binding in a Python 2.3 and higher date time"
+        self.cursor.execute("""
+                select * from TestDates
+                where DateCol = :value""",
+                value = datetime.datetime(2002, 12, 13, 9, 36, 0))
+        self.failUnlessEqual(self.cursor.fetchall(), [self.dataByKey[4]])
+
+    def testBindDateAfterString(self):
+        "test binding in a date after setting input sizes to a string"
+        self.cursor.setinputsizes(p_Value = 15)
+        self.cursor.execute("""
+                select * from TestDates
+                where DateCol = :p_Value""",
+                p_Value = cx_Oracle.Timestamp(2002, 12, 14, 12, 0, 0))
+        self.failUnlessEqual(self.cursor.fetchall(), [self.dataByKey[5]])
+
+    def testBindNull(self):
+        "test binding in a null"
+        self.cursor.setinputsizes(p_Value = cx_Oracle.DATETIME)
+        self.cursor.execute("""
+                select * from TestDates
+                where DateCol = :p_Value""",
+                p_Value = None)
+        self.failUnlessEqual(self.cursor.fetchall(), [])
+
+    def testBindDateArrayDirect(self):
+        "test binding in a date array"
+        returnValue = self.cursor.var(cx_Oracle.NUMBER)
+        array = [r[1] for r in self.rawData]
+        statement = """
+                begin
+                  :p_ReturnValue := pkg_TestDateArrays.TestInArrays(
+                      :p_StartValue, :p_BaseDate, :p_Array);
+                end;"""
+        self.cursor.execute(statement,
+                p_ReturnValue = returnValue,
+                p_StartValue = 5,
+                p_BaseDate = cx_Oracle.Date(2002, 12, 12),
+                p_Array = array)
+        self.failUnlessEqual(returnValue.getvalue(), 35.5)
+        array = array + array[:5]
+        self.cursor.execute(statement,
+                p_StartValue = 7,
+                p_BaseDate = cx_Oracle.Date(2002, 12, 13),
+                p_Array = array)
+        self.failUnlessEqual(returnValue.getvalue(), 24.0)
+
+    def testBindDateArrayBySizes(self):
+        "test binding in a date array (with setinputsizes)"
+        returnValue = self.cursor.var(cx_Oracle.NUMBER)
+        self.cursor.setinputsizes(p_Array = [cx_Oracle.DATETIME, 10])
+        array = [r[1] for r in self.rawData]
+        self.cursor.execute("""
+                begin
+                  :p_ReturnValue := pkg_TestDateArrays.TestInArrays(
+                      :p_StartValue, :p_BaseDate, :p_Array);
+                end;""",
+                p_ReturnValue = returnValue,
+                p_StartValue = 6,
+                p_BaseDate = cx_Oracle.Date(2002, 12, 13),
+                p_Array = array)
+        self.failUnlessEqual(returnValue.getvalue(), 26.5)
+
+    def testBindDateArrayByVar(self):
+        "test binding in a date array (with arrayvar)"
+        returnValue = self.cursor.var(cx_Oracle.NUMBER)
+        array = self.cursor.arrayvar(cx_Oracle.DATETIME, 10, 20)
+        array.setvalue(0, [r[1] for r in self.rawData])
+        self.cursor.execute("""
+                begin
+                  :p_ReturnValue := pkg_TestDateArrays.TestInArrays(
+                      :p_StartValue, :p_BaseDate, :p_Array);
+                end;""",
+                p_ReturnValue = returnValue,
+                p_StartValue = 7,
+                p_BaseDate = cx_Oracle.Date(2002, 12, 14),
+                p_Array = array)
+        self.failUnlessEqual(returnValue.getvalue(), 17.5)
+
+    def testBindInOutDateArrayByVar(self):
+        "test binding in/out a date array (with arrayvar)"
+        array = self.cursor.arrayvar(cx_Oracle.DATETIME, 10, 100)
+        originalData = [r[1] for r in self.rawData]
+        array.setvalue(0, originalData)
+        self.cursor.execute("""
+                begin
+                  pkg_TestDateArrays.TestInOutArrays(:p_NumElems, :p_Array);
+                end;""",
+                p_NumElems = 5,
+                p_Array = array)
+        self.failUnlessEqual(array.getvalue(),
+                [ cx_Oracle.Timestamp(2002, 12, 17, 2, 24, 0),
+                  cx_Oracle.Timestamp(2002, 12, 18, 4, 48, 0),
+                  cx_Oracle.Timestamp(2002, 12, 19, 7, 12, 0),
+                  cx_Oracle.Timestamp(2002, 12, 20, 9, 36, 0),
+                  cx_Oracle.Timestamp(2002, 12, 21, 12, 0, 0) ] + \
+                originalData[5:])
+
+    def testBindOutDateArrayByVar(self):
+        "test binding out a date array (with arrayvar)"
+        array = self.cursor.arrayvar(cx_Oracle.DATETIME, 6, 100)
+        self.cursor.execute("""
+                begin
+                  pkg_TestDateArrays.TestOutArrays(:p_NumElems, :p_Array);
+                end;""",
+                p_NumElems = 6,
+                p_Array = array)
+        self.failUnlessEqual(array.getvalue(),
+                [ cx_Oracle.Timestamp(2002, 12, 13, 4, 48, 0),
+                  cx_Oracle.Timestamp(2002, 12, 14, 9, 36, 0),
+                  cx_Oracle.Timestamp(2002, 12, 15, 14, 24, 0),
+                  cx_Oracle.Timestamp(2002, 12, 16, 19, 12, 0),
+                  cx_Oracle.Timestamp(2002, 12, 18, 0, 0, 0),
+                  cx_Oracle.Timestamp(2002, 12, 19, 4, 48, 0) ])
+
+    def testBindOutSetInputSizes(self):
+        "test binding out with set input sizes defined"
+        vars = self.cursor.setinputsizes(p_Value = cx_Oracle.DATETIME)
+        self.cursor.execute("""
+                begin
+                  :p_Value := to_date(20021209, 'YYYYMMDD');
+                end;""")
+        self.failUnlessEqual(vars["p_Value"].getvalue(),
+               cx_Oracle.Timestamp(2002, 12, 9))
+
+    def testBindInOutSetInputSizes(self):
+        "test binding in/out with set input sizes defined"
+        vars = self.cursor.setinputsizes(p_Value = cx_Oracle.DATETIME)
+        self.cursor.execute("""
+                begin
+                  :p_Value := :p_Value + 5.25;
+                end;""",
+                p_Value = cx_Oracle.Timestamp(2002, 12, 12, 10, 0, 0))
+        self.failUnlessEqual(vars["p_Value"].getvalue(),
+                cx_Oracle.Timestamp(2002, 12, 17, 16, 0, 0))
+
+    def testBindOutVar(self):
+        "test binding out with cursor.var() method"
+        var = self.cursor.var(cx_Oracle.DATETIME)
+        self.cursor.execute("""
+                begin
+                  :p_Value := to_date('20021231 12:31:00',
+                      'YYYYMMDD HH24:MI:SS');
+                end;""",
+                p_Value = var)
+        self.failUnlessEqual(var.getvalue(),
+               cx_Oracle.Timestamp(2002, 12, 31, 12, 31, 0))
+
+    def testBindInOutVarDirectSet(self):
+        "test binding in/out with cursor.var() method"
+        var = self.cursor.var(cx_Oracle.DATETIME)
+        var.setvalue(0, cx_Oracle.Timestamp(2002, 12, 9, 6, 0, 0))
+        self.cursor.execute("""
+                begin
+                  :p_Value := :p_Value + 5.25;
+                end;""",
+                p_Value = var)
+        self.failUnlessEqual(var.getvalue(),
+                cx_Oracle.Timestamp(2002, 12, 14, 12, 0, 0))
+
+    def testCursorDescription(self):
+        "test cursor description is accurate"
+        self.cursor.execute("select * from TestDates")
+        self.failUnlessEqual(self.cursor.description,
+                [ ('INTCOL', cx_Oracle.NUMBER, 10, 22, 9, 0, 0),
+                  ('DATECOL', cx_Oracle.DATETIME, 23, 7, 0, 0, 0),
+                  ('NULLABLECOL', cx_Oracle.DATETIME, 23, 7, 0, 0, 1) ])
+
+    def testFetchAll(self):
+        "test that fetching all of the data returns the correct results"
+        self.cursor.execute("select * From TestDates order by IntCol")
+        self.failUnlessEqual(self.cursor.fetchall(), self.rawData)
+        self.failUnlessEqual(self.cursor.fetchall(), [])
+
+    def testFetchMany(self):
+        "test that fetching data in chunks returns the correct results"
+        self.cursor.execute("select * From TestDates order by IntCol")
+        self.failUnlessEqual(self.cursor.fetchmany(3), self.rawData[0:3])
+        self.failUnlessEqual(self.cursor.fetchmany(2), self.rawData[3:5])
+        self.failUnlessEqual(self.cursor.fetchmany(4), self.rawData[5:9])
+        self.failUnlessEqual(self.cursor.fetchmany(3), self.rawData[9:])
+        self.failUnlessEqual(self.cursor.fetchmany(3), [])
+
+    def testFetchOne(self):
+        "test that fetching a single row returns the correct results"
+        self.cursor.execute("""
+                select *
+                from TestDates
+                where IntCol in (3, 4)
+                order by IntCol""")
+        self.failUnlessEqual(self.cursor.fetchone(), self.dataByKey[3])
+        self.failUnlessEqual(self.cursor.fetchone(), self.dataByKey[4])
+        self.failUnlessEqual(self.cursor.fetchone(), None)
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/test/IntervalVar.py b/desktop/core/ext-py/cx_Oracle-5.1.2/test/IntervalVar.py
new file mode 100644
index 0000000..2b5ab77
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/test/IntervalVar.py
@@ -0,0 +1,121 @@
+"""Module for testing interval variables."""
+
+import datetime
+
+class TestIntervalVar(BaseTestCase):
+
+    def setUp(self):
+        BaseTestCase.setUp(self)
+        self.rawData = []
+        self.dataByKey = {}
+        for i in range(1, 11):
+            delta = datetime.timedelta(days = i, hours = i, minutes = i * 2,
+                    seconds = i * 3)
+            if i % 2 == 0:
+                nullableDelta = None
+            else:
+                nullableDelta = datetime.timedelta(days = i + 5, hours = i + 2,
+                        minutes = i * 2 + 5, seconds = i * 3 + 5)
+            tuple = (i, delta, nullableDelta)
+            self.rawData.append(tuple)
+            self.dataByKey[i] = tuple
+
+    def testBindInterval(self):
+        "test binding in an interval"
+        self.cursor.setinputsizes(value = cx_Oracle.INTERVAL)
+        self.cursor.execute("""
+                select * from TestIntervals
+                where IntervalCol = :value""",
+                value = datetime.timedelta(days = 5, hours = 5, minutes = 10,
+                        seconds = 15))
+        self.failUnlessEqual(self.cursor.fetchall(), [self.dataByKey[5]])
+
+    def testBindNull(self):
+        "test binding in a null"
+        self.cursor.setinputsizes(value = cx_Oracle.INTERVAL)
+        self.cursor.execute("""
+                select * from TestIntervals
+                where IntervalCol = :value""",
+                value = None)
+        self.failUnlessEqual(self.cursor.fetchall(), [])
+
+    def testBindOutSetInputSizes(self):
+        "test binding out with set input sizes defined"
+        vars = self.cursor.setinputsizes(value = cx_Oracle.INTERVAL)
+        self.cursor.execute("""
+                begin
+                  :value := to_dsinterval('8 09:24:18.123789');
+                end;""")
+        self.failUnlessEqual(vars["value"].getvalue(),
+                datetime.timedelta(days = 8, hours = 9, minutes = 24,
+                        seconds = 18, microseconds = 123789))
+
+    def testBindInOutSetInputSizes(self):
+        "test binding in/out with set input sizes defined"
+        vars = self.cursor.setinputsizes(value = cx_Oracle.INTERVAL)
+        self.cursor.execute("""
+                begin
+                  :value := :value + to_dsinterval('5 08:30:00');
+                end;""",
+                value = datetime.timedelta(days = 5, hours = 2, minutes = 15))
+        self.failUnlessEqual(vars["value"].getvalue(),
+                datetime.timedelta(days = 10, hours = 10, minutes = 45))
+
+    def testBindOutVar(self):
+        "test binding out with cursor.var() method"
+        var = self.cursor.var(cx_Oracle.INTERVAL)
+        self.cursor.execute("""
+                begin
+                  :value := to_dsinterval('15 18:35:45.586');
+                end;""",
+                value = var)
+        self.failUnlessEqual(var.getvalue(),
+                datetime.timedelta(days = 15, hours = 18, minutes = 35,
+                        seconds = 45, milliseconds = 586))
+
+    def testBindInOutVarDirectSet(self):
+        "test binding in/out with cursor.var() method"
+        var = self.cursor.var(cx_Oracle.INTERVAL)
+        var.setvalue(0, datetime.timedelta(days = 1, minutes = 50))
+        self.cursor.execute("""
+                begin
+                  :value := :value + to_dsinterval('8 05:15:00');
+                end;""",
+                value = var)
+        self.failUnlessEqual(var.getvalue(),
+                datetime.timedelta(days = 9, hours = 6, minutes = 5))
+
+    def testCursorDescription(self):
+        "test cursor description is accurate"
+        self.cursor.execute("select * from TestIntervals")
+        self.failUnlessEqual(self.cursor.description,
+                [ ('INTCOL', cx_Oracle.NUMBER, 10, 22, 9, 0, 0),
+                  ('INTERVALCOL', cx_Oracle.INTERVAL, -1, 11, 0, 0, 0),
+                  ('NULLABLECOL', cx_Oracle.INTERVAL, -1, 11, 0, 0, 1) ])
+
+    def testFetchAll(self):
+        "test that fetching all of the data returns the correct results"
+        self.cursor.execute("select * From TestIntervals order by IntCol")
+        self.failUnlessEqual(self.cursor.fetchall(), self.rawData)
+        self.failUnlessEqual(self.cursor.fetchall(), [])
+
+    def testFetchMany(self):
+        "test that fetching data in chunks returns the correct results"
+        self.cursor.execute("select * From TestIntervals order by IntCol")
+        self.failUnlessEqual(self.cursor.fetchmany(3), self.rawData[0:3])
+        self.failUnlessEqual(self.cursor.fetchmany(2), self.rawData[3:5])
+        self.failUnlessEqual(self.cursor.fetchmany(4), self.rawData[5:9])
+        self.failUnlessEqual(self.cursor.fetchmany(3), self.rawData[9:])
+        self.failUnlessEqual(self.cursor.fetchmany(3), [])
+
+    def testFetchOne(self):
+        "test that fetching a single row returns the correct results"
+        self.cursor.execute("""
+                select *
+                from TestIntervals
+                where IntCol in (3, 4)
+                order by IntCol""")
+        self.failUnlessEqual(self.cursor.fetchone(), self.dataByKey[3])
+        self.failUnlessEqual(self.cursor.fetchone(), self.dataByKey[4])
+        self.failUnlessEqual(self.cursor.fetchone(), None)
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/test/LobVar.py b/desktop/core/ext-py/cx_Oracle-5.1.2/test/LobVar.py
new file mode 100644
index 0000000..bb4609b
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/test/LobVar.py
@@ -0,0 +1,156 @@
+"""Module for testing LOB (CLOB and BLOB) variables."""
+
+import sys
+
+class TestLobVar(BaseTestCase):
+
+    def __PerformTest(self, type, inputType):
+        longString = ""
+        directType = getattr(cx_Oracle, type)
+        self.cursor.execute("truncate table Test%ss" % type)
+        for i in range(0, 11):
+            if i > 0:
+                char = chr(ord('A') + i - 1)
+                longString += char * 25000
+            elif inputType != directType:
+                continue
+            self.cursor.setinputsizes(longString = inputType)
+            if type == "BLOB" and sys.version_info[0] >= 3:
+                bindValue = longString.encode("ascii")
+            else:
+                bindValue = longString
+            self.cursor.execute("""
+                    insert into Test%ss (
+                      IntCol,
+                      %sCol
+                    ) values (
+                      :integerValue,
+                      :longString
+                    )""" % (type, type),
+                    integerValue = i,
+                    longString = bindValue)
+        self.connection.commit()
+        self.cursor.execute("""
+                select *
+                from Test%ss
+                order by IntCol""" % type)
+        longString = ""
+        for row in self.cursor:
+            integerValue, lob = row
+            if integerValue == 0:
+                self.failUnlessEqual(lob.size(), 0)
+                expectedValue = ""
+                if type == "BLOB" and sys.version_info[0] >= 3:
+                    expectedValue = expectedValue.encode("ascii")
+                self.failUnlessEqual(lob.read(), expectedValue)
+            else:
+                char = chr(ord('A') + integerValue - 1)
+                prevChar = chr(ord('A') + integerValue - 2)
+                longString += char * 25000
+                if type == "BLOB" and sys.version_info[0] >= 3:
+                    actualValue = longString.encode("ascii")
+                    char = char.encode("ascii")
+                    prevChar = prevChar.encode("ascii")
+                else:
+                    actualValue = longString
+                self.failUnlessEqual(lob.size(), len(actualValue))
+                self.failUnlessEqual(lob.read(), actualValue)
+                if type == "CLOB":
+                    self.failUnlessEqual(str(lob), actualValue)
+                self.failUnlessEqual(lob.read(len(actualValue)), char)
+            if integerValue > 1:
+                offset = (integerValue - 1) * 25000 - 4
+                string = prevChar * 5 + char * 5
+                self.failUnlessEqual(lob.read(offset, 10), string)
+
+    def __TestTrim(self, type):
+        self.cursor.execute("truncate table Test%ss" % type)
+        self.cursor.setinputsizes(longString = getattr(cx_Oracle, type))
+        longString = "X" * 75000
+        if type == "BLOB" and sys.version_info[0] >= 3:
+            longString = longString.encode("ascii")
+        self.cursor.execute("""
+                insert into Test%ss (
+                  IntCol,
+                  %sCol
+                ) values (
+                  :integerValue,
+                  :longString
+                )""" % (type, type),
+                integerValue = 1,
+                longString = longString)
+        self.cursor.execute("""
+                select %sCol
+                from Test%ss
+                where IntCol = 1""" % (type, type))
+        lob, = self.cursor.fetchone()
+        self.failUnlessEqual(lob.size(), 75000)
+        lob.trim(25000)
+        self.failUnlessEqual(lob.size(), 25000)
+        lob.trim()
+        self.failUnlessEqual(lob.size(), 0)
+
+    def testBLOBCursorDescription(self):
+        "test cursor description is accurate for BLOBs"
+        self.cursor.execute("select * from TestBLOBs")
+        self.failUnlessEqual(self.cursor.description,
+                [ ('INTCOL', cx_Oracle.NUMBER, 10, 22, 9, 0, 0),
+                  ('BLOBCOL', cx_Oracle.BLOB, -1, 4000, 0, 0, 0) ])
+
+    def testBLOBsDirect(self):
+        "test binding and fetching BLOB data (directly)"
+        self.__PerformTest("BLOB", cx_Oracle.BLOB)
+
+    def testBLOBsIndirect(self):
+        "test binding and fetching BLOB data (indirectly)"
+        self.__PerformTest("BLOB", cx_Oracle.LONG_BINARY)
+
+    def testBLOBTrim(self):
+        "test trimming a BLOB"
+        self.__TestTrim("BLOB")
+
+    def testCLOBCursorDescription(self):
+        "test cursor description is accurate for CLOBs"
+        self.cursor.execute("select * from TestCLOBs")
+        self.failUnlessEqual(self.cursor.description,
+                [ ('INTCOL', cx_Oracle.NUMBER, 10, 22, 9, 0, 0),
+                  ('CLOBCOL', cx_Oracle.CLOB, -1, 4000, 0, 0, 0) ])
+
+    def testCLOBsDirect(self):
+        "test binding and fetching CLOB data (directly)"
+        self.__PerformTest("CLOB", cx_Oracle.CLOB)
+
+    def testCLOBsIndirect(self):
+        "test binding and fetching CLOB data (indirectly)"
+        self.__PerformTest("CLOB", cx_Oracle.LONG_STRING)
+
+    def testCLOBTrim(self):
+        "test trimming a CLOB"
+        self.__TestTrim("CLOB")
+
+    def testMultipleFetch(self):
+        "test retrieving data from a CLOB after multiple fetches"
+        self.cursor.arraysize = 1
+        self.cursor.execute("select CLOBCol from TestCLOBS")
+        rows = self.cursor.fetchall()
+        self.failUnlessRaises(cx_Oracle.ProgrammingError, rows[1][0].read)
+
+    def testNCLOBCursorDescription(self):
+        "test cursor description is accurate for NCLOBs"
+        self.cursor.execute("select * from TestNCLOBs")
+        self.failUnlessEqual(self.cursor.description,
+                [ ('INTCOL', cx_Oracle.NUMBER, 10, 22, 9, 0, 0),
+                  ('NCLOBCOL', cx_Oracle.NCLOB, -1, 4000, 0, 0, 0) ])
+
+    def testNCLOBsDirect(self):
+        "test binding and fetching NCLOB data (directly)"
+        self.__PerformTest("NCLOB", cx_Oracle.NCLOB)
+
+    def testNCLOBsIndirect(self):
+        "test binding and fetching NCLOB data (indirectly)"
+        self.__PerformTest("NCLOB", cx_Oracle.LONG_STRING)
+
+    def testNCLOBTrim(self):
+        "test trimming a CLOB"
+        self.__TestTrim("CLOB")
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/test/LongVar.py b/desktop/core/ext-py/cx_Oracle-5.1.2/test/LongVar.py
new file mode 100644
index 0000000..2194c59
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/test/LongVar.py
@@ -0,0 +1,101 @@
+"""Module for testing long and long raw variables."""
+
+import sys
+
+class TestLongVar(BaseTestCase):
+
+    def __PerformTest(self, a_Type, a_InputType):
+        self.cursor.execute("truncate table Test%ss" % a_Type)
+        longString = ""
+        for i in range(1, 11):
+            char = chr(ord('A') + i - 1)
+            longString += char * 25000
+            self.cursor.setinputsizes(p_LongString = a_InputType)
+            if a_Type == "LongRaw" and sys.version_info[0] >= 3:
+                bindValue = longString.encode("ascii")
+            else:
+                bindValue = longString
+            self.cursor.execute("""
+                    insert into Test%ss (
+                      IntCol,
+                      %sCol
+                    ) values (
+                      :p_IntegerValue,
+                      :p_LongString
+                    )""" % (a_Type, a_Type),
+                    p_IntegerValue = i,
+                    p_LongString = bindValue)
+        self.connection.commit()
+        self.cursor.setoutputsize(250000, 2)
+        self.cursor.execute("""
+                select *
+                from Test%ss
+                order by IntCol""" % a_Type)
+        longString = ""
+        while 1:
+            row = self.cursor.fetchone()
+            if row is None:
+                break
+            integerValue, fetchedValue = row
+            char = chr(ord('A') + integerValue - 1)
+            longString += char * 25000
+            if a_Type == "LongRaw" and sys.version_info[0] >= 3:
+                actualValue = longString.encode("ascii")
+            else:
+                actualValue = longString
+            self.failUnlessEqual(len(fetchedValue), integerValue * 25000)
+            self.failUnlessEqual(fetchedValue, actualValue)
+
+    def testLongs(self):
+        "test binding and fetching long data"
+        self.__PerformTest("Long", cx_Oracle.LONG_STRING)
+
+    def testLongRaws(self):
+        "test binding and fetching long raw data"
+        self.__PerformTest("LongRaw", cx_Oracle.LONG_BINARY)
+
+    def testLongCursorDescription(self):
+        "test cursor description is accurate for longs"
+        self.cursor.execute("select * from TestLongs")
+        self.failUnlessEqual(self.cursor.description,
+                [ ('INTCOL', cx_Oracle.NUMBER, 10, 22, 9, 0, 0),
+                  ('LONGCOL', cx_Oracle.LONG_STRING, -1, 0, 0, 0, 0) ])
+
+    def testLongRawCursorDescription(self):
+        "test cursor description is accurate for long raws"
+        self.cursor.execute("select * from TestLongRaws")
+        self.failUnlessEqual(self.cursor.description,
+                [ ('INTCOL', cx_Oracle.NUMBER, 10, 22, 9, 0, 0),
+                  ('LONGRAWCOL', cx_Oracle.LONG_BINARY, -1, 0, 0, 0, 0) ])
+
+    def testSetOutputSizesAll(self):
+        "test setoutputsizes is valid (all)"
+        self.cursor.setoutputsize(25000)
+        self.cursor.execute("select * from TestLongRaws")
+        longVar = self.cursor.fetchvars[1]
+        self.failUnlessEqual(longVar.size, 25000)
+        self.failUnlessEqual(longVar.bufferSize, 25004)
+
+    def testSetOutputSizesWrongColumn(self):
+        "test setoutputsizes is valid (wrong column)"
+        self.cursor.setoutputsize(25000, 1)
+        self.cursor.execute("select * from TestLongs")
+        longVar = self.cursor.fetchvars[1]
+        self.failUnlessEqual(longVar.size, 131072)
+        self.failUnlessEqual(longVar.bufferSize,
+                131072 * self.connection.maxBytesPerCharacter + 4)
+
+    def testSetOutputSizesRightColumn(self):
+        "test setoutputsizes is valid (right column)"
+        self.cursor.setoutputsize(35000, 2)
+        self.cursor.execute("select * from TestLongRaws")
+        longVar = self.cursor.fetchvars[1]
+        self.failUnlessEqual(longVar.size, 35000)
+        self.failUnlessEqual(longVar.bufferSize, 35004)
+
+    def testArraySizeTooLarge(self):
+        "test array size too large generates an exception"
+        self.cursor.arraysize = 65536
+        self.failUnlessRaises(ValueError, self.cursor.execute,
+                "select * from TestLongRaws")
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/test/NumberVar.py b/desktop/core/ext-py/cx_Oracle-5.1.2/test/NumberVar.py
new file mode 100644
index 0000000..902f964
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/test/NumberVar.py
@@ -0,0 +1,271 @@
+"""Module for testing number variables."""
+
+import cx_Oracle
+import decimal
+
+class TestNumberVar(BaseTestCase):
+
+    def setUp(self):
+      BaseTestCase.setUp(self)
+      self.rawData = []
+      self.dataByKey = {}
+      for i in range(1, 11):
+          numberCol = i + i * 0.25
+          floatCol = i + i * 0.75
+          unconstrainedCol = i ** 3 + i * 0.5
+          if i % 2:
+              nullableCol = 143L ** i
+          else:
+              nullableCol = None
+          dataTuple = (i, numberCol, floatCol, unconstrainedCol, nullableCol)
+          self.rawData.append(dataTuple)
+          self.dataByKey[i] = dataTuple
+
+    def testBindDecimal(self):
+        "test binding in a decimal.Decimal"
+        self.cursor.execute("""
+                select * from TestNumbers
+                where NumberCol - :value1 - :value2 = trunc(NumberCol)""",
+                value1 = decimal.Decimal("0.20"),
+                value2 = decimal.Decimal("0.05"))
+        self.failUnlessEqual(self.cursor.fetchall(),
+                [self.dataByKey[1], self.dataByKey[5], self.dataByKey[9]])
+
+    def testBindFloat(self):
+        "test binding in a float"
+        self.cursor.execute("""
+                select * from TestNumbers
+                where NumberCol - :value = trunc(NumberCol)""",
+                value = 0.25)
+        self.failUnlessEqual(self.cursor.fetchall(),
+                [self.dataByKey[1], self.dataByKey[5], self.dataByKey[9]])
+
+    def testBindInteger(self):
+        "test binding in an integer"
+        self.cursor.execute("""
+                select * from TestNumbers
+                where IntCol = :value""",
+                value = 2)
+        self.failUnlessEqual(self.cursor.fetchall(), [self.dataByKey[2]])
+
+    def testBindSmallLong(self):
+        "test binding in a small long integer"
+        self.cursor.execute("""
+                select * from TestNumbers
+                where IntCol = :value""",
+                value = 3L)
+        self.failUnlessEqual(self.cursor.fetchall(), [self.dataByKey[3]])
+
+    def testBindLargeLong(self):
+        "test binding in a large long integer"
+        valueVar = self.cursor.var(cx_Oracle.NUMBER)
+        valueVar.setvalue(0, 6088343244)
+        self.cursor.execute("""
+                begin
+                  :value := :value + 5;
+                end;""",
+                value = valueVar)
+        value = valueVar.getvalue()
+        self.failUnlessEqual(value, 6088343249)
+
+    def testBindIntegerAfterString(self):
+        "test binding in an number after setting input sizes to a string"
+        self.cursor.setinputsizes(value = 15)
+        self.cursor.execute("""
+                select * from TestNumbers
+                where IntCol = :value""",
+                value = 3)
+        self.failUnlessEqual(self.cursor.fetchall(), [self.dataByKey[3]])
+
+    def testBindNull(self):
+        "test binding in a null"
+        self.cursor.execute("""
+                select * from TestNumbers
+                where IntCol = :value""",
+                value = None)
+        self.failUnlessEqual(self.cursor.fetchall(), [])
+
+    def testBindNumberArrayDirect(self):
+        "test binding in a number array"
+        returnValue = self.cursor.var(cx_Oracle.NUMBER)
+        array = [r[1] for r in self.rawData]
+        statement = """
+                begin
+                  :p_ReturnValue := pkg_TestNumberArrays.TestInArrays(
+                      :p_StartValue, :p_Array);
+                end;"""
+        self.cursor.execute(statement,
+                p_ReturnValue = returnValue,
+                p_StartValue = 5,
+                p_Array = array)
+        self.failUnlessEqual(returnValue.getvalue(), 73.75)
+        array = range(15)
+        self.cursor.execute(statement,
+                p_StartValue = 10,
+                p_Array = array)
+        self.failUnlessEqual(returnValue.getvalue(), 115.0)
+
+    def testBindNumberArrayBySizes(self):
+        "test binding in a number array (with setinputsizes)"
+        returnValue = self.cursor.var(cx_Oracle.NUMBER)
+        self.cursor.setinputsizes(p_Array = [cx_Oracle.NUMBER, 10])
+        array = [r[1] for r in self.rawData]
+        self.cursor.execute("""
+                begin
+                  :p_ReturnValue := pkg_TestNumberArrays.TestInArrays(
+                      :p_StartValue, :p_Array);
+                end;""",
+                p_ReturnValue = returnValue,
+                p_StartValue = 6,
+                p_Array = array)
+        self.failUnlessEqual(returnValue.getvalue(), 74.75)
+
+    def testBindNumberArrayByVar(self):
+        "test binding in a number array (with arrayvar)"
+        returnValue = self.cursor.var(cx_Oracle.NUMBER)
+        array = self.cursor.arrayvar(cx_Oracle.NUMBER,
+                [r[1] for r in self.rawData])
+        array.setvalue(0, [r[1] for r in self.rawData])
+        self.cursor.execute("""
+                begin
+                  :p_ReturnValue := pkg_TestNumberArrays.TestInArrays(
+                      :p_IntegerValue, :p_Array);
+                end;""",
+                p_ReturnValue = returnValue,
+                p_IntegerValue = 7,
+                p_Array = array)
+        self.failUnlessEqual(returnValue.getvalue(), 75.75)
+
+    def testBindZeroLengthNumberArrayByVar(self):
+        "test binding in a zero length number array (with arrayvar)"
+        returnValue = self.cursor.var(cx_Oracle.NUMBER)
+        array = self.cursor.arrayvar(cx_Oracle.NUMBER, 0)
+        self.cursor.execute("""
+                begin
+                  :p_ReturnValue := pkg_TestNumberArrays.TestInArrays(
+                      :p_IntegerValue, :p_Array);
+                end;""",
+                p_ReturnValue = returnValue,
+                p_IntegerValue = 8,
+                p_Array = array)
+        self.failUnlessEqual(returnValue.getvalue(), 8.0)
+        self.failUnlessEqual(array.getvalue(), [])
+
+    def testBindInOutNumberArrayByVar(self):
+        "test binding in/out a number array (with arrayvar)"
+        array = self.cursor.arrayvar(cx_Oracle.NUMBER, 10)
+        originalData = [r[1] for r in self.rawData]
+        expectedData = [originalData[i - 1] * 10 for i in range(1, 6)] + \
+                originalData[5:]
+        array.setvalue(0, originalData)
+        self.cursor.execute("""
+                begin
+                  pkg_TestNumberArrays.TestInOutArrays(:p_NumElems, :p_Array);
+                end;""",
+                p_NumElems = 5,
+                p_Array = array)
+        self.failUnlessEqual(array.getvalue(), expectedData)
+
+    def testBindOutNumberArrayByVar(self):
+        "test binding out a Number array (with arrayvar)"
+        array = self.cursor.arrayvar(cx_Oracle.NUMBER, 6)
+        expectedData = [i * 100 for i in range(1, 7)]
+        self.cursor.execute("""
+                begin
+                  pkg_TestNumberArrays.TestOutArrays(:p_NumElems, :p_Array);
+                end;""",
+                p_NumElems = 6,
+                p_Array = array)
+        self.failUnlessEqual(array.getvalue(), expectedData)
+
+    def testBindOutSetInputSizes(self):
+        "test binding out with set input sizes defined"
+        vars = self.cursor.setinputsizes(value = cx_Oracle.NUMBER)
+        self.cursor.execute("""
+                begin
+                  :value := 5;
+                end;""")
+        self.failUnlessEqual(vars["value"].getvalue(), 5)
+
+    def testBindInOutSetInputSizes(self):
+        "test binding in/out with set input sizes defined"
+        vars = self.cursor.setinputsizes(value = cx_Oracle.NUMBER)
+        self.cursor.execute("""
+                begin
+                  :value := :value + 5;
+                end;""",
+                value = 1.25)
+        self.failUnlessEqual(vars["value"].getvalue(), 6.25)
+
+    def testBindOutVar(self):
+        "test binding out with cursor.var() method"
+        var = self.cursor.var(cx_Oracle.NUMBER)
+        self.cursor.execute("""
+                begin
+                  :value := 5;
+                end;""",
+                value = var)
+        self.failUnlessEqual(var.getvalue(), 5)
+
+    def testBindInOutVarDirectSet(self):
+        "test binding in/out with cursor.var() method"
+        var = self.cursor.var(cx_Oracle.NUMBER)
+        var.setvalue(0, 2.25)
+        self.cursor.execute("""
+                begin
+                  :value := :value + 5;
+                end;""",
+                value = var)
+        self.failUnlessEqual(var.getvalue(), 7.25)
+
+    def testCursorDescription(self):
+        "test cursor description is accurate"
+        self.cursor.execute("select * from TestNumbers")
+        self.failUnlessEqual(self.cursor.description,
+                [ ('INTCOL', cx_Oracle.NUMBER, 10, 22, 9, 0, 0),
+                  ('NUMBERCOL', cx_Oracle.NUMBER, 13, 22, 9, 2, 0),
+                  ('FLOATCOL', cx_Oracle.NUMBER, 127, 22, 126, -127, 0),
+                  ('UNCONSTRAINEDCOL', cx_Oracle.NUMBER, 127, 22, 0, -127, 0),
+                  ('NULLABLECOL', cx_Oracle.NUMBER, 39, 22, 38, 0, 1) ])
+
+    def testFetchAll(self):
+        "test that fetching all of the data returns the correct results"
+        self.cursor.execute("select * From TestNumbers order by IntCol")
+        self.failUnlessEqual(self.cursor.fetchall(), self.rawData)
+        self.failUnlessEqual(self.cursor.fetchall(), [])
+
+    def testFetchMany(self):
+        "test that fetching data in chunks returns the correct results"
+        self.cursor.execute("select * From TestNumbers order by IntCol")
+        self.failUnlessEqual(self.cursor.fetchmany(3), self.rawData[0:3])
+        self.failUnlessEqual(self.cursor.fetchmany(2), self.rawData[3:5])
+        self.failUnlessEqual(self.cursor.fetchmany(4), self.rawData[5:9])
+        self.failUnlessEqual(self.cursor.fetchmany(3), self.rawData[9:])
+        self.failUnlessEqual(self.cursor.fetchmany(3), [])
+
+    def testFetchOne(self):
+        "test that fetching a single row returns the correct results"
+        self.cursor.execute("""
+                select *
+                from TestNumbers
+                where IntCol in (3, 4)
+                order by IntCol""")
+        self.failUnlessEqual(self.cursor.fetchone(), self.dataByKey[3])
+        self.failUnlessEqual(self.cursor.fetchone(), self.dataByKey[4])
+        self.failUnlessEqual(self.cursor.fetchone(), None)
+
+    def testReturnAsLong(self):
+        "test that fetching a long integer returns such in Python"
+        self.cursor.execute("""
+                select NullableCol
+                from TestNumbers
+                where IntCol = 9""")
+        col, = self.cursor.fetchone()
+        self.failUnless(isinstance(col, long), "long integer not returned")
+
+    def testReturnAsFloat(self):
+        "test that fetching a floating point number returns such in Python"
+        self.cursor.execute("select 1.25 from dual")
+        result, = self.cursor.fetchone()
+        self.failUnlessEqual(result, 1.25)
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/test/ObjectVar.py b/desktop/core/ext-py/cx_Oracle-5.1.2/test/ObjectVar.py
new file mode 100644
index 0000000..49977e4
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/test/ObjectVar.py
@@ -0,0 +1,53 @@
+"""Module for testing object variables."""
+
+import sys
+
+class TestObjectVar(BaseTestCase):
+
+    def __TestData(self, expectedIntValue, expectedObjectValue,
+            expectedArrayValue):
+        intValue, objectValue, arrayValue = self.cursor.fetchone()
+        if objectValue is not None:
+            attributeValues = []
+            for attribute in objectValue.type.attributes:
+                value = getattr(objectValue, attribute.name)
+                attributeValues.append(value)
+            objectValue = tuple(attributeValues)
+        self.failUnlessEqual(intValue, expectedIntValue)
+        self.failUnlessEqual(objectValue, expectedObjectValue)
+        self.failUnlessEqual(arrayValue, expectedArrayValue)
+
+    def testFetchData(self):
+        "test fetching objects"
+        self.cursor.execute("""
+                select
+                  IntCol,
+                  ObjectCol,
+                  ArrayCol
+                from TestObjects
+                order by IntCol""")
+        self.failUnlessEqual(self.cursor.description,
+                [ ('INTCOL', cx_Oracle.NUMBER, 10, 22, 9, 0, 0),
+                  ('OBJECTCOL', cx_Oracle.OBJECT, -1, 2000, 0, 0, 1),
+                  ('ARRAYCOL', cx_Oracle.OBJECT, -1, 2000, 0, 0, 1) ])
+        self.__TestData(1, (1, 'First row', 'First     ',
+                cx_Oracle.Timestamp(2007, 3, 6, 0, 0, 0),
+                cx_Oracle.Timestamp(2008, 9, 12, 16, 40)), [5, 10, None, 20])
+        self.__TestData(2, None, [3, None, 9, 12, 15])
+        self.__TestData(3, (3, 'Third row', 'Third     ',
+                cx_Oracle.Timestamp(2007, 6, 21, 0, 0, 0),
+                cx_Oracle.Timestamp(2007, 12, 13, 7, 30, 45)), None)
+
+    def testObjectType(self):
+        "test object type data"
+        self.cursor.execute("""
+                select ObjectCol
+                from TestObjects
+                where ObjectCol is not null
+                  and rownum <= 1""")
+        objValue, = self.cursor.fetchone()
+        self.failUnlessEqual(objValue.type.schema,
+                self.connection.username.upper())
+        self.failUnlessEqual(objValue.type.name, "UDT_OBJECT")
+        self.failUnlessEqual(objValue.type.attributes[0].name, "NUMBERVALUE")
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/test/SessionPool.py b/desktop/core/ext-py/cx_Oracle-5.1.2/test/SessionPool.py
new file mode 100644
index 0000000..0f870fb
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/test/SessionPool.py
@@ -0,0 +1,117 @@
+"""Module for testing session pools."""
+
+import threading
+
+class TestConnection(TestCase):
+
+    def __ConnectAndDrop(self):
+        """Connect to the database, perform a query and drop the connection."""
+        connection = self.pool.acquire()
+        cursor = connection.cursor()
+        cursor.execute("select count(*) from TestNumbers")
+        count, = cursor.fetchone()
+        self.failUnlessEqual(count, 10)
+
+    def __ConnectAndGenerateError(self):
+        """Connect to the database, perform a query which raises an error"""
+        connection = self.pool.acquire()
+        cursor = connection.cursor()
+        self.failUnlessRaises(cx_Oracle.DatabaseError, cursor.execute,
+                "select 1 / 0 from dual")
+
+    def testPool(self):
+        """test that the pool is created and has the right attributes"""
+        pool = cx_Oracle.SessionPool(USERNAME, PASSWORD, TNSENTRY, 2, 8, 3)
+        self.failUnlessEqual(pool.username, USERNAME, "user name differs")
+        self.failUnlessEqual(pool.password, PASSWORD, "password differs")
+        self.failUnlessEqual(pool.tnsentry, TNSENTRY, "tnsentry differs")
+        self.failUnlessEqual(pool.max, 8, "max differs")
+        self.failUnlessEqual(pool.min, 2, "min differs")
+        self.failUnlessEqual(pool.increment, 3, "increment differs")
+        self.failUnlessEqual(pool.opened, 2, "opened differs")
+        self.failUnlessEqual(pool.busy, 0, "busy not 0 at start")
+        connection_1 = pool.acquire()
+        self.failUnlessEqual(pool.busy, 1, "busy not 1 after acquire")
+        self.failUnlessEqual(pool.opened, 2, "opened not unchanged (1)")
+        connection_2 = pool.acquire()
+        self.failUnlessEqual(pool.busy, 2, "busy not 2 after acquire")
+        self.failUnlessEqual(pool.opened, 2, "opened not unchanged (2)")
+        connection_3 = pool.acquire()
+        self.failUnlessEqual(pool.busy, 3, "busy not 3 after acquire")
+        self.failUnlessEqual(pool.opened, 5, "opened not changed (3)")
+        pool.release(connection_3)
+        self.failUnlessEqual(pool.busy, 2, "busy not 2 after release")
+        del connection_2
+        self.failUnlessEqual(pool.busy, 1, "busy not 1 after del")
+
+    def testProxyAuth(self):
+        """test that proxy authentication is possible"""
+        pool = cx_Oracle.SessionPool(USERNAME, PASSWORD, TNSENTRY, 2, 8, 3)
+        self.failUnlessEqual(pool.homogeneous, 1,
+                "homogeneous should be 1 by default")
+        self.failUnlessRaises(cx_Oracle.ProgrammingError, pool.acquire,
+                user = "proxyuser")
+        pool = cx_Oracle.SessionPool(USERNAME, PASSWORD, TNSENTRY, 2, 8, 3,
+                homogeneous = False)
+        self.failUnlessEqual(pool.homogeneous, 0,
+                "homogeneous should be 0 after setting it in the constructor")
+        user = "%s_proxy" % USERNAME
+        connection = pool.acquire(user = user)
+        cursor = connection.cursor()
+        cursor.execute('select user from dual')
+        result, = cursor.fetchone()
+        self.assertEqual(result, user.upper())
+
+    def testRollbackOnDel(self):
+        "connection rolls back before being destroyed"
+        pool = cx_Oracle.SessionPool(USERNAME, PASSWORD, TNSENTRY, 1, 8, 3)
+        connection = pool.acquire()
+        cursor = connection.cursor()
+        cursor.execute("truncate table TestExecuteMany")
+        cursor.execute("insert into TestExecuteMany (IntCol) values (1)")
+        pool = cx_Oracle.SessionPool(USERNAME, PASSWORD, TNSENTRY, 1, 8, 3)
+        connection = pool.acquire()
+        cursor = connection.cursor()
+        cursor.execute("select count(*) from TestExecuteMany")
+        count, = cursor.fetchone()
+        self.failUnlessEqual(count, 0)
+
+    def testRollbackOnRelease(self):
+        "connection rolls back before released back to the pool"
+        pool = cx_Oracle.SessionPool(USERNAME, PASSWORD, TNSENTRY, 1, 8, 3)
+        connection = pool.acquire()
+        cursor = connection.cursor()
+        cursor.execute("truncate table TestExecuteMany")
+        cursor.execute("insert into TestExecuteMany (IntCol) values (1)")
+        pool.release(connection)
+        pool = cx_Oracle.SessionPool(USERNAME, PASSWORD, TNSENTRY, 1, 8, 3)
+        connection = pool.acquire()
+        cursor = connection.cursor()
+        cursor.execute("select count(*) from TestExecuteMany")
+        count, = cursor.fetchone()
+        self.failUnlessEqual(count, 0)
+
+    def testThreading(self):
+        """test session pool to database with multiple threads"""
+        self.pool = cx_Oracle.SessionPool(USERNAME, PASSWORD, TNSENTRY, 5, 20,
+                2, threaded = True)
+        threads = []
+        for i in range(20):
+            thread = threading.Thread(None, self.__ConnectAndDrop)
+            threads.append(thread)
+            thread.start()
+        for thread in threads:
+            thread.join()
+
+    def testThreadingWithErrors(self):
+        """test session pool to database with multiple threads (with errors)"""
+        self.pool = cx_Oracle.SessionPool(USERNAME, PASSWORD, TNSENTRY, 5, 20,
+                2, threaded = True)
+        threads = []
+        for i in range(20):
+            thread = threading.Thread(None, self.__ConnectAndGenerateError)
+            threads.append(thread)
+            thread.start()
+        for thread in threads:
+            thread.join()
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/test/SetupTest.sql b/desktop/core/ext-py/cx_Oracle-5.1.2/test/SetupTest.sql
new file mode 100644
index 0000000..b7af68d
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/test/SetupTest.sql
@@ -0,0 +1,560 @@
+/*-----------------------------------------------------------------------------
+ * SetupTest.sql
+ *   Creates a user named "cx_Oracle" and populates its schema with the tables
+ * and packages necessary for performing the test suite.
+ *---------------------------------------------------------------------------*/
+
+whenever sqlerror exit failure
+
+-- drop existing users, if present
+begin
+  for r in
+      ( select username
+        from dba_users
+        where username in ('CX_ORACLE', 'CX_ORACLE_PROXY')
+      ) loop
+    execute immediate 'drop user ' || r.username || ' cascade';
+  end loop;
+end;
+/
+
+alter session set nls_date_format = 'YYYY-MM-DD HH24:MI:SS';
+alter session set nls_numeric_characters='.,';
+
+create user cx_Oracle identified by dev
+quota unlimited on users
+default tablespace users;
+
+create user cx_Oracle_proxy identified by dev;
+alter user cx_Oracle_proxy grant connect through cx_Oracle;
+
+grant create session to cx_Oracle_proxy;
+
+grant
+  create session,
+  create table,
+  create procedure,
+  create type
+to cx_Oracle;
+
+-- create types
+create type cx_Oracle.udt_Object as object (
+  NumberValue           number,
+  StringValue           varchar2(60),
+  FixedCharValue        char(10),
+  DateValue             date,
+  TimestampValue        timestamp
+);
+/
+
+create type cx_Oracle.udt_Array as varray(10) of number;
+/
+
+-- create tables
+create table cx_Oracle.TestNumbers (
+  IntCol                number(9) not null,
+  NumberCol             number(9, 2) not null,
+  FloatCol              float not null,
+  UnconstrainedCol      number not null,
+  NullableCol           number(38)
+) tablespace users;
+
+create table cx_Oracle.TestStrings (
+  IntCol                number(9) not null,
+  StringCol             varchar2(20) not null,
+  RawCol                raw(30) not null,
+  FixedCharCol          char(40) not null,
+  NullableCol           varchar2(50)
+) tablespace users;
+
+create table cx_Oracle.TestUnicodes (
+  IntCol                number(9) not null,
+  UnicodeCol            nvarchar2(20) not null,
+  FixedUnicodeCol       nchar(40) not null,
+  NullableCol           nvarchar2(50)
+) tablespace users;
+
+create table cx_Oracle.TestDates (
+  IntCol                number(9) not null,
+  DateCol               date not null,
+  NullableCol           date
+) tablespace users;
+
+create table cx_Oracle.TestCLOBs (
+  IntCol                number(9) not null,
+  CLOBCol               clob not null
+) tablespace users;
+
+create table cx_Oracle.TestNCLOBs (
+  IntCol                number(9) not null,
+  NCLOBCol              nclob not null
+) tablespace users;
+
+create table cx_Oracle.TestBLOBs (
+  IntCol                number(9) not null,
+  BLOBCol               blob not null
+) tablespace users;
+
+create table cx_Oracle.TestLongs (
+  IntCol                number(9) not null,
+  LongCol               long not null
+) tablespace users;
+
+create table cx_Oracle.TestLongRaws (
+  IntCol                number(9) not null,
+  LongRawCol            long raw not null
+) tablespace users;
+
+create table cx_Oracle.TestExecuteMany (
+  IntCol                number(9) not null,
+  StringCol             varchar2(100)
+) tablespace users;
+
+create table cx_Oracle.TestObjects (
+  IntCol                number(9) not null,
+  ObjectCol             cx_Oracle.udt_Object,
+  ArrayCol              cx_Oracle.udt_Array
+);
+
+create table cx_Oracle.TestTimestamps (
+  IntCol			    number(9) not null,
+  TimestampCol          timestamp not null,
+  NullableCol           timestamp
+) tablespace users;
+
+create table cx_Oracle.TestIntervals (
+  IntCol			    number(9) not null,
+  IntervalCol           interval day to second not null,
+  NullableCol           interval day to second
+) tablespace users;
+
+alter table cx_Oracle.testexecutemany
+add constraint testexecutemany_pk
+primary key (
+  intcol
+) using index tablespace users;
+
+-- populate tables
+begin
+  for i in 1..10 loop
+    insert into cx_Oracle.TestNumbers
+    values (i, i + i * 0.25, i + i * .75, i * i * i + i *.5,
+        decode(mod(i, 2), 0, null, power(143, i)));
+  end loop;
+end;
+/
+
+declare
+
+  t_RawValue			raw(30);
+
+  function ConvertHexDigit(a_Value number) return varchar2 is
+  begin
+    if a_Value between 0 and 9 then
+      return to_char(a_Value);
+    end if;
+    return chr(ascii('A') + a_Value - 10);
+  end;
+
+  function ConvertToHex(a_Value varchar2) return varchar2 is
+    t_HexValue			varchar2(60);
+    t_Digit			number;
+  begin
+    for i in 1..length(a_Value) loop
+      t_Digit := ascii(substr(a_Value, i, 1));
+      t_HexValue := t_HexValue ||
+          ConvertHexDigit(trunc(t_Digit / 16)) ||
+          ConvertHexDigit(mod(t_Digit, 16));
+    end loop;
+    return t_HexValue;
+  end;
+
+begin
+  for i in 1..10 loop
+    t_RawValue := hextoraw(ConvertToHex('Raw ' || to_char(i)));
+    insert into cx_Oracle.TestStrings
+    values (i, 'String ' || to_char(i), t_RawValue,
+        'Fixed Char ' || to_char(i),
+        decode(mod(i, 2), 0, null, 'Nullable ' || to_char(i)));
+  end loop;
+end;
+/
+
+begin
+  for i in 1..10 loop
+    insert into cx_Oracle.TestUnicodes
+    values (i, 'Unicode ' || unistr('\3042') || ' ' || to_char(i),
+        'Fixed Unicode ' || to_char(i),
+        decode(mod(i, 2), 0, null, unistr('Nullable ') || to_char(i)));
+  end loop;
+end;
+/
+
+begin
+  for i in 1..10 loop
+    insert into cx_Oracle.TestDates
+    values (i, to_date(20021209, 'YYYYMMDD') + i + i * .1,
+        decode(mod(i, 2), 0, null,
+        to_date(20021209, 'YYYYMMDD') + i + i + i * .15));
+  end loop;
+end;
+/
+
+begin
+  for i in 1..10 loop
+    insert into cx_Oracle.TestTimestamps
+    values (i, to_timestamp('20021209', 'YYYYMMDD') +
+            to_dsinterval(to_char(i) || ' 00:00:' || to_char(i * 2) || '.' ||
+                    to_char(i * 50)),
+        decode(mod(i, 2), 0, to_timestamp(null, 'YYYYMMDD'),
+        to_timestamp('20021209', 'YYYYMMDD') +
+            to_dsinterval(to_char(i + 1) || ' 00:00:' ||
+                    to_char(i * 3) || '.' || to_char(i * 125))));
+  end loop;
+end;
+/
+
+begin
+  for i in 1..10 loop
+    insert into cx_Oracle.TestIntervals
+    values (i, to_dsinterval(to_char(i) || ' ' || to_char(i) || ':' ||
+            to_char(i * 2) || ':' || to_char(i * 3)),
+            decode(mod(i, 2), 0, to_dsinterval(null),
+            to_dsinterval(to_char(i + 5) || ' ' || to_char(i + 2) || ':' ||
+            to_char(i * 2 + 5) || ':' || to_char(i * 3 + 5))));
+  end loop;
+end;
+/
+
+insert into cx_Oracle.TestObjects values (1,
+    cx_Oracle.udt_Object(1, 'First row', 'First',
+        to_date(20070306, 'YYYYMMDD'),
+        to_timestamp('20080912 16:40:00', 'YYYYMMDD HH24:MI:SS')),
+    cx_Oracle.udt_Array(5, 10, null, 20));
+
+insert into cx_Oracle.TestObjects values (2, null,
+    cx_Oracle.udt_Array(3, null, 9, 12, 15));
+
+insert into cx_Oracle.TestObjects values (3,
+    cx_Oracle.udt_Object(3, 'Third row', 'Third',
+        to_date(20070621, 'YYYYMMDD'),
+        to_timestamp('20071213 07:30:45', 'YYYYMMDD HH24:MI:SS')), null);
+
+commit;
+
+-- create procedures for testing callproc()
+create procedure cx_Oracle.proc_Test (
+  a_InValue             varchar2,
+  a_InOutValue          in out number,
+  a_OutValue            out number
+) as
+begin
+  a_InOutValue := a_InOutValue * length(a_InValue);
+  a_OutValue := length(a_InValue);
+end;
+/
+
+create procedure cx_Oracle.proc_TestNoArgs as
+begin
+  null;
+end;
+/
+
+-- create functions for testing callfunc()
+create function cx_Oracle.func_Test (
+  a_String              varchar2,
+  a_ExtraAmount         number
+) return number as
+begin
+  return length(a_String) + a_ExtraAmount;
+end;
+/
+
+create function cx_Oracle.func_TestNoArgs
+return number as
+begin
+  return 712;
+end;
+/
+
+-- create packages
+create or replace package cx_Oracle.pkg_TestStringArrays as
+
+  type udt_StringList is table of varchar2(100) index by binary_integer;
+
+  function TestInArrays (
+    a_StartingLength    number,
+    a_Array             udt_StringList
+  ) return number;
+
+  procedure TestInOutArrays (
+    a_NumElems          number,
+    a_Array             in out nocopy udt_StringList
+  );
+
+  procedure TestOutArrays (
+    a_NumElems          number,
+    a_Array             out nocopy udt_StringList
+  );
+
+end;
+/
+
+create or replace package body cx_Oracle.pkg_TestStringArrays as
+
+  function TestInArrays (
+    a_StartingLength    number,
+    a_Array             udt_StringList
+  ) return number is
+    t_Length            number;
+  begin
+    t_Length := a_StartingLength;
+    for i in 1..a_Array.count loop
+      t_Length := t_Length + length(a_Array(i));
+    end loop;
+    return t_Length;
+  end;
+
+  procedure TestInOutArrays (
+    a_NumElems          number,
+    a_Array             in out udt_StringList
+  ) is
+  begin
+    for i in 1..a_NumElems loop
+      a_Array(i) := 'Converted element # ' ||
+          to_char(i) || ' originally had length ' ||
+          to_char(length(a_Array(i)));
+    end loop;
+  end;
+
+  procedure TestOutArrays (
+    a_NumElems          number,
+    a_Array             out udt_StringList
+  ) is
+  begin
+    for i in 1..a_NumElems loop
+      a_Array(i) := 'Test out element # ' || to_char(i);
+    end loop;
+  end;
+
+end;
+/
+
+create or replace package cx_Oracle.pkg_TestUnicodeArrays as
+
+  type udt_UnicodeList is table of nvarchar2(100) index by binary_integer;
+
+  function TestInArrays (
+    a_StartingLength    number,
+    a_Array             udt_UnicodeList
+  ) return number;
+
+  procedure TestInOutArrays (
+    a_NumElems          number,
+    a_Array             in out nocopy udt_UnicodeList
+  );
+
+  procedure TestOutArrays (
+    a_NumElems          number,
+    a_Array             out nocopy udt_UnicodeList
+  );
+
+end;
+/
+
+create or replace package body cx_Oracle.pkg_TestUnicodeArrays as
+
+  function TestInArrays (
+    a_StartingLength    number,
+    a_Array             udt_UnicodeList
+  ) return number is
+    t_Length            number;
+  begin
+    t_Length := a_StartingLength;
+    for i in 1..a_Array.count loop
+      t_Length := t_Length + length(a_Array(i));
+    end loop;
+    return t_Length;
+  end;
+
+  procedure TestInOutArrays (
+    a_NumElems          number,
+    a_Array             in out udt_UnicodeList
+  ) is
+  begin
+    for i in 1..a_NumElems loop
+      a_Array(i) := unistr('Converted element ' || unistr('\3042') ||
+          ' # ') || to_char(i) || ' originally had length ' ||
+          to_char(length(a_Array(i)));
+    end loop;
+  end;
+
+  procedure TestOutArrays (
+    a_NumElems          number,
+    a_Array             out udt_UnicodeList
+  ) is
+  begin
+    for i in 1..a_NumElems loop
+      a_Array(i) := unistr('Test out element ') || unistr('\3042') || ' # ' ||
+          to_char(i);
+    end loop;
+  end;
+
+end;
+/
+
+create or replace package cx_Oracle.pkg_TestNumberArrays as
+
+  type udt_NumberList is table of number index by binary_integer;
+
+  function TestInArrays (
+    a_StartingValue     number,
+    a_Array             udt_NumberList
+  ) return number;
+
+  procedure TestInOutArrays (
+    a_NumElems          number,
+    a_Array             in out nocopy udt_NumberList
+  );
+
+  procedure TestOutArrays (
+    a_NumElems          number,
+    a_Array             out nocopy udt_NumberList
+  );
+
+end;
+/
+
+create or replace package body cx_Oracle.pkg_TestNumberArrays as
+
+  function TestInArrays (
+    a_StartingValue     number,
+    a_Array             udt_NumberList
+  ) return number is
+    t_Value             number;
+  begin
+    t_Value := a_StartingValue;
+    for i in 1..a_Array.count loop
+      t_Value := t_Value + a_Array(i);
+    end loop;
+    return t_Value;
+  end;
+
+  procedure TestInOutArrays (
+    a_NumElems          number,
+    a_Array             in out udt_NumberList
+  ) is
+  begin
+    for i in 1..a_NumElems loop
+      a_Array(i) := a_Array(i) * 10;
+    end loop;
+  end;
+
+  procedure TestOutArrays (
+    a_NumElems          number,
+    a_Array             out udt_NumberList
+  ) is
+  begin
+    for i in 1..a_NumElems loop
+      a_Array(i) := i * 100;
+    end loop;
+  end;
+
+end;
+/
+
+create or replace package cx_Oracle.pkg_TestDateArrays as
+
+  type udt_DateList is table of date index by binary_integer;
+
+  function TestInArrays (
+    a_StartingValue     number,
+    a_BaseDate          date,
+    a_Array             udt_DateList
+  ) return number;
+
+  procedure TestInOutArrays (
+    a_NumElems          number,
+    a_Array             in out nocopy udt_DateList
+  );
+
+  procedure TestOutArrays (
+    a_NumElems          number,
+    a_Array             out nocopy udt_DateList
+  );
+
+end;
+/
+
+create or replace package body cx_Oracle.pkg_TestDateArrays as
+
+  function TestInArrays (
+    a_StartingValue     number,
+    a_BaseDate          date,
+    a_Array             udt_DateList
+  ) return number is
+    t_Value             number;
+  begin
+    t_Value := a_StartingValue;
+    for i in 1..a_Array.count loop
+      t_Value := t_Value + a_Array(i) - a_BaseDate;
+    end loop;
+    return t_Value;
+  end;
+
+  procedure TestInOutArrays (
+    a_NumElems          number,
+    a_Array             in out udt_DateList
+  ) is
+  begin
+    for i in 1..a_NumElems loop
+      a_Array(i) := a_Array(i) + 7;
+    end loop;
+  end;
+
+  procedure TestOutArrays (
+    a_NumElems          number,
+    a_Array             out udt_DateList
+  ) is
+  begin
+    for i in 1..a_NumElems loop
+      a_Array(i) := to_date(20021212, 'YYYYMMDD') + i * 1.2;
+    end loop;
+  end;
+
+end;
+/
+
+create or replace package cx_Oracle.pkg_TestOutCursors as
+
+  type udt_RefCursor is ref cursor;
+
+  procedure TestOutCursor (
+    a_MaxIntValue       number,
+    a_Cursor            out udt_RefCursor
+  );
+
+end;
+/
+
+create or replace package body cx_Oracle.pkg_TestOutCursors as
+
+  procedure TestOutCursor (
+    a_MaxIntValue       number,
+    a_Cursor            out udt_RefCursor
+  ) is
+  begin
+    open a_Cursor for
+      select
+        IntCol,
+        StringCol
+      from TestStrings
+      where IntCol <= a_MaxIntValue
+      order by IntCol;
+  end;
+
+end;
+/
+
+exit
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/test/StringVar.py b/desktop/core/ext-py/cx_Oracle-5.1.2/test/StringVar.py
new file mode 100644
index 0000000..8c7f5d4
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/test/StringVar.py
@@ -0,0 +1,286 @@
+"""Module for testing string variables."""
+
+class TestStringVar(BaseTestCase):
+
+    def setUp(self):
+        BaseTestCase.setUp(self)
+        self.rawData = []
+        self.dataByKey = {}
+        for i in range(1, 11):
+            stringCol = "String %d" % i
+            fixedCharCol = ("Fixed Char %d" % i).ljust(40)
+            rawCol = "Raw %d" % i
+            if i % 2:
+                nullableCol = "Nullable %d" % i
+            else:
+                nullableCol = None
+            dataTuple = (i, stringCol, rawCol, fixedCharCol, nullableCol)
+            self.rawData.append(dataTuple)
+            self.dataByKey[i] = dataTuple
+
+    def testBindString(self):
+        "test binding in a string"
+        self.cursor.execute("""
+                select * from TestStrings
+                where StringCol = :p_Value""",
+                p_Value = "String 5")
+        self.failUnlessEqual(self.cursor.fetchall(), [self.dataByKey[5]])
+
+    def testBindDifferentVar(self):
+        "test binding a different variable on second execution"
+        retval_1 = self.cursor.var(cx_Oracle.STRING, 30)
+        retval_2 = self.cursor.var(cx_Oracle.STRING, 30)
+        self.cursor.execute("begin :retval := 'Called'; end;",
+                retval = retval_1)
+        self.failUnlessEqual(retval_1.getvalue(), "Called")
+        self.cursor.execute("begin :retval := 'Called'; end;",
+                retval = retval_2)
+        self.failUnlessEqual(retval_2.getvalue(), "Called")
+
+    def testBindStringAfterNumber(self):
+        "test binding in a string after setting input sizes to a number"
+        self.cursor.setinputsizes(p_Value = cx_Oracle.NUMBER)
+        self.cursor.execute("""
+                select * from TestStrings
+                where StringCol = :p_Value""",
+                p_Value = "String 6")
+        self.failUnlessEqual(self.cursor.fetchall(), [self.dataByKey[6]])
+
+    def testBindStringArrayDirect(self):
+        "test binding in a string array"
+        returnValue = self.cursor.var(cx_Oracle.NUMBER)
+        array = [r[1] for r in self.rawData]
+        statement = """
+                begin
+                  :p_ReturnValue := pkg_TestStringArrays.TestInArrays(
+                      :p_IntegerValue, :p_Array);
+                end;"""
+        self.cursor.execute(statement,
+                p_ReturnValue = returnValue,
+                p_IntegerValue = 5,
+                p_Array = array)
+        self.failUnlessEqual(returnValue.getvalue(), 86)
+        array = [ "String - %d" % i for i in range(15) ]
+        self.cursor.execute(statement,
+                p_IntegerValue = 8,
+                p_Array = array)
+        self.failUnlessEqual(returnValue.getvalue(), 163)
+
+    def testBindStringArrayBySizes(self):
+        "test binding in a string array (with setinputsizes)"
+        returnValue = self.cursor.var(cx_Oracle.NUMBER)
+        self.cursor.setinputsizes(p_Array = [cx_Oracle.STRING, 10])
+        array = [r[1] for r in self.rawData]
+        self.cursor.execute("""
+                begin
+                  :p_ReturnValue := pkg_TestStringArrays.TestInArrays(
+                      :p_IntegerValue, :p_Array);
+                end;""",
+                p_ReturnValue = returnValue,
+                p_IntegerValue = 6,
+                p_Array = array)
+        self.failUnlessEqual(returnValue.getvalue(), 87)
+
+    def testBindStringArrayByVar(self):
+        "test binding in a string array (with arrayvar)"
+        returnValue = self.cursor.var(cx_Oracle.NUMBER)
+        array = self.cursor.arrayvar(cx_Oracle.STRING, 10, 20)
+        array.setvalue(0, [r[1] for r in self.rawData])
+        self.cursor.execute("""
+                begin
+                  :p_ReturnValue := pkg_TestStringArrays.TestInArrays(
+                      :p_IntegerValue, :p_Array);
+                end;""",
+                p_ReturnValue = returnValue,
+                p_IntegerValue = 7,
+                p_Array = array)
+        self.failUnlessEqual(returnValue.getvalue(), 88)
+
+    def testBindInOutStringArrayByVar(self):
+        "test binding in/out a string array (with arrayvar)"
+        array = self.cursor.arrayvar(cx_Oracle.STRING, 10, 100)
+        originalData = [r[1] for r in self.rawData]
+        expectedData = ["Converted element # %d originally had length %d" % \
+                (i, len(originalData[i - 1])) for i in range(1, 6)] + \
+                originalData[5:]
+        array.setvalue(0, originalData)
+        self.cursor.execute("""
+                begin
+                  pkg_TestStringArrays.TestInOutArrays(:p_NumElems, :p_Array);
+                end;""",
+                p_NumElems = 5,
+                p_Array = array)
+        self.failUnlessEqual(array.getvalue(), expectedData)
+
+    def testBindOutStringArrayByVar(self):
+        "test binding out a string array (with arrayvar)"
+        array = self.cursor.arrayvar(cx_Oracle.STRING, 6, 100)
+        expectedData = ["Test out element # %d" % i for i in range(1, 7)]
+        self.cursor.execute("""
+                begin
+                  pkg_TestStringArrays.TestOutArrays(:p_NumElems, :p_Array);
+                end;""",
+                p_NumElems = 6,
+                p_Array = array)
+        self.failUnlessEqual(array.getvalue(), expectedData)
+
+    def testBindRaw(self):
+        "test binding in a raw"
+        self.cursor.setinputsizes(p_Value = cx_Oracle.BINARY)
+        self.cursor.execute("""
+                select * from TestStrings
+                where RawCol = :p_Value""",
+                p_Value = "Raw 4")
+        self.failUnlessEqual(self.cursor.fetchall(), [self.dataByKey[4]])
+
+    def testBindAndFetchRowid(self):
+        "test binding (and fetching) a rowid"
+        self.cursor.execute("""
+                select rowid
+                from TestStrings
+                where IntCol = 3""")
+        rowid, = self.cursor.fetchone()
+        self.cursor.execute("""
+                select *
+                from TestStrings
+                where rowid = :p_Value""",
+                p_Value = rowid)
+        self.failUnlessEqual(self.cursor.fetchall(), [self.dataByKey[3]])
+
+    def testBindNull(self):
+        "test binding in a null"
+        self.cursor.execute("""
+                select * from TestStrings
+                where StringCol = :p_Value""",
+                p_Value = None)
+        self.failUnlessEqual(self.cursor.fetchall(), [])
+
+    def testBindOutSetInputSizesByType(self):
+        "test binding out with set input sizes defined (by type)"
+        vars = self.cursor.setinputsizes(p_Value = cx_Oracle.STRING)
+        self.cursor.execute("""
+                begin
+                  :p_Value := 'TSI';
+                end;""")
+        self.failUnlessEqual(vars["p_Value"].getvalue(), "TSI")
+
+    def testBindOutSetInputSizesByInteger(self):
+        "test binding out with set input sizes defined (by integer)"
+        vars = self.cursor.setinputsizes(p_Value = 30)
+        self.cursor.execute("""
+                begin
+                  :p_Value := 'TSI (I)';
+                end;""")
+        self.failUnlessEqual(vars["p_Value"].getvalue(), "TSI (I)")
+
+    def testBindInOutSetInputSizesByType(self):
+        "test binding in/out with set input sizes defined (by type)"
+        vars = self.cursor.setinputsizes(p_Value = cx_Oracle.STRING)
+        self.cursor.execute("""
+                begin
+                  :p_Value := :p_Value || ' TSI';
+                end;""",
+                p_Value = "InVal")
+        self.failUnlessEqual(vars["p_Value"].getvalue(), "InVal TSI")
+
+    def testBindInOutSetInputSizesByInteger(self):
+        "test binding in/out with set input sizes defined (by integer)"
+        vars = self.cursor.setinputsizes(p_Value = 30)
+        self.cursor.execute("""
+                begin
+                  :p_Value := :p_Value || ' TSI (I)';
+                end;""",
+                p_Value = "InVal")
+        self.failUnlessEqual(vars["p_Value"].getvalue(), "InVal TSI (I)")
+
+    def testBindOutVar(self):
+        "test binding out with cursor.var() method"
+        var = self.cursor.var(cx_Oracle.STRING)
+        self.cursor.execute("""
+                begin
+                  :p_Value := 'TSI (VAR)';
+                end;""",
+                p_Value = var)
+        self.failUnlessEqual(var.getvalue(), "TSI (VAR)")
+
+    def testBindInOutVarDirectSet(self):
+        "test binding in/out with cursor.var() method"
+        var = self.cursor.var(cx_Oracle.STRING)
+        var.setvalue(0, "InVal")
+        self.cursor.execute("""
+                begin
+                  :p_Value := :p_Value || ' TSI (VAR)';
+                end;""",
+                p_Value = var)
+        self.failUnlessEqual(var.getvalue(), "InVal TSI (VAR)")
+
+    def testBindLongString(self):
+        "test that binding a long string succeeds"
+        self.cursor.execute("""
+                declare
+                  t_Temp varchar2(10000);
+                begin
+                  t_Temp := :bigString;
+                end;""",
+                bigString = "X" * 10000)
+
+    def testBindLongStringAfterSettingSize(self):
+        "test that setinputsizes() returns a long variable"
+        var = self.cursor.setinputsizes(test = 90000)["test"]
+        self.failUnlessEqual(type(var), cx_Oracle.LONG_STRING)
+        inString = "1234567890" * 9000
+        var.setvalue(0, inString)
+        outString = var.getvalue()
+        self.failUnlessEqual(inString, outString,
+                "output does not match: in was %d, out was %d" % \
+                (len(inString), len(outString)))
+
+    def testStringMaximumReached(self):
+        "test that an error is raised when maximum string length exceeded"
+        var = self.cursor.setinputsizes(test = 100)["test"]
+        inString = "1234567890" * 400
+        var.setvalue(0, inString)
+        outString = var.getvalue()
+        self.failUnlessEqual(inString, outString,
+                "output does not match: in was %d, out was %d" % \
+                (len(inString), len(outString)))
+        badStringSize = 4000 * self.connection.maxBytesPerCharacter + 1
+        inString = "X" * badStringSize
+        self.failUnlessRaises(ValueError, var.setvalue, 0, inString)
+
+    def testCursorDescription(self):
+        "test cursor description is accurate"
+        self.cursor.execute("select * from TestStrings")
+        self.failUnlessEqual(self.cursor.description,
+                [ ('INTCOL', cx_Oracle.NUMBER, 10, 22, 9, 0, 0),
+                  ('STRINGCOL', cx_Oracle.STRING, 20, 20, 0, 0, 0),
+                  ('RAWCOL', cx_Oracle.BINARY, 30, 30, 0, 0, 0),
+                  ('FIXEDCHARCOL', cx_Oracle.FIXED_CHAR, 40, 40, 0, 0, 0),
+                  ('NULLABLECOL', cx_Oracle.STRING, 50, 50, 0, 0, 1) ])
+
+    def testFetchAll(self):
+        "test that fetching all of the data returns the correct results"
+        self.cursor.execute("select * From TestStrings order by IntCol")
+        self.failUnlessEqual(self.cursor.fetchall(), self.rawData)
+        self.failUnlessEqual(self.cursor.fetchall(), [])
+
+    def testFetchMany(self):
+        "test that fetching data in chunks returns the correct results"
+        self.cursor.execute("select * From TestStrings order by IntCol")
+        self.failUnlessEqual(self.cursor.fetchmany(3), self.rawData[0:3])
+        self.failUnlessEqual(self.cursor.fetchmany(2), self.rawData[3:5])
+        self.failUnlessEqual(self.cursor.fetchmany(4), self.rawData[5:9])
+        self.failUnlessEqual(self.cursor.fetchmany(3), self.rawData[9:])
+        self.failUnlessEqual(self.cursor.fetchmany(3), [])
+
+    def testFetchOne(self):
+        "test that fetching a single row returns the correct results"
+        self.cursor.execute("""
+                select *
+                from TestStrings
+                where IntCol in (3, 4)
+                order by IntCol""")
+        self.failUnlessEqual(self.cursor.fetchone(), self.dataByKey[3])
+        self.failUnlessEqual(self.cursor.fetchone(), self.dataByKey[4])
+        self.failUnlessEqual(self.cursor.fetchone(), None)
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/test/TestEnv.py b/desktop/core/ext-py/cx_Oracle-5.1.2/test/TestEnv.py
new file mode 100644
index 0000000..d335344
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/test/TestEnv.py
@@ -0,0 +1,20 @@
+"""Define test environment."""
+
+import cx_Oracle
+import os
+import sys
+import unittest
+
+def GetValue(name, label):
+    value = os.environ.get("CX_ORACLE_" + name)
+    if value is None:
+        value = raw_input(label + ": ")
+    if hasattr(cx_Oracle, "UNICODE") or sys.version_info[0] >= 3:
+        return value
+    return unicode(value)
+
+USERNAME = GetValue("USERNAME", "user name")
+PASSWORD = GetValue("PASSWORD", "password")
+TNSENTRY = GetValue("TNSENTRY", "TNS entry")
+ARRAY_SIZE = int(GetValue("ARRAY_SIZE", "array size"))
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/test/TimestampVar.py b/desktop/core/ext-py/cx_Oracle-5.1.2/test/TimestampVar.py
new file mode 100644
index 0000000..406e574
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/test/TimestampVar.py
@@ -0,0 +1,130 @@
+"""Module for testing timestamp variables."""
+
+import time
+
+class TestTimestampVar(BaseTestCase):
+
+    def setUp(self):
+        BaseTestCase.setUp(self)
+        self.rawData = []
+        self.dataByKey = {}
+        for i in range(1, 11):
+            timeTuple = (2002, 12, 9, 0, 0, 0, 0, 0, -1)
+            timeInTicks = time.mktime(timeTuple) + i * 86400
+            dateValue = cx_Oracle.TimestampFromTicks(int(timeInTicks))
+            strValue = str(i * 50)
+            fsecond = int(strValue + "0" * (6 - len(strValue)))
+            dateCol = cx_Oracle.Timestamp(dateValue.year, dateValue.month,
+                    dateValue.day, dateValue.hour, dateValue.minute,
+                    i * 2, fsecond)
+            if i % 2:
+                timeInTicks = time.mktime(timeTuple) + i * 86400 + 86400
+                dateValue = cx_Oracle.TimestampFromTicks(int(timeInTicks))
+                strValue = str(i * 125)
+                fsecond = int(strValue + "0" * (6 - len(strValue)))
+                nullableCol = cx_Oracle.Timestamp(dateValue.year,
+                        dateValue.month, dateValue.day, dateValue.hour,
+                        dateValue.minute, i * 3, fsecond)
+            else:
+                nullableCol = None
+            tuple = (i, dateCol, nullableCol)
+            self.rawData.append(tuple)
+            self.dataByKey[i] = tuple
+
+    def testBindTimestamp(self):
+        "test binding in a timestamp"
+        self.cursor.setinputsizes(value = cx_Oracle.TIMESTAMP)
+        self.cursor.execute("""
+                select * from TestTimestamps
+                where TimestampCol = :value""",
+                value = cx_Oracle.Timestamp(2002, 12, 14, 0, 0, 10, 250000))
+        self.failUnlessEqual(self.cursor.fetchall(), [self.dataByKey[5]])
+
+    def testBindNull(self):
+        "test binding in a null"
+        self.cursor.setinputsizes(p_Value = cx_Oracle.TIMESTAMP)
+        self.cursor.execute("""
+                select * from TestTimestamps
+                where TimestampCol = :p_Value""",
+                p_Value = None)
+        self.failUnlessEqual(self.cursor.fetchall(), [])
+
+    def testBindOutSetInputSizes(self):
+        "test binding out with set input sizes defined"
+        vars = self.cursor.setinputsizes(p_Value = cx_Oracle.TIMESTAMP)
+        self.cursor.execute("""
+                begin
+                  :p_Value := to_timestamp('20021209', 'YYYYMMDD');
+                end;""")
+        self.failUnlessEqual(vars["p_Value"].getvalue(),
+               cx_Oracle.Timestamp(2002, 12, 9))
+
+    def testBindInOutSetInputSizes(self):
+        "test binding in/out with set input sizes defined"
+        vars = self.cursor.setinputsizes(p_Value = cx_Oracle.TIMESTAMP)
+        self.cursor.execute("""
+                begin
+                  :p_Value := :p_Value + 5.25;
+                end;""",
+                p_Value = cx_Oracle.Timestamp(2002, 12, 12, 10, 0, 0))
+        self.failUnlessEqual(vars["p_Value"].getvalue(),
+                cx_Oracle.Timestamp(2002, 12, 17, 16, 0, 0))
+
+    def testBindOutVar(self):
+        "test binding out with cursor.var() method"
+        var = self.cursor.var(cx_Oracle.TIMESTAMP)
+        self.cursor.execute("""
+                begin
+                  :p_Value := to_date('20021231 12:31:00',
+                      'YYYYMMDD HH24:MI:SS');
+                end;""",
+                p_Value = var)
+        self.failUnlessEqual(var.getvalue(),
+               cx_Oracle.Timestamp(2002, 12, 31, 12, 31, 0))
+
+    def testBindInOutVarDirectSet(self):
+        "test binding in/out with cursor.var() method"
+        var = self.cursor.var(cx_Oracle.TIMESTAMP)
+        var.setvalue(0, cx_Oracle.Timestamp(2002, 12, 9, 6, 0, 0))
+        self.cursor.execute("""
+                begin
+                  :p_Value := :p_Value + 5.25;
+                end;""",
+                p_Value = var)
+        self.failUnlessEqual(var.getvalue(),
+                cx_Oracle.Timestamp(2002, 12, 14, 12, 0, 0))
+
+    def testCursorDescription(self):
+        "test cursor description is accurate"
+        self.cursor.execute("select * from TestTimestamps")
+        self.failUnlessEqual(self.cursor.description,
+                [ ('INTCOL', cx_Oracle.NUMBER, 10, 22, 9, 0, 0),
+                  ('TIMESTAMPCOL', cx_Oracle.TIMESTAMP, -1, 11, 0, 0, 0),
+                  ('NULLABLECOL', cx_Oracle.TIMESTAMP, -1, 11, 0, 0, 1) ])
+
+    def testFetchAll(self):
+        "test that fetching all of the data returns the correct results"
+        self.cursor.execute("select * From TestTimestamps order by IntCol")
+        self.failUnlessEqual(self.cursor.fetchall(), self.rawData)
+        self.failUnlessEqual(self.cursor.fetchall(), [])
+
+    def testFetchMany(self):
+        "test that fetching data in chunks returns the correct results"
+        self.cursor.execute("select * From TestTimestamps order by IntCol")
+        self.failUnlessEqual(self.cursor.fetchmany(3), self.rawData[0:3])
+        self.failUnlessEqual(self.cursor.fetchmany(2), self.rawData[3:5])
+        self.failUnlessEqual(self.cursor.fetchmany(4), self.rawData[5:9])
+        self.failUnlessEqual(self.cursor.fetchmany(3), self.rawData[9:])
+        self.failUnlessEqual(self.cursor.fetchmany(3), [])
+
+    def testFetchOne(self):
+        "test that fetching a single row returns the correct results"
+        self.cursor.execute("""
+                select *
+                from TestTimestamps
+                where IntCol in (3, 4)
+                order by IntCol""")
+        self.failUnlessEqual(self.cursor.fetchone(), self.dataByKey[3])
+        self.failUnlessEqual(self.cursor.fetchone(), self.dataByKey[4])
+        self.failUnlessEqual(self.cursor.fetchone(), None)
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/test/UnicodeVar.py b/desktop/core/ext-py/cx_Oracle-5.1.2/test/UnicodeVar.py
new file mode 100644
index 0000000..c911881
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/test/UnicodeVar.py
@@ -0,0 +1,237 @@
+"""Module for testing unicode variables."""
+
+class TestUnicodeVar(BaseTestCase):
+
+    def setUp(self):
+        BaseTestCase.setUp(self)
+        self.rawData = []
+        self.dataByKey = {}
+        for i in range(1, 11):
+            unicodeCol = u"Unicode \u3042 %d" % i
+            fixedCharCol = (u"Fixed Unicode %d" % i).ljust(40)
+            if i % 2:
+                nullableCol = u"Nullable %d" % i
+            else:
+                nullableCol = None
+            dataTuple = (i, unicodeCol, fixedCharCol, nullableCol)
+            self.rawData.append(dataTuple)
+            self.dataByKey[i] = dataTuple
+
+    def testUnicodeLength(self):
+        "test value length"
+        returnValue = self.cursor.var(int)
+        self.cursor.execute("""
+                begin
+                  :retval := LENGTH(:value);
+                end;""",
+                value = u"InVal \u3042",
+                retval = returnValue)
+        self.failUnlessEqual(returnValue.getvalue(), 7)
+
+    def testBindUnicode(self):
+        "test binding in a unicode"
+        self.cursor.execute("""
+                select * from TestUnicodes
+                where UnicodeCol = :value""",
+                value = u"Unicode \u3042 5")
+        self.failUnlessEqual(self.cursor.fetchall(), [self.dataByKey[5]])
+
+    def testBindDifferentVar(self):
+        "test binding a different variable on second execution"
+        retval_1 = self.cursor.var(cx_Oracle.UNICODE, 30)
+        retval_2 = self.cursor.var(cx_Oracle.UNICODE, 30)
+        self.cursor.execute(r"begin :retval := unistr('Called \3042'); end;",
+                retval = retval_1)
+        self.failUnlessEqual(retval_1.getvalue(), u"Called \u3042")
+        self.cursor.execute("begin :retval := 'Called'; end;",
+                retval = retval_2)
+        self.failUnlessEqual(retval_2.getvalue(), "Called")
+
+    def testBindUnicodeAfterNumber(self):
+        "test binding in a unicode after setting input sizes to a number"
+        self.cursor.setinputsizes(value = cx_Oracle.NUMBER)
+        self.cursor.execute("""
+                select * from TestUnicodes
+                where UnicodeCol = :value""",
+                value = u"Unicode \u3042 6")
+        self.failUnlessEqual(self.cursor.fetchall(), [self.dataByKey[6]])
+
+    def testBindUnicodeArrayDirect(self):
+        "test binding in a unicode array"
+        returnValue = self.cursor.var(cx_Oracle.NUMBER)
+        array = [r[1] for r in self.rawData]
+        statement = """
+                begin
+                  :retval := pkg_TestUnicodeArrays.TestInArrays(
+                      :integerValue, :array);
+                end;"""
+        self.cursor.execute(statement,
+                retval = returnValue,
+                integerValue = 5,
+                array = array)
+        self.failUnlessEqual(returnValue.getvalue(), 116)
+        array = [ u"Unicode - \u3042 %d" % i for i in range(15) ]
+        self.cursor.execute(statement,
+                integerValue = 8,
+                array = array)
+        self.failUnlessEqual(returnValue.getvalue(), 208)
+
+    def testBindUnicodeArrayBySizes(self):
+        "test binding in a unicode array (with setinputsizes)"
+        returnValue = self.cursor.var(cx_Oracle.NUMBER)
+        self.cursor.setinputsizes(array = [cx_Oracle.UNICODE, 10])
+        array = [r[1] for r in self.rawData]
+        self.cursor.execute("""
+                begin
+                  :retval := pkg_TestUnicodeArrays.TestInArrays(:integerValue,
+                      :array);
+                end;""",
+                retval = returnValue,
+                integerValue = 6,
+                array = array)
+        self.failUnlessEqual(returnValue.getvalue(), 117)
+
+    def testBindUnicodeArrayByVar(self):
+        "test binding in a unicode array (with arrayvar)"
+        returnValue = self.cursor.var(cx_Oracle.NUMBER)
+        array = self.cursor.arrayvar(cx_Oracle.UNICODE, 10, 20)
+        array.setvalue(0, [r[1] for r in self.rawData])
+        self.cursor.execute("""
+                begin
+                  :retval := pkg_TestUnicodeArrays.TestInArrays(:integerValue,
+                      :array);
+                end;""",
+                retval = returnValue,
+                integerValue = 7,
+                array = array)
+        self.failUnlessEqual(returnValue.getvalue(), 118)
+
+    def testBindInOutUnicodeArrayByVar(self):
+        "test binding in/out a unicode array (with arrayvar)"
+        array = self.cursor.arrayvar(cx_Oracle.UNICODE, 10, 100)
+        originalData = [r[1] for r in self.rawData]
+        format = u"Converted element \u3042 # %d originally had length %d"
+        expectedData = [format % (i, len(originalData[i - 1])) \
+                for i in range(1, 6)] + originalData[5:]
+        array.setvalue(0, originalData)
+        self.cursor.execute("""
+                begin
+                  pkg_TestUnicodeArrays.TestInOutArrays(:numElems, :array);
+                end;""",
+                numElems = 5,
+                array = array)
+        self.failUnlessEqual(array.getvalue(), expectedData)
+
+    def testBindOutUnicodeArrayByVar(self):
+        "test binding out a unicode array (with arrayvar)"
+        array = self.cursor.arrayvar(cx_Oracle.UNICODE, 6, 100)
+        format = u"Test out element \u3042 # %d"
+        expectedData = [format % i for i in range(1, 7)]
+        self.cursor.execute("""
+                begin
+                  pkg_TestUnicodeArrays.TestOutArrays(:numElems, :array);
+                end;""",
+                numElems = 6,
+                array = array)
+        self.failUnlessEqual(array.getvalue(), expectedData)
+
+    def testBindNull(self):
+        "test binding in a null"
+        self.cursor.execute("""
+                select * from TestUnicodes
+                where UnicodeCol = :value""",
+                value = None)
+        self.failUnlessEqual(self.cursor.fetchall(), [])
+
+    def testBindOutSetInputSizesByType(self):
+        "test binding out with set input sizes defined (by type)"
+        vars = self.cursor.setinputsizes(value = cx_Oracle.UNICODE)
+        self.cursor.execute(r"""
+                begin
+                  :value := unistr('TSI \3042');
+                end;""")
+        self.failUnlessEqual(vars["value"].getvalue(), u"TSI \u3042")
+
+    def testBindInOutSetInputSizesByType(self):
+        "test binding in/out with set input sizes defined (by type)"
+        vars = self.cursor.setinputsizes(value = cx_Oracle.UNICODE)
+        self.cursor.execute(r"""
+                begin
+                  :value := :value || unistr(' TSI \3042');
+                end;""",
+                value = u"InVal \u3041")
+        self.failUnlessEqual(vars["value"].getvalue(),
+                u"InVal \u3041 TSI \u3042")
+
+    def testBindOutVar(self):
+        "test binding out with cursor.var() method"
+        var = self.cursor.var(cx_Oracle.UNICODE)
+        self.cursor.execute(r"""
+                begin
+                  :value := unistr('TSI (VAR) \3042');
+                end;""",
+                value = var)
+        self.failUnlessEqual(var.getvalue(), u"TSI (VAR) \u3042")
+
+    def testBindInOutVarDirectSet(self):
+        "test binding in/out with cursor.var() method"
+        var = self.cursor.var(cx_Oracle.UNICODE)
+        var.setvalue(0, u"InVal \u3041")
+        self.cursor.execute(r"""
+                begin
+                  :value := :value || unistr(' TSI (VAR) \3042');
+                end;""",
+                value = var)
+        self.failUnlessEqual(var.getvalue(), u"InVal \u3041 TSI (VAR) \u3042")
+
+    def testUnicodeMaximumReached(self):
+        "test that an error is raised when maximum unicode length exceeded"
+        var = self.cursor.setinputsizes(test = cx_Oracle.UNICODE)["test"]
+        inUnicode = u"1234567890" * 400
+        var.setvalue(0, inUnicode)
+        outUnicode = var.getvalue()
+        self.failUnlessEqual(inUnicode, outUnicode,
+                "output does not match: in was %d, out was %d" % \
+                (len(inUnicode), len(outUnicode)))
+        inUnicode = inUnicode + u"0"
+        self.failUnlessRaises(ValueError, var.setvalue, 0, inUnicode)
+
+    def testCursorDescription(self):
+        "test cursor description is accurate"
+        self.cursor.execute("select * from TestUnicodes")
+        self.failUnlessEqual(self.cursor.description,
+                [ ('INTCOL', cx_Oracle.NUMBER, 10, 22, 9, 0, 0),
+                  ('UNICODECOL', cx_Oracle.UNICODE, 20,
+                      self.connection.maxBytesPerCharacter * 20, 0, 0, 0),
+                  ('FIXEDUNICODECOL',
+                      cx_Oracle.FIXED_UNICODE, 40,
+                      self.connection.maxBytesPerCharacter * 40, 0, 0, 0),
+                  ('NULLABLECOL', cx_Oracle.UNICODE, 50,
+                      self.connection.maxBytesPerCharacter * 50, 0, 0, 1) ])
+
+    def testFetchAll(self):
+        "test that fetching all of the data returns the correct results"
+        self.cursor.execute("select * From TestUnicodes order by IntCol")
+        self.failUnlessEqual(self.cursor.fetchall(), self.rawData)
+        self.failUnlessEqual(self.cursor.fetchall(), [])
+
+    def testFetchMany(self):
+        "test that fetching data in chunks returns the correct results"
+        self.cursor.execute("select * From TestUnicodes order by IntCol")
+        self.failUnlessEqual(self.cursor.fetchmany(3), self.rawData[0:3])
+        self.failUnlessEqual(self.cursor.fetchmany(2), self.rawData[3:5])
+        self.failUnlessEqual(self.cursor.fetchmany(4), self.rawData[5:9])
+        self.failUnlessEqual(self.cursor.fetchmany(3), self.rawData[9:])
+        self.failUnlessEqual(self.cursor.fetchmany(3), [])
+
+    def testFetchOne(self):
+        "test that fetching a single row returns the correct results"
+        self.cursor.execute("""
+                select *
+                from TestUnicodes
+                where IntCol in (3, 4)
+                order by IntCol""")
+        self.failUnlessEqual(self.cursor.fetchone(), self.dataByKey[3])
+        self.failUnlessEqual(self.cursor.fetchone(), self.dataByKey[4])
+        self.failUnlessEqual(self.cursor.fetchone(), None)
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/test/test.py b/desktop/core/ext-py/cx_Oracle-5.1.2/test/test.py
new file mode 100644
index 0000000..6c16557
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/test/test.py
@@ -0,0 +1,87 @@
+"""Runs all defined unit tests."""
+
+import cx_Oracle
+import imp
+import os
+import sys
+import unittest
+
+print "Running tests for cx_Oracle version", cx_Oracle.version
+
+import TestEnv
+
+inSetup = (os.path.basename(sys.argv[0]).lower() == "setup.py")
+
+if len(sys.argv) > 1 and not inSetup:
+    moduleNames = [os.path.splitext(v)[0] for v in sys.argv[1:]]
+else:
+    moduleNames = [
+            "Connection",
+            "uConnection",
+            "Cursor",
+            "uCursor",
+            "CursorVar",
+            "uCursorVar",
+            "DateTimeVar",
+            "uDateTimeVar",
+            "IntervalVar",
+            "uIntervalVar",
+            "LobVar",
+            "uLobVar",
+            "LongVar",
+            "uLongVar",
+            "NumberVar",
+            "uNumberVar",
+            "ObjectVar",
+            "uObjectVar",
+            "SessionPool",
+            "uSessionPool",
+            "StringVar",
+            "uStringVar",
+            "TimestampVar",
+            "uTimestampVar",
+            "UnicodeVar"
+    ]
+
+class BaseTestCase(unittest.TestCase):
+
+    def setUp(self):
+        global cx_Oracle, TestEnv
+        self.connection = cx_Oracle.connect(TestEnv.USERNAME,
+                TestEnv.PASSWORD, TestEnv.TNSENTRY)
+        self.cursor = self.connection.cursor()
+        self.cursor.arraysize = TestEnv.ARRAY_SIZE
+
+    def tearDown(self):
+        del self.cursor
+        del self.connection
+
+
+loader = unittest.TestLoader()
+runner = unittest.TextTestRunner(verbosity = 2)
+failures = []
+for name in moduleNames:
+    fileName = name + ".py"
+    print
+    print "Running tests in", fileName
+    if inSetup:
+        fileName = os.path.join("test", fileName)
+    module = imp.new_module(name)
+    setattr(module, "USERNAME", TestEnv.USERNAME)
+    setattr(module, "PASSWORD", TestEnv.PASSWORD)
+    setattr(module, "TNSENTRY", TestEnv.TNSENTRY)
+    setattr(module, "ARRAY_SIZE", TestEnv.ARRAY_SIZE)
+    setattr(module, "TestCase", unittest.TestCase)
+    setattr(module, "BaseTestCase", BaseTestCase)
+    setattr(module, "cx_Oracle", cx_Oracle)
+    execfile(fileName, module.__dict__)
+    tests = loader.loadTestsFromModule(module)
+    result = runner.run(tests)
+    if not result.wasSuccessful():
+        failures.append(name)
+if failures:
+    print "***** Some tests in the following modules failed. *****"
+    for name in failures:
+        print "      %s" % name
+    sys.exit(1)
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/test/test3k.py b/desktop/core/ext-py/cx_Oracle-5.1.2/test/test3k.py
new file mode 100644
index 0000000..d104ca9
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/test/test3k.py
@@ -0,0 +1,75 @@
+"""Runs all defined unit tests."""
+
+import cx_Oracle
+import imp
+import os
+import sys
+import unittest
+
+inSetup = (os.path.basename(sys.argv[0]).lower() == "setup.py")
+
+print("Running tests for cx_Oracle version", cx_Oracle.version)
+
+import TestEnv
+
+if len(sys.argv) > 1 and not inSetup:
+    moduleNames = [os.path.splitext(v)[0] for v in sys.argv[1:]]
+else:
+    moduleNames = [
+            "Connection",
+            "Cursor",
+            "CursorVar",
+            "DateTimeVar",
+            "LobVar",
+            "LongVar",
+            "3kNumberVar",
+            "ObjectVar",
+            "SessionPool",
+            "3kStringVar",
+            "TimestampVar"
+    ]
+
+class BaseTestCase(unittest.TestCase):
+
+    def setUp(self):
+        import cx_Oracle
+        import TestEnv
+        self.connection = cx_Oracle.connect(TestEnv.USERNAME,
+                TestEnv.PASSWORD, TestEnv.TNSENTRY)
+        self.cursor = self.connection.cursor()
+        self.cursor.arraysize = TestEnv.ARRAY_SIZE
+
+    def tearDown(self):
+        del self.cursor
+        del self.connection
+
+
+loader = unittest.TestLoader()
+runner = unittest.TextTestRunner(verbosity = 2)
+failures = []
+for name in moduleNames:
+    fileName = name + ".py"
+    print()
+    print("Running tests in", fileName)
+    if inSetup:
+        fileName = os.path.join("test", fileName)
+    module = imp.new_module(name)
+    import cx_Oracle
+    setattr(module, "USERNAME", TestEnv.USERNAME)
+    setattr(module, "PASSWORD", TestEnv.PASSWORD)
+    setattr(module, "TNSENTRY", TestEnv.TNSENTRY)
+    setattr(module, "ARRAY_SIZE", TestEnv.ARRAY_SIZE)
+    setattr(module, "TestCase", unittest.TestCase)
+    setattr(module, "BaseTestCase", BaseTestCase)
+    setattr(module, "cx_Oracle", cx_Oracle)
+    exec(open(fileName).read(), module.__dict__)
+    tests = loader.loadTestsFromModule(module)
+    result = runner.run(tests)
+    if not result.wasSuccessful():
+        failures.append(name)
+if failures:
+    print("***** Some tests in the following modules failed. *****")
+    for name in failures:
+        print("      %s" % name)
+    sys.exit(1)
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/test/test_dbapi20.py b/desktop/core/ext-py/cx_Oracle-5.1.2/test/test_dbapi20.py
new file mode 100644
index 0000000..13fd91c
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/test/test_dbapi20.py
@@ -0,0 +1,39 @@
+"""Driver specific portion of the DB API test suite provided by Stuart Bishop
+   available at http://stuartbishop.net/Software/DBAPI20TestSuite/"""
+
+import cx_Oracle
+import dbapi20
+import unittest
+
+import TestEnv
+
+class TestSuite(dbapi20.DatabaseAPI20Test):
+
+    connect_args = (TestEnv.USERNAME, TestEnv.PASSWORD, TestEnv.TNSENTRY)
+    driver = cx_Oracle
+
+    # not implemented; use a string instead
+    def test_Binary(self):
+        pass
+
+    # not implemented; see cx_Oracle specific test suite instead
+    def test_callproc(self):
+        pass
+
+    # not implemented; Oracle does not support the concept
+    def test_nextset(self):
+        pass
+
+    # not implemented; see cx_Oracle specific test suite instead
+    def test_setinputsizes(self):
+        pass
+
+    # not implemented; see cx_Oracle specific test suite instead
+    def test_setoutputsize(self):
+        pass
+
+
+if __name__ == "__main__":
+    print "Testing cx_Oracle version", cx_Oracle.version
+    unittest.main()
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/test/uConnection.py b/desktop/core/ext-py/cx_Oracle-5.1.2/test/uConnection.py
new file mode 100644
index 0000000..65736e3
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/test/uConnection.py
@@ -0,0 +1,116 @@
+"""Module for testing connections."""
+
+import threading
+
+class TestConnection(TestCase):
+
+    def __ConnectAndDrop(self):
+        """Connect to the database, perform a query and drop the connection."""
+        connection = cx_Oracle.connect(self.username, self.password,
+                self.tnsentry, threaded = True)
+        cursor = connection.cursor()
+        cursor.execute(u"select count(*) from TestNumbers")
+        count, = cursor.fetchone()
+        self.failUnlessEqual(count, 10)
+
+    def setUp(self):
+        self.username = USERNAME
+        self.password = PASSWORD
+        self.tnsentry = TNSENTRY
+
+    def verifyArgs(self, connection):
+        self.failUnlessEqual(connection.username, self.username,
+                "user name differs")
+        self.failUnlessEqual(connection.password, self.password,
+                "password differs")
+        self.failUnlessEqual(connection.tnsentry, self.tnsentry,
+                "tnsentry differs")
+
+    def testAllArgs(self):
+        "connection to database with user, password, TNS separate"
+        connection = cx_Oracle.connect(self.username, self.password,
+                self.tnsentry)
+        self.verifyArgs(connection)
+
+    def testBadConnectString(self):
+        "connection to database with bad connect string"
+        self.failUnlessRaises(cx_Oracle.DatabaseError, cx_Oracle.connect,
+                self.username)
+        self.failUnlessRaises(cx_Oracle.DatabaseError, cx_Oracle.connect,
+                self.username + u"@" + self.tnsentry)
+        self.failUnlessRaises(cx_Oracle.DatabaseError, cx_Oracle.connect,
+                self.username + u"@" + self.tnsentry + u"/" + self.password)
+
+    def testBadPassword(self):
+        "connection to database with bad password"
+        self.failUnlessRaises(cx_Oracle.DatabaseError, cx_Oracle.connect,
+                self.username, self.password + u"X", self.tnsentry)
+
+    def testExceptionOnClose(self):
+        "confirm an exception is raised after closing a connection"
+        connection = cx_Oracle.connect(self.username, self.password,
+                self.tnsentry)
+        connection.close()
+        self.failUnlessRaises(cx_Oracle.InterfaceError, connection.rollback)
+
+    def testMakeDSN(self):
+        "test making a data source name from host, port and sid"
+        formatString = u"(DESCRIPTION=(ADDRESS_LIST=(ADDRESS=" \
+                u"(PROTOCOL=TCP)(HOST=%s)(PORT=%d)))(CONNECT_DATA=(SID=%s)))"
+        args = (u"hostname", 1521, u"TEST")
+        result = cx_Oracle.makedsn(*args)
+        self.failUnlessEqual(result, formatString % args)
+
+    def testSingleArg(self):
+        "connection to database with user, password, TNS together"
+        connection = cx_Oracle.connect(u"%s/%s@%s" % \
+                (self.username, self.password, self.tnsentry))
+        self.verifyArgs(connection)
+
+    def testVersion(self):
+        "connection version is a string"
+        connection = cx_Oracle.connect(self.username, self.password,
+                self.tnsentry)
+        self.failUnless(isinstance(connection.version, str))
+
+    def testRollbackOnClose(self):
+        "connection rolls back before close"
+        connection = cx_Oracle.connect(self.username, self.password,
+                self.tnsentry)
+        cursor = connection.cursor()
+        cursor.execute(u"truncate table TestExecuteMany")
+        otherConnection = cx_Oracle.connect(self.username, self.password,
+                self.tnsentry)
+        otherCursor = otherConnection.cursor()
+        otherCursor.execute(u"insert into TestExecuteMany (IntCol) values (1)")
+        otherConnection.close()
+        cursor.execute(u"select count(*) from TestExecuteMany")
+        count, = cursor.fetchone()
+        self.failUnlessEqual(count, 0)
+
+    def testRollbackOnDel(self):
+        "connection rolls back before destruction"
+        connection = cx_Oracle.connect(self.username, self.password,
+                self.tnsentry)
+        cursor = connection.cursor()
+        cursor.execute(u"truncate table TestExecuteMany")
+        otherConnection = cx_Oracle.connect(self.username, self.password,
+                self.tnsentry)
+        otherCursor = otherConnection.cursor()
+        otherCursor.execute(u"insert into TestExecuteMany (IntCol) values (1)")
+        del otherCursor
+        del otherConnection
+        cursor.execute(u"select count(*) from TestExecuteMany")
+        count, = cursor.fetchone()
+        self.failUnlessEqual(count, 0)
+
+    def testThreading(self):
+        "connection to database with multiple threads"
+        threads = []
+        for i in range(20):
+            thread = threading.Thread(None, self.__ConnectAndDrop)
+            threads.append(thread)
+            thread.start()
+        for thread in threads:
+            thread.join()
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/test/uCursor.py b/desktop/core/ext-py/cx_Oracle-5.1.2/test/uCursor.py
new file mode 100644
index 0000000..d7603bb
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/test/uCursor.py
@@ -0,0 +1,226 @@
+"""Module for testing cursor objects."""
+
+import cx_Oracle
+
+class TestCursor(BaseTestCase):
+
+    def testExecuteNoArgs(self):
+        """test executing a statement without any arguments"""
+        result = self.cursor.execute(u"begin null; end;")
+        self.failUnlessEqual(result, None)
+
+    def testExecuteNoStatementWithArgs(self):
+        """test executing a None statement with bind variables"""
+        self.failUnlessRaises(cx_Oracle.ProgrammingError, self.cursor.execute,
+                None, x = 5)
+
+    def testExecuteEmptyKeywordArgs(self):
+        """test executing a statement with args and empty keyword args"""
+        simpleVar = self.cursor.var(cx_Oracle.NUMBER)
+        args = [simpleVar]
+        kwArgs = {}
+        result = self.cursor.execute(u"begin :1 := 25; end;", args, **kwArgs)
+        self.failUnlessEqual(result, None)
+        self.failUnlessEqual(simpleVar.getvalue(), 25)
+
+    def testExecuteKeywordArgs(self):
+        """test executing a statement with keyword arguments"""
+        simpleVar = self.cursor.var(cx_Oracle.NUMBER)
+        result = self.cursor.execute(u"begin :p_Value := 5; end;",
+                p_Value = simpleVar)
+        self.failUnlessEqual(result, None)
+        self.failUnlessEqual(simpleVar.getvalue(), 5)
+
+    def testExecuteDictionaryArg(self):
+        """test executing a statement with a dictionary argument"""
+        simpleVar = self.cursor.var(cx_Oracle.NUMBER)
+        dictArg = { u"p_Value" : simpleVar }
+        result = self.cursor.execute(u"begin :p_Value := 10; end;", dictArg)
+        self.failUnlessEqual(result, None)
+        self.failUnlessEqual(simpleVar.getvalue(), 10)
+
+    def testExecuteMultipleMethod(self):
+        """test executing a statement with both a dict arg and keyword args"""
+        simpleVar = self.cursor.var(cx_Oracle.NUMBER)
+        dictArg = { u"p_Value" : simpleVar }
+        self.failUnlessRaises(cx_Oracle.InterfaceError, self.cursor.execute,
+                u"begin :p_Value := 15; end;", dictArg, p_Value = simpleVar)
+
+    def testExecuteAndModifyArraySize(self):
+        """test executing a statement and then changing the array size"""
+        self.cursor.execute(u"select IntCol from TestNumbers")
+        self.cursor.arraysize = 20
+        self.failUnlessEqual(len(self.cursor.fetchall()), 10)
+
+    def testCallProc(self):
+        """test executing a stored procedure"""
+        var = self.cursor.var(cx_Oracle.NUMBER)
+        results = self.cursor.callproc(u"proc_Test", (u"hi", 5, var))
+        self.failUnlessEqual(results, [u"hi", 10, 2.0])
+
+    def testCallProcNoArgs(self):
+        """test executing a stored procedure without any arguments"""
+        results = self.cursor.callproc(u"proc_TestNoArgs")
+        self.failUnlessEqual(results, [])
+
+    def testCallFunc(self):
+        """test executing a stored function"""
+        results = self.cursor.callfunc(u"func_Test", cx_Oracle.NUMBER,
+                (u"hi", 5))
+        self.failUnlessEqual(results, 7)
+
+    def testCallFuncNoArgs(self):
+        """test executing a stored function without any arguments"""
+        results = self.cursor.callfunc(u"func_TestNoArgs", cx_Oracle.NUMBER)
+        self.failUnlessEqual(results, 712)
+
+    def testExecuteManyByName(self):
+        """test executing a statement multiple times (named args)"""
+        self.cursor.execute(u"truncate table TestExecuteMany")
+        rows = [ { u"value" : n } for n in range(250) ]
+        self.cursor.arraysize = 100
+        statement = u"insert into TestExecuteMany (IntCol) values (:value)"
+        self.cursor.executemany(statement, rows)
+        self.connection.commit()
+        self.cursor.execute(u"select count(*) from TestExecuteMany")
+        count, = self.cursor.fetchone()
+        self.failUnlessEqual(count, len(rows))
+
+    def testExecuteManyByPosition(self):
+        """test executing a statement multiple times (positional args)"""
+        self.cursor.execute(u"truncate table TestExecuteMany")
+        rows = [ [n] for n in range(230) ]
+        self.cursor.arraysize = 100
+        statement = u"insert into TestExecuteMany (IntCol) values (:1)"
+        self.cursor.executemany(statement, rows)
+        self.connection.commit()
+        self.cursor.execute(u"select count(*) from TestExecuteMany")
+        count, = self.cursor.fetchone()
+        self.failUnlessEqual(count, len(rows))
+
+    def testExecuteManyWithPrepare(self):
+        """test executing a statement multiple times (with prepare)"""
+        self.cursor.execute(u"truncate table TestExecuteMany")
+        rows = [ [n] for n in range(225) ]
+        self.cursor.arraysize = 100
+        statement = u"insert into TestExecuteMany (IntCol) values (:1)"
+        self.cursor.prepare(statement)
+        self.cursor.executemany(None, rows)
+        self.connection.commit()
+        self.cursor.execute(u"select count(*) from TestExecuteMany")
+        count, = self.cursor.fetchone()
+        self.failUnlessEqual(count, len(rows))
+
+    def testExecuteManyWithRebind(self):
+        """test executing a statement multiple times (with rebind)"""
+        self.cursor.execute(u"truncate table TestExecuteMany")
+        rows = [ [n] for n in range(235) ]
+        self.cursor.arraysize = 100
+        statement = u"insert into TestExecuteMany (IntCol) values (:1)"
+        self.cursor.executemany(statement, rows[:50])
+        self.cursor.executemany(statement, rows[50:])
+        self.connection.commit()
+        self.cursor.execute(u"select count(*) from TestExecuteMany")
+        count, = self.cursor.fetchone()
+        self.failUnlessEqual(count, len(rows))
+
+    def testExecuteManyWithExecption(self):
+        """test executing a statement multiple times (with exception)"""
+        self.cursor.execute(u"truncate table TestExecuteMany")
+        rows = [ { u"p_Value" : n } for n in (1, 2, 3, 2, 5) ]
+        statement = u"insert into TestExecuteMany (IntCol) values (:p_Value)"
+        self.failUnlessRaises(cx_Oracle.DatabaseError, self.cursor.executemany,
+                statement, rows)
+        self.failUnlessEqual(self.cursor.rowcount, 3)
+
+    def testPrepare(self):
+        """test preparing a statement and executing it multiple times"""
+        self.failUnlessEqual(self.cursor.statement, None)
+        statement = u"begin :p_Value := :p_Value + 5; end;"
+        self.cursor.prepare(statement)
+        var = self.cursor.var(cx_Oracle.NUMBER)
+        self.failUnlessEqual(self.cursor.statement, statement)
+        var.setvalue(0, 2)
+        self.cursor.execute(None, p_Value = var)
+        self.failUnlessEqual(var.getvalue(), 7)
+        self.cursor.execute(None, p_Value = var)
+        self.failUnlessEqual(var.getvalue(), 12)
+        self.cursor.execute(u"begin :p_Value2 := 3; end;", p_Value2 = var)
+        self.failUnlessEqual(var.getvalue(), 3)
+
+    def testExceptionOnClose(self):
+        "confirm an exception is raised after closing a cursor"
+        self.cursor.close()
+        self.failUnlessRaises(cx_Oracle.InterfaceError, self.cursor.execute,
+                u"select 1 from dual")
+
+    def testIterators(self):
+        """test iterators"""
+        self.cursor.execute(u"""
+                select IntCol
+                from TestNumbers
+                where IntCol between 1 and 3
+                order by IntCol""")
+        rows = []
+        for row in self.cursor:
+            rows.append(row[0])
+        self.failUnlessEqual(rows, [1, 2, 3])
+
+    def testIteratorsInterrupted(self):
+        """test iterators (with intermediate execute)"""
+        self.cursor.execute(u"truncate table TestExecuteMany")
+        self.cursor.execute(u"""
+                select IntCol
+                from TestNumbers
+                where IntCol between 1 and 3
+                order by IntCol""")
+        testIter = iter(self.cursor)
+        value, = testIter.next()
+        self.cursor.execute(u"insert into TestExecuteMany (IntCol) values (1)")
+        self.failUnlessRaises(cx_Oracle.InterfaceError, testIter.next) 
+
+    def testBindNames(self):
+        """test that bindnames() works correctly."""
+        self.failUnlessRaises(cx_Oracle.ProgrammingError,
+                self.cursor.bindnames)
+        self.cursor.prepare(u"begin null; end;")
+        self.failUnlessEqual(self.cursor.bindnames(), [])
+        self.cursor.prepare(u"begin :retval := :inval + 5; end;")
+        self.failUnlessEqual(self.cursor.bindnames(), ["RETVAL", "INVAL"])
+        self.cursor.prepare(u"begin :retval := :a * :a + :b * :b; end;")
+        self.failUnlessEqual(self.cursor.bindnames(), ["RETVAL", "A", "B"])
+        self.cursor.prepare(u"begin :a := :b + :c + :d + :e + :f + :g + " + \
+                ":h + :i + :j + :k + :l; end;")
+        self.failUnlessEqual(self.cursor.bindnames(),
+                [u"A", u"B", u"C", u"D", u"E", u"F", u"G", u"H", u"I", u"J",
+                 u"K", u"L"])
+
+    def testBadPrepare(self):
+        """test that subsequent executes succeed after bad prepare"""
+        self.failUnlessRaises(cx_Oracle.DatabaseError,
+                self.cursor.execute,
+                u"begin raise_application_error(-20000, 'this); end;")
+        self.cursor.execute(u"begin null; end;")
+
+    def testBadExecute(self):
+        """test that subsequent fetches fail after bad execute"""
+        self.failUnlessRaises(cx_Oracle.DatabaseError,
+                self.cursor.execute, u"select y from dual")
+        self.failUnlessRaises(cx_Oracle.InterfaceError,
+                self.cursor.fetchall)
+
+    def testSetInputSizesMultipleMethod(self):
+        """test setting input sizes with both positional and keyword args"""
+        self.failUnlessRaises(cx_Oracle.InterfaceError,
+                self.cursor.setinputsizes, 5, x = 5)
+
+    def testSetInputSizesByPosition(self):
+        """test setting input sizes with positional args"""
+        var = self.cursor.var(cx_Oracle.STRING, 100)
+        self.cursor.setinputsizes(None, 5, None, 10, None, cx_Oracle.NUMBER)
+        self.cursor.execute(u"""
+                begin
+                  :1 := :2 || to_char(:3) || :4 || to_char(:5) || to_char(:6);
+                end;""", [var, u'test_', 5, u'_second_', 3, 7])
+        self.failUnlessEqual(var.getvalue(), u"test_5_second_37")
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/test/uCursorVar.py b/desktop/core/ext-py/cx_Oracle-5.1.2/test/uCursorVar.py
new file mode 100644
index 0000000..a8cf06f
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/test/uCursorVar.py
@@ -0,0 +1,48 @@
+"""Module for testing cursor variables."""
+
+import struct
+import sys
+
+class TestCursorVar(BaseTestCase):
+
+    def testBindCursor(self):
+        "test binding in a cursor"
+        cursor = self.connection.cursor()
+        self.failUnlessEqual(cursor.description, None)
+        self.cursor.execute(u"""
+                begin
+                  open :p_Cursor for select 'X' StringValue from dual;
+                end;""",
+                p_Cursor = cursor)
+        self.failUnlessEqual(cursor.description,
+                [ ('STRINGVALUE', cx_Oracle.FIXED_CHAR, 1, 1, 0, 0, 1) ])
+        self.failUnlessEqual(cursor.fetchall(), [('X',)])
+
+    def testBindCursorInPackage(self):
+        "test binding in a cursor from a package"
+        cursor = self.connection.cursor()
+        self.failUnlessEqual(cursor.description, None)
+        self.cursor.callproc(u"pkg_TestOutCursors.TestOutCursor", (2, cursor))
+        self.failUnlessEqual(cursor.description,
+                [ ('INTCOL', cx_Oracle.NUMBER, 10, 22, 9, 0, 0),
+                  ('STRINGCOL', cx_Oracle.STRING, 20, 20, 0, 0, 0) ])
+        self.failUnlessEqual(cursor.fetchall(),
+                [ (1, 'String 1'), (2, 'String 2') ])
+
+    def testFetchCursor(self):
+        "test fetching a cursor"
+        self.cursor.execute(u"""
+                select
+                  IntCol,
+                  cursor(select IntCol + 1 from dual) CursorValue
+                from TestNumbers
+                order by IntCol""")
+        size = struct.calcsize('P')
+        self.failUnlessEqual(self.cursor.description,
+                [ (u'INTCOL', cx_Oracle.NUMBER, 10, 22, 9, 0, 0),
+                  (u'CURSORVALUE', cx_Oracle.CURSOR, -1, size, 0, 0, 1) ])
+        for i in range(1, 11):
+            number, cursor = self.cursor.fetchone()
+            self.failUnlessEqual(number, i)
+            self.failUnlessEqual(cursor.fetchall(), [(i + 1,)])
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/test/uDateTimeVar.py b/desktop/core/ext-py/cx_Oracle-5.1.2/test/uDateTimeVar.py
new file mode 100644
index 0000000..59e1bc6
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/test/uDateTimeVar.py
@@ -0,0 +1,228 @@
+"""Module for testing date/time variables."""
+
+import datetime
+import time
+
+class TestDateTimeVar(BaseTestCase):
+
+    def setUp(self):
+        BaseTestCase.setUp(self)
+        self.rawData = []
+        self.dataByKey = {}
+        for i in range(1, 11):
+            timeTuple = (2002, 12, 9, 0, 0, 0, 0, 0, -1)
+            timeInTicks = time.mktime(timeTuple) + i * 86400 + i * 8640
+            dateCol = cx_Oracle.TimestampFromTicks(int(timeInTicks))
+            if i % 2:
+                timeInTicks = time.mktime(timeTuple) + i * 86400 * 2 + \
+                        i * 12960
+                nullableCol = cx_Oracle.TimestampFromTicks(int(timeInTicks))
+            else:
+                nullableCol = None
+            tuple = (i, dateCol, nullableCol)
+            self.rawData.append(tuple)
+            self.dataByKey[i] = tuple
+
+    def testBindDate(self):
+        "test binding in a date"
+        self.cursor.execute(u"""
+                select * from TestDates
+                where DateCol = :p_Value""",
+                p_Value = cx_Oracle.Timestamp(2002, 12, 13, 9, 36, 0))
+        self.failUnlessEqual(self.cursor.fetchall(), [self.dataByKey[4]])
+
+    def testBindDateTime(self):
+        "test binding in a Python 2.3 and higher date time"
+        self.cursor.execute(u"""
+                select * from TestDates
+                where DateCol = :value""",
+                value = datetime.datetime(2002, 12, 13, 9, 36, 0))
+        self.failUnlessEqual(self.cursor.fetchall(), [self.dataByKey[4]])
+
+    def testBindDateAfterString(self):
+        "test binding in a date after setting input sizes to a string"
+        self.cursor.setinputsizes(p_Value = 15)
+        self.cursor.execute(u"""
+                select * from TestDates
+                where DateCol = :p_Value""",
+                p_Value = cx_Oracle.Timestamp(2002, 12, 14, 12, 0, 0))
+        self.failUnlessEqual(self.cursor.fetchall(), [self.dataByKey[5]])
+
+    def testBindNull(self):
+        "test binding in a null"
+        self.cursor.setinputsizes(p_Value = cx_Oracle.DATETIME)
+        self.cursor.execute(u"""
+                select * from TestDates
+                where DateCol = :p_Value""",
+                p_Value = None)
+        self.failUnlessEqual(self.cursor.fetchall(), [])
+
+    def testBindDateArrayDirect(self):
+        "test binding in a date array"
+        returnValue = self.cursor.var(cx_Oracle.NUMBER)
+        array = [r[1] for r in self.rawData]
+        statement = u"""
+                begin
+                  :p_ReturnValue := pkg_TestDateArrays.TestInArrays(
+                      :p_StartValue, :p_BaseDate, :p_Array);
+                end;"""
+        self.cursor.execute(statement,
+                p_ReturnValue = returnValue,
+                p_StartValue = 5,
+                p_BaseDate = cx_Oracle.Date(2002, 12, 12),
+                p_Array = array)
+        self.failUnlessEqual(returnValue.getvalue(), 35.5)
+        array = array + array[:5]
+        self.cursor.execute(statement,
+                p_StartValue = 7,
+                p_BaseDate = cx_Oracle.Date(2002, 12, 13),
+                p_Array = array)
+        self.failUnlessEqual(returnValue.getvalue(), 24.0)
+
+    def testBindDateArrayBySizes(self):
+        "test binding in a date array (with setinputsizes)"
+        returnValue = self.cursor.var(cx_Oracle.NUMBER)
+        self.cursor.setinputsizes(p_Array = [cx_Oracle.DATETIME, 10])
+        array = [r[1] for r in self.rawData]
+        self.cursor.execute(u"""
+                begin
+                  :p_ReturnValue := pkg_TestDateArrays.TestInArrays(
+                      :p_StartValue, :p_BaseDate, :p_Array);
+                end;""",
+                p_ReturnValue = returnValue,
+                p_StartValue = 6,
+                p_BaseDate = cx_Oracle.Date(2002, 12, 13),
+                p_Array = array)
+        self.failUnlessEqual(returnValue.getvalue(), 26.5)
+
+    def testBindDateArrayByVar(self):
+        "test binding in a date array (with arrayvar)"
+        returnValue = self.cursor.var(cx_Oracle.NUMBER)
+        array = self.cursor.arrayvar(cx_Oracle.DATETIME, 10, 20)
+        array.setvalue(0, [r[1] for r in self.rawData])
+        self.cursor.execute(u"""
+                begin
+                  :p_ReturnValue := pkg_TestDateArrays.TestInArrays(
+                      :p_StartValue, :p_BaseDate, :p_Array);
+                end;""",
+                p_ReturnValue = returnValue,
+                p_StartValue = 7,
+                p_BaseDate = cx_Oracle.Date(2002, 12, 14),
+                p_Array = array)
+        self.failUnlessEqual(returnValue.getvalue(), 17.5)
+
+    def testBindInOutDateArrayByVar(self):
+        "test binding in/out a date array (with arrayvar)"
+        array = self.cursor.arrayvar(cx_Oracle.DATETIME, 10, 100)
+        originalData = [r[1] for r in self.rawData]
+        array.setvalue(0, originalData)
+        self.cursor.execute(u"""
+                begin
+                  pkg_TestDateArrays.TestInOutArrays(:p_NumElems, :p_Array);
+                end;""",
+                p_NumElems = 5,
+                p_Array = array)
+        self.failUnlessEqual(array.getvalue(),
+                [ cx_Oracle.Timestamp(2002, 12, 17, 2, 24, 0),
+                  cx_Oracle.Timestamp(2002, 12, 18, 4, 48, 0),
+                  cx_Oracle.Timestamp(2002, 12, 19, 7, 12, 0),
+                  cx_Oracle.Timestamp(2002, 12, 20, 9, 36, 0),
+                  cx_Oracle.Timestamp(2002, 12, 21, 12, 0, 0) ] + \
+                originalData[5:])
+
+    def testBindOutDateArrayByVar(self):
+        "test binding out a date array (with arrayvar)"
+        array = self.cursor.arrayvar(cx_Oracle.DATETIME, 6, 100)
+        self.cursor.execute(u"""
+                begin
+                  pkg_TestDateArrays.TestOutArrays(:p_NumElems, :p_Array);
+                end;""",
+                p_NumElems = 6,
+                p_Array = array)
+        self.failUnlessEqual(array.getvalue(),
+                [ cx_Oracle.Timestamp(2002, 12, 13, 4, 48, 0),
+                  cx_Oracle.Timestamp(2002, 12, 14, 9, 36, 0),
+                  cx_Oracle.Timestamp(2002, 12, 15, 14, 24, 0),
+                  cx_Oracle.Timestamp(2002, 12, 16, 19, 12, 0),
+                  cx_Oracle.Timestamp(2002, 12, 18, 0, 0, 0),
+                  cx_Oracle.Timestamp(2002, 12, 19, 4, 48, 0) ])
+
+    def testBindOutSetInputSizes(self):
+        "test binding out with set input sizes defined"
+        vars = self.cursor.setinputsizes(p_Value = cx_Oracle.DATETIME)
+        self.cursor.execute(u"""
+                begin
+                  :p_Value := to_date(20021209, 'YYYYMMDD');
+                end;""")
+        self.failUnlessEqual(vars["p_Value"].getvalue(),
+               cx_Oracle.Timestamp(2002, 12, 9))
+
+    def testBindInOutSetInputSizes(self):
+        "test binding in/out with set input sizes defined"
+        vars = self.cursor.setinputsizes(p_Value = cx_Oracle.DATETIME)
+        self.cursor.execute(u"""
+                begin
+                  :p_Value := :p_Value + 5.25;
+                end;""",
+                p_Value = cx_Oracle.Timestamp(2002, 12, 12, 10, 0, 0))
+        self.failUnlessEqual(vars["p_Value"].getvalue(),
+                cx_Oracle.Timestamp(2002, 12, 17, 16, 0, 0))
+
+    def testBindOutVar(self):
+        "test binding out with cursor.var() method"
+        var = self.cursor.var(cx_Oracle.DATETIME)
+        self.cursor.execute(u"""
+                begin
+                  :p_Value := to_date('20021231 12:31:00',
+                      'YYYYMMDD HH24:MI:SS');
+                end;""",
+                p_Value = var)
+        self.failUnlessEqual(var.getvalue(),
+               cx_Oracle.Timestamp(2002, 12, 31, 12, 31, 0))
+
+    def testBindInOutVarDirectSet(self):
+        "test binding in/out with cursor.var() method"
+        var = self.cursor.var(cx_Oracle.DATETIME)
+        var.setvalue(0, cx_Oracle.Timestamp(2002, 12, 9, 6, 0, 0))
+        self.cursor.execute(u"""
+                begin
+                  :p_Value := :p_Value + 5.25;
+                end;""",
+                p_Value = var)
+        self.failUnlessEqual(var.getvalue(),
+                cx_Oracle.Timestamp(2002, 12, 14, 12, 0, 0))
+
+    def testCursorDescription(self):
+        "test cursor description is accurate"
+        self.cursor.execute(u"select * from TestDates")
+        self.failUnlessEqual(self.cursor.description,
+                [ (u'INTCOL', cx_Oracle.NUMBER, 10, 22, 9, 0, 0),
+                  (u'DATECOL', cx_Oracle.DATETIME, 23, 7, 0, 0, 0),
+                  (u'NULLABLECOL', cx_Oracle.DATETIME, 23, 7, 0, 0, 1) ])
+
+    def testFetchAll(self):
+        "test that fetching all of the data returns the correct results"
+        self.cursor.execute(u"select * From TestDates order by IntCol")
+        self.failUnlessEqual(self.cursor.fetchall(), self.rawData)
+        self.failUnlessEqual(self.cursor.fetchall(), [])
+
+    def testFetchMany(self):
+        "test that fetching data in chunks returns the correct results"
+        self.cursor.execute(u"select * From TestDates order by IntCol")
+        self.failUnlessEqual(self.cursor.fetchmany(3), self.rawData[0:3])
+        self.failUnlessEqual(self.cursor.fetchmany(2), self.rawData[3:5])
+        self.failUnlessEqual(self.cursor.fetchmany(4), self.rawData[5:9])
+        self.failUnlessEqual(self.cursor.fetchmany(3), self.rawData[9:])
+        self.failUnlessEqual(self.cursor.fetchmany(3), [])
+
+    def testFetchOne(self):
+        "test that fetching a single row returns the correct results"
+        self.cursor.execute(u"""
+                select *
+                from TestDates
+                where IntCol in (3, 4)
+                order by IntCol""")
+        self.failUnlessEqual(self.cursor.fetchone(), self.dataByKey[3])
+        self.failUnlessEqual(self.cursor.fetchone(), self.dataByKey[4])
+        self.failUnlessEqual(self.cursor.fetchone(), None)
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/test/uIntervalVar.py b/desktop/core/ext-py/cx_Oracle-5.1.2/test/uIntervalVar.py
new file mode 100644
index 0000000..3690447
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/test/uIntervalVar.py
@@ -0,0 +1,121 @@
+"""Module for testing interval variables."""
+
+import datetime
+
+class TestIntervalVar(BaseTestCase):
+
+    def setUp(self):
+        BaseTestCase.setUp(self)
+        self.rawData = []
+        self.dataByKey = {}
+        for i in range(1, 11):
+            delta = datetime.timedelta(days = i, hours = i, minutes = i * 2,
+                    seconds = i * 3)
+            if i % 2 == 0:
+                nullableDelta = None
+            else:
+                nullableDelta = datetime.timedelta(days = i + 5, hours = i + 2,
+                        minutes = i * 2 + 5, seconds = i * 3 + 5)
+            tuple = (i, delta, nullableDelta)
+            self.rawData.append(tuple)
+            self.dataByKey[i] = tuple
+
+    def testBindInterval(self):
+        "test binding in an interval"
+        self.cursor.setinputsizes(value = cx_Oracle.INTERVAL)
+        self.cursor.execute(u"""
+                select * from TestIntervals
+                where IntervalCol = :value""",
+                value = datetime.timedelta(days = 5, hours = 5, minutes = 10,
+                        seconds = 15))
+        self.failUnlessEqual(self.cursor.fetchall(), [self.dataByKey[5]])
+
+    def testBindNull(self):
+        "test binding in a null"
+        self.cursor.setinputsizes(value = cx_Oracle.INTERVAL)
+        self.cursor.execute(u"""
+                select * from TestIntervals
+                where IntervalCol = :value""",
+                value = None)
+        self.failUnlessEqual(self.cursor.fetchall(), [])
+
+    def testBindOutSetInputSizes(self):
+        "test binding out with set input sizes defined"
+        vars = self.cursor.setinputsizes(value = cx_Oracle.INTERVAL)
+        self.cursor.execute(u"""
+                begin
+                  :value := to_dsinterval('8 09:24:18.123789');
+                end;""")
+        self.failUnlessEqual(vars["value"].getvalue(),
+                datetime.timedelta(days = 8, hours = 9, minutes = 24,
+                        seconds = 18, microseconds = 123789))
+
+    def testBindInOutSetInputSizes(self):
+        "test binding in/out with set input sizes defined"
+        vars = self.cursor.setinputsizes(value = cx_Oracle.INTERVAL)
+        self.cursor.execute(u"""
+                begin
+                  :value := :value + to_dsinterval('5 08:30:00');
+                end;""",
+                value = datetime.timedelta(days = 5, hours = 2, minutes = 15))
+        self.failUnlessEqual(vars["value"].getvalue(),
+                datetime.timedelta(days = 10, hours = 10, minutes = 45))
+
+    def testBindOutVar(self):
+        "test binding out with cursor.var() method"
+        var = self.cursor.var(cx_Oracle.INTERVAL)
+        self.cursor.execute(u"""
+                begin
+                  :value := to_dsinterval('15 18:35:45.586');
+                end;""",
+                value = var)
+        self.failUnlessEqual(var.getvalue(),
+                datetime.timedelta(days = 15, hours = 18, minutes = 35,
+                        seconds = 45, milliseconds = 586))
+
+    def testBindInOutVarDirectSet(self):
+        "test binding in/out with cursor.var() method"
+        var = self.cursor.var(cx_Oracle.INTERVAL)
+        var.setvalue(0, datetime.timedelta(days = 1, minutes = 50))
+        self.cursor.execute(u"""
+                begin
+                  :value := :value + to_dsinterval('8 05:15:00');
+                end;""",
+                value = var)
+        self.failUnlessEqual(var.getvalue(),
+                datetime.timedelta(days = 9, hours = 6, minutes = 5))
+
+    def testCursorDescription(self):
+        "test cursor description is accurate"
+        self.cursor.execute(u"select * from TestIntervals")
+        self.failUnlessEqual(self.cursor.description,
+                [ ('INTCOL', cx_Oracle.NUMBER, 10, 22, 9, 0, 0),
+                  ('INTERVALCOL', cx_Oracle.INTERVAL, -1, 11, 0, 0, 0),
+                  ('NULLABLECOL', cx_Oracle.INTERVAL, -1, 11, 0, 0, 1) ])
+
+    def testFetchAll(self):
+        "test that fetching all of the data returns the correct results"
+        self.cursor.execute(u"select * From TestIntervals order by IntCol")
+        self.failUnlessEqual(self.cursor.fetchall(), self.rawData)
+        self.failUnlessEqual(self.cursor.fetchall(), [])
+
+    def testFetchMany(self):
+        "test that fetching data in chunks returns the correct results"
+        self.cursor.execute(u"select * From TestIntervals order by IntCol")
+        self.failUnlessEqual(self.cursor.fetchmany(3), self.rawData[0:3])
+        self.failUnlessEqual(self.cursor.fetchmany(2), self.rawData[3:5])
+        self.failUnlessEqual(self.cursor.fetchmany(4), self.rawData[5:9])
+        self.failUnlessEqual(self.cursor.fetchmany(3), self.rawData[9:])
+        self.failUnlessEqual(self.cursor.fetchmany(3), [])
+
+    def testFetchOne(self):
+        "test that fetching a single row returns the correct results"
+        self.cursor.execute(u"""
+                select *
+                from TestIntervals
+                where IntCol in (3, 4)
+                order by IntCol""")
+        self.failUnlessEqual(self.cursor.fetchone(), self.dataByKey[3])
+        self.failUnlessEqual(self.cursor.fetchone(), self.dataByKey[4])
+        self.failUnlessEqual(self.cursor.fetchone(), None)
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/test/uLobVar.py b/desktop/core/ext-py/cx_Oracle-5.1.2/test/uLobVar.py
new file mode 100644
index 0000000..b3e3325
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/test/uLobVar.py
@@ -0,0 +1,152 @@
+"""Module for testing LOB (CLOB and BLOB) variables."""
+
+class TestLobVar(BaseTestCase):
+
+    def __PerformTest(self, type, inputType):
+        if type.endswith("CLOB"):
+            longString = u""
+        else:
+            longString = ""
+        directType = getattr(cx_Oracle, type)
+        self.cursor.execute(u"truncate table Test%ss" % type)
+        for i in range(0, 11):
+            if i > 0:
+                if type.endswith("CLOB"):
+                    char = unichr(ord('A') + i - 1)
+                else:
+                    char = chr(ord('A') + i - 1)
+                longString += char * 25000
+            elif inputType != directType:
+                continue
+            self.cursor.setinputsizes(longString = inputType)
+            self.cursor.execute(u"""
+                    insert into Test%ss (
+                      IntCol,
+                      %sCol
+                    ) values (
+                      :integerValue,
+                      :longString
+                    )""" % (type, type),
+                    integerValue = i,
+                    longString = longString)
+        self.connection.commit()
+        self.cursor.execute(u"""
+                select *
+                from Test%ss
+                order by IntCol""" % type)
+        longString = ""
+        for row in self.cursor:
+            integerValue, lob = row
+            if integerValue == 0:
+                self.failUnlessEqual(lob.size(), 0)
+                self.failUnlessEqual(lob.read(), "")
+            else:
+                if type.endswith("CLOB"):
+                    char = unichr(ord('A') + integerValue - 1)
+                    prevChar = unichr(ord('A') + integerValue - 2)
+                    actualValue = unicode(lob)
+                else:
+                    char = chr(ord('A') + integerValue - 1)
+                    prevChar = chr(ord('A') + integerValue - 2)
+                    actualValue = str(lob)
+                longString += char * 25000
+                self.failUnlessEqual(lob.size(), len(longString))
+                self.failUnlessEqual(lob.read(), longString)
+                self.failUnlessEqual(actualValue, longString)
+                self.failUnlessEqual(lob.read(len(longString)), char)
+            if integerValue > 1:
+                offset = (integerValue - 1) * 25000 - 4
+                string = prevChar * 5 + char * 5
+                self.failUnlessEqual(lob.read(offset, 10), string)
+
+    def __TestTrim(self, type):
+        self.cursor.execute(u"truncate table Test%ss" % type)
+        self.cursor.setinputsizes(longString = getattr(cx_Oracle, type))
+        longString = "X" * 75000
+        if type.endswith("CLOB"):
+            longString = unicode(longString)
+        self.cursor.execute(u"""
+                insert into Test%ss (
+                  IntCol,
+                  %sCol
+                ) values (
+                  :integerValue,
+                  :longString
+                )""" % (type, type),
+                integerValue = 1,
+                longString = longString)
+        self.cursor.execute(u"""
+                select %sCol
+                from Test%ss
+                where IntCol = 1""" % (type, type))
+        lob, = self.cursor.fetchone()
+        self.failUnlessEqual(lob.size(), 75000)
+        lob.trim(25000)
+        self.failUnlessEqual(lob.size(), 25000)
+        lob.trim()
+        self.failUnlessEqual(lob.size(), 0)
+
+    def testBLOBCursorDescription(self):
+        "test cursor description is accurate for BLOBs"
+        self.cursor.execute(u"select * from TestBLOBs")
+        self.failUnlessEqual(self.cursor.description,
+                [ (u'INTCOL', cx_Oracle.NUMBER, 10, 22, 9, 0, 0),
+                  (u'BLOBCOL', cx_Oracle.BLOB, -1, 4000, 0, 0, 0) ])
+
+    def testBLOBsDirect(self):
+        "test binding and fetching BLOB data (directly)"
+        self.__PerformTest("BLOB", cx_Oracle.BLOB)
+
+    def testBLOBsIndirect(self):
+        "test binding and fetching BLOB data (indirectly)"
+        self.__PerformTest("BLOB", cx_Oracle.LONG_BINARY)
+
+    def testBLOBTrim(self):
+        "test trimming a BLOB"
+        self.__TestTrim("BLOB")
+
+    def testCLOBCursorDescription(self):
+        "test cursor description is accurate for CLOBs"
+        self.cursor.execute(u"select * from TestCLOBs")
+        self.failUnlessEqual(self.cursor.description,
+                [ (u'INTCOL', cx_Oracle.NUMBER, 10, 22, 9, 0, 0),
+                  (u'CLOBCOL', cx_Oracle.CLOB, -1, 4000, 0, 0, 0) ])
+
+    def testCLOBsDirect(self):
+        "test binding and fetching CLOB data (directly)"
+        self.__PerformTest("CLOB", cx_Oracle.CLOB)
+
+    def testCLOBsIndirect(self):
+        "test binding and fetching CLOB data (indirectly)"
+        self.__PerformTest("CLOB", cx_Oracle.LONG_STRING)
+
+    def testCLOBTrim(self):
+        "test trimming a CLOB"
+        self.__TestTrim("CLOB")
+
+    def testMultipleFetch(self):
+        "test retrieving data from a CLOB after multiple fetches"
+        self.cursor.arraysize = 1
+        self.cursor.execute(u"select CLOBCol from TestCLOBS")
+        rows = self.cursor.fetchall()
+        self.failUnlessRaises(cx_Oracle.ProgrammingError, rows[1][0].read)
+
+    def testNCLOBCursorDescription(self):
+        "test cursor description is accurate for NCLOBs"
+        self.cursor.execute(u"select * from TestNCLOBs")
+        self.failUnlessEqual(self.cursor.description,
+                [ (u'INTCOL', cx_Oracle.NUMBER, 10, 22, 9, 0, 0),
+                  (u'NCLOBCOL', cx_Oracle.NCLOB, -1, 4000, 0, 0, 0) ])
+
+    def testNCLOBsDirect(self):
+        "test binding and fetching NCLOB data (directly)"
+        self.__PerformTest("NCLOB", cx_Oracle.NCLOB)
+
+    def testNCLOBsIndirect(self):
+        "test binding and fetching NCLOB data (indirectly)"
+        self.__PerformTest("NCLOB", cx_Oracle.LONG_STRING)
+
+    def testNCLOBTrim(self):
+        "test trimming a NCLOB"
+        self.__TestTrim("NCLOB")
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/test/uLongVar.py b/desktop/core/ext-py/cx_Oracle-5.1.2/test/uLongVar.py
new file mode 100644
index 0000000..299d846
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/test/uLongVar.py
@@ -0,0 +1,88 @@
+"""Module for testing long and long raw variables."""
+
+class TestLongVar(BaseTestCase):
+
+    def __PerformTest(self, a_Type, a_InputType):
+        self.cursor.execute(u"truncate table Test%ss" % a_Type)
+        if a_InputType == cx_Oracle.LONG_STRING:
+            longString = u""
+        else:
+            longString = ""
+        for i in range(1, 11):
+            if a_InputType == cx_Oracle.LONG_STRING:
+                char = unichr(ord('A') + i - 1)
+            else:
+                char = chr(ord('A') + i - 1)
+            longString += char * 25000
+            self.cursor.setinputsizes(p_LongString = a_InputType)
+            self.cursor.execute(u"""
+                    insert into Test%ss (
+                      IntCol,
+                      %sCol
+                    ) values (
+                      :p_IntegerValue,
+                      :p_LongString
+                    )""" % (a_Type, a_Type),
+                    p_IntegerValue = i,
+                    p_LongString = longString)
+        self.connection.commit()
+        self.cursor.setoutputsize(250000, 2)
+        self.cursor.execute(u"""
+                select *
+                from Test%ss
+                order by IntCol""" % a_Type)
+        longString = ""
+        while 1:
+            row = self.cursor.fetchone()
+            if row is None:
+                break
+            integerValue, fetchedValue = row
+            char = unichr(ord('A') + integerValue - 1)
+            longString += char * 25000
+            self.failUnlessEqual(len(fetchedValue), integerValue * 25000)
+            self.failUnlessEqual(fetchedValue, longString)
+
+    def testLongs(self):
+        "test binding and fetching long data"
+        self.__PerformTest("Long", cx_Oracle.LONG_STRING)
+
+    def testLongRaws(self):
+        "test binding and fetching long raw data"
+        self.__PerformTest("LongRaw", cx_Oracle.LONG_BINARY)
+
+    def testLongCursorDescription(self):
+        "test cursor description is accurate for longs"
+        self.cursor.execute(u"select * from TestLongs")
+        self.failUnlessEqual(self.cursor.description,
+                [ (u'INTCOL', cx_Oracle.NUMBER, 10, 22, 9, 0, 0),
+                  (u'LONGCOL', cx_Oracle.LONG_STRING, -1, 0, 0, 0, 0) ])
+
+    def testLongRawCursorDescription(self):
+        "test cursor description is accurate for long raws"
+        self.cursor.execute(u"select * from TestLongRaws")
+        self.failUnlessEqual(self.cursor.description,
+                [ (u'INTCOL', cx_Oracle.NUMBER, 10, 22, 9, 0, 0),
+                  (u'LONGRAWCOL', cx_Oracle.LONG_BINARY, -1, 0, 0, 0, 0) ])
+
+    def testSetOutputSizesAll(self):
+        "test setoutputsizes is valid (all)"
+        self.cursor.setoutputsize(25000)
+        self.cursor.execute(u"select * from TestLongRaws")
+        longVar = self.cursor.fetchvars[1]
+        self.failUnlessEqual(longVar.size, 25000)
+        self.failUnlessEqual(longVar.bufferSize, 25004)
+
+    def testSetOutputSizesWrongColumn(self):
+        "test setoutputsizes is valid (wrong column)"
+        self.cursor.setoutputsize(25000, 1)
+        self.cursor.execute(u"select * from TestLongRaws")
+        longVar = self.cursor.fetchvars[1]
+        self.failUnlessEqual(longVar.size, 131072)
+        self.failUnlessEqual(longVar.bufferSize, 131076)
+
+    def testArraySizeTooLarge(self):
+        "test array size too large generates an exception"
+        self.cursor.arraysize = 65536
+        self.failUnlessRaises(ValueError, self.cursor.execute,
+                u"select * from TestLongRaws")
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/test/uNumberVar.py b/desktop/core/ext-py/cx_Oracle-5.1.2/test/uNumberVar.py
new file mode 100644
index 0000000..76c8ffd
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/test/uNumberVar.py
@@ -0,0 +1,271 @@
+"""Module for testing number variables."""
+
+import cx_Oracle
+import decimal
+
+class TestNumberVar(BaseTestCase):
+
+    def setUp(self):
+      BaseTestCase.setUp(self)
+      self.rawData = []
+      self.dataByKey = {}
+      for i in range(1, 11):
+          numberCol = i + i * 0.25
+          floatCol = i + i * 0.75
+          unconstrainedCol = i ** 3 + i * 0.5
+          if i % 2:
+              nullableCol = 143L ** i
+          else:
+              nullableCol = None
+          dataTuple = (i, numberCol, floatCol, unconstrainedCol, nullableCol)
+          self.rawData.append(dataTuple)
+          self.dataByKey[i] = dataTuple
+
+    def testBindDecimal(self):
+        "test binding in a decimal.Decimal"
+        self.cursor.execute(u"""
+                select * from TestNumbers
+                where NumberCol - :value1 - :value2 = trunc(NumberCol)""",
+                value1 = decimal.Decimal("0.20"),
+                value2 = decimal.Decimal("0.05"))
+        self.failUnlessEqual(self.cursor.fetchall(),
+                [self.dataByKey[1], self.dataByKey[5], self.dataByKey[9]])
+
+    def testBindFloat(self):
+        "test binding in a float"
+        self.cursor.execute(u"""
+                select * from TestNumbers
+                where NumberCol - :value = trunc(NumberCol)""",
+                value = 0.25)
+        self.failUnlessEqual(self.cursor.fetchall(),
+                [self.dataByKey[1], self.dataByKey[5], self.dataByKey[9]])
+
+    def testBindInteger(self):
+        "test binding in an integer"
+        self.cursor.execute(u"""
+                select * from TestNumbers
+                where IntCol = :value""",
+                value = 2)
+        self.failUnlessEqual(self.cursor.fetchall(), [self.dataByKey[2]])
+
+    def testBindSmallLong(self):
+        "test binding in a small long integer"
+        self.cursor.execute(u"""
+                select * from TestNumbers
+                where IntCol = :value""",
+                value = 3L)
+        self.failUnlessEqual(self.cursor.fetchall(), [self.dataByKey[3]])
+
+    def testBindLargeLong(self):
+        "test binding in a large long integer"
+        valueVar = self.cursor.var(cx_Oracle.NUMBER)
+        valueVar.setvalue(0, 6088343244)
+        self.cursor.execute(u"""
+                begin
+                  :value := :value + 5;
+                end;""",
+                value = valueVar)
+        value = valueVar.getvalue()
+        self.failUnlessEqual(value, 6088343249)
+
+    def testBindIntegerAfterString(self):
+        "test binding in an number after setting input sizes to a string"
+        self.cursor.setinputsizes(value = 15)
+        self.cursor.execute(u"""
+                select * from TestNumbers
+                where IntCol = :value""",
+                value = 3)
+        self.failUnlessEqual(self.cursor.fetchall(), [self.dataByKey[3]])
+
+    def testBindNull(self):
+        "test binding in a null"
+        self.cursor.execute(u"""
+                select * from TestNumbers
+                where IntCol = :value""",
+                value = None)
+        self.failUnlessEqual(self.cursor.fetchall(), [])
+
+    def testBindNumberArrayDirect(self):
+        "test binding in a number array"
+        returnValue = self.cursor.var(cx_Oracle.NUMBER)
+        array = [r[1] for r in self.rawData]
+        statement = u"""
+                begin
+                  :p_ReturnValue := pkg_TestNumberArrays.TestInArrays(
+                      :p_StartValue, :p_Array);
+                end;"""
+        self.cursor.execute(statement,
+                p_ReturnValue = returnValue,
+                p_StartValue = 5,
+                p_Array = array)
+        self.failUnlessEqual(returnValue.getvalue(), 73.75)
+        array = range(15)
+        self.cursor.execute(statement,
+                p_StartValue = 10,
+                p_Array = array)
+        self.failUnlessEqual(returnValue.getvalue(), 115.0)
+
+    def testBindNumberArrayBySizes(self):
+        "test binding in a number array (with setinputsizes)"
+        returnValue = self.cursor.var(cx_Oracle.NUMBER)
+        self.cursor.setinputsizes(p_Array = [cx_Oracle.NUMBER, 10])
+        array = [r[1] for r in self.rawData]
+        self.cursor.execute(u"""
+                begin
+                  :p_ReturnValue := pkg_TestNumberArrays.TestInArrays(
+                      :p_StartValue, :p_Array);
+                end;""",
+                p_ReturnValue = returnValue,
+                p_StartValue = 6,
+                p_Array = array)
+        self.failUnlessEqual(returnValue.getvalue(), 74.75)
+
+    def testBindNumberArrayByVar(self):
+        "test binding in a number array (with arrayvar)"
+        returnValue = self.cursor.var(cx_Oracle.NUMBER)
+        array = self.cursor.arrayvar(cx_Oracle.NUMBER,
+                [r[1] for r in self.rawData])
+        array.setvalue(0, [r[1] for r in self.rawData])
+        self.cursor.execute(u"""
+                begin
+                  :p_ReturnValue := pkg_TestNumberArrays.TestInArrays(
+                      :p_IntegerValue, :p_Array);
+                end;""",
+                p_ReturnValue = returnValue,
+                p_IntegerValue = 7,
+                p_Array = array)
+        self.failUnlessEqual(returnValue.getvalue(), 75.75)
+
+    def testBindZeroLengthNumberArrayByVar(self):
+        "test binding in a zero length number array (with arrayvar)"
+        returnValue = self.cursor.var(cx_Oracle.NUMBER)
+        array = self.cursor.arrayvar(cx_Oracle.NUMBER, 0)
+        self.cursor.execute(u"""
+                begin
+                  :p_ReturnValue := pkg_TestNumberArrays.TestInArrays(
+                      :p_IntegerValue, :p_Array);
+                end;""",
+                p_ReturnValue = returnValue,
+                p_IntegerValue = 8,
+                p_Array = array)
+        self.failUnlessEqual(returnValue.getvalue(), 8.0)
+        self.failUnlessEqual(array.getvalue(), [])
+
+    def testBindInOutNumberArrayByVar(self):
+        "test binding in/out a number array (with arrayvar)"
+        array = self.cursor.arrayvar(cx_Oracle.NUMBER, 10)
+        originalData = [r[1] for r in self.rawData]
+        expectedData = [originalData[i - 1] * 10 for i in range(1, 6)] + \
+                originalData[5:]
+        array.setvalue(0, originalData)
+        self.cursor.execute(u"""
+                begin
+                  pkg_TestNumberArrays.TestInOutArrays(:p_NumElems, :p_Array);
+                end;""",
+                p_NumElems = 5,
+                p_Array = array)
+        self.failUnlessEqual(array.getvalue(), expectedData)
+
+    def testBindOutNumberArrayByVar(self):
+        "test binding out a Number array (with arrayvar)"
+        array = self.cursor.arrayvar(cx_Oracle.NUMBER, 6)
+        expectedData = [i * 100 for i in range(1, 7)]
+        self.cursor.execute(u"""
+                begin
+                  pkg_TestNumberArrays.TestOutArrays(:p_NumElems, :p_Array);
+                end;""",
+                p_NumElems = 6,
+                p_Array = array)
+        self.failUnlessEqual(array.getvalue(), expectedData)
+
+    def testBindOutSetInputSizes(self):
+        "test binding out with set input sizes defined"
+        vars = self.cursor.setinputsizes(value = cx_Oracle.NUMBER)
+        self.cursor.execute(u"""
+                begin
+                  :value := 5;
+                end;""")
+        self.failUnlessEqual(vars["value"].getvalue(), 5)
+
+    def testBindInOutSetInputSizes(self):
+        "test binding in/out with set input sizes defined"
+        vars = self.cursor.setinputsizes(value = cx_Oracle.NUMBER)
+        self.cursor.execute(u"""
+                begin
+                  :value := :value + 5;
+                end;""",
+                value = 1.25)
+        self.failUnlessEqual(vars["value"].getvalue(), 6.25)
+
+    def testBindOutVar(self):
+        "test binding out with cursor.var() method"
+        var = self.cursor.var(cx_Oracle.NUMBER)
+        self.cursor.execute(u"""
+                begin
+                  :value := 5;
+                end;""",
+                value = var)
+        self.failUnlessEqual(var.getvalue(), 5)
+
+    def testBindInOutVarDirectSet(self):
+        "test binding in/out with cursor.var() method"
+        var = self.cursor.var(cx_Oracle.NUMBER)
+        var.setvalue(0, 2.25)
+        self.cursor.execute(u"""
+                begin
+                  :value := :value + 5;
+                end;""",
+                value = var)
+        self.failUnlessEqual(var.getvalue(), 7.25)
+
+    def testCursorDescription(self):
+        "test cursor description is accurate"
+        self.cursor.execute(u"select * from TestNumbers")
+        self.failUnlessEqual(self.cursor.description,
+                [ (u'INTCOL', cx_Oracle.NUMBER, 10, 22, 9, 0, 0),
+                  (u'NUMBERCOL', cx_Oracle.NUMBER, 13, 22, 9, 2, 0),
+                  (u'FLOATCOL', cx_Oracle.NUMBER, 127, 22, 126, -127, 0),
+                  (u'UNCONSTRAINEDCOL', cx_Oracle.NUMBER, 127, 22, 0, -127, 0),
+                  (u'NULLABLECOL', cx_Oracle.NUMBER, 39, 22, 38, 0, 1) ])
+
+    def testFetchAll(self):
+        "test that fetching all of the data returns the correct results"
+        self.cursor.execute(u"select * From TestNumbers order by IntCol")
+        self.failUnlessEqual(self.cursor.fetchall(), self.rawData)
+        self.failUnlessEqual(self.cursor.fetchall(), [])
+
+    def testFetchMany(self):
+        "test that fetching data in chunks returns the correct results"
+        self.cursor.execute(u"select * From TestNumbers order by IntCol")
+        self.failUnlessEqual(self.cursor.fetchmany(3), self.rawData[0:3])
+        self.failUnlessEqual(self.cursor.fetchmany(2), self.rawData[3:5])
+        self.failUnlessEqual(self.cursor.fetchmany(4), self.rawData[5:9])
+        self.failUnlessEqual(self.cursor.fetchmany(3), self.rawData[9:])
+        self.failUnlessEqual(self.cursor.fetchmany(3), [])
+
+    def testFetchOne(self):
+        "test that fetching a single row returns the correct results"
+        self.cursor.execute(u"""
+                select *
+                from TestNumbers
+                where IntCol in (3, 4)
+                order by IntCol""")
+        self.failUnlessEqual(self.cursor.fetchone(), self.dataByKey[3])
+        self.failUnlessEqual(self.cursor.fetchone(), self.dataByKey[4])
+        self.failUnlessEqual(self.cursor.fetchone(), None)
+
+    def testReturnAsLong(self):
+        "test that fetching a long integer returns such in Python"
+        self.cursor.execute(u"""
+                select NullableCol
+                from TestNumbers
+                where IntCol = 9""")
+        col, = self.cursor.fetchone()
+        self.failUnless(isinstance(col, long), "long integer not returned")
+
+    def testReturnAsFloat(self):
+        "test that fetching a floating point number returns such in Python"
+        self.cursor.execute(u"select 1.25 from dual")
+        result, = self.cursor.fetchone()
+        self.failUnlessEqual(result, 1.25)
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/test/uObjectVar.py b/desktop/core/ext-py/cx_Oracle-5.1.2/test/uObjectVar.py
new file mode 100644
index 0000000..6e709d0
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/test/uObjectVar.py
@@ -0,0 +1,53 @@
+"""Module for testing object variables."""
+
+import sys
+
+class TestObjectVar(BaseTestCase):
+
+    def __TestData(self, expectedIntValue, expectedObjectValue,
+            expectedArrayValue):
+        intValue, objectValue, arrayValue = self.cursor.fetchone()
+        if objectValue is not None:
+            attributeValues = []
+            for attribute in objectValue.type.attributes:
+                value = getattr(objectValue, attribute.name)
+                attributeValues.append(value)
+            objectValue = tuple(attributeValues)
+        self.failUnlessEqual(intValue, expectedIntValue)
+        self.failUnlessEqual(objectValue, expectedObjectValue)
+        self.failUnlessEqual(arrayValue, expectedArrayValue)
+
+    def testFetchData(self):
+        "test fetching objects"
+        self.cursor.execute(u"""
+                select
+                  IntCol,
+                  ObjectCol,
+                  ArrayCol
+                from TestObjects
+                order by IntCol""")
+        self.failUnlessEqual(self.cursor.description,
+                [ (u'INTCOL', cx_Oracle.NUMBER, 10, 22, 9, 0, 0),
+                  (u'OBJECTCOL', cx_Oracle.OBJECT, -1, 2000, 0, 0, 1),
+                  (u'ARRAYCOL', cx_Oracle.OBJECT, -1, 2000, 0, 0, 1) ])
+        self.__TestData(1, (1, u'First row', u'First     ',
+                cx_Oracle.Timestamp(2007, 3, 6, 0, 0, 0),
+                cx_Oracle.Timestamp(2008, 9, 12, 16, 40)), [5, 10, None, 20])
+        self.__TestData(2, None, [3, None, 9, 12, 15])
+        self.__TestData(3, (3, u'Third row', u'Third     ',
+                cx_Oracle.Timestamp(2007, 6, 21, 0, 0, 0),
+                cx_Oracle.Timestamp(2007, 12, 13, 7, 30, 45)), None)
+
+    def testObjectType(self):
+        "test object type data"
+        self.cursor.execute(u"""
+                select ObjectCol
+                from TestObjects
+                where ObjectCol is not null
+                  and rownum <= 1""")
+        objValue, = self.cursor.fetchone()
+        self.failUnlessEqual(objValue.type.schema,
+                self.connection.username.upper())
+        self.failUnlessEqual(objValue.type.name, u"UDT_OBJECT")
+        self.failUnlessEqual(objValue.type.attributes[0].name, "NUMBERVALUE")
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/test/uSessionPool.py b/desktop/core/ext-py/cx_Oracle-5.1.2/test/uSessionPool.py
new file mode 100644
index 0000000..cbd5f91
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/test/uSessionPool.py
@@ -0,0 +1,98 @@
+"""Module for testing session pools."""
+
+import threading
+
+class TestConnection(TestCase):
+
+    def __ConnectAndDrop(self):
+        """Connect to the database, perform a query and drop the connection."""
+        connection = self.pool.acquire()
+        cursor = connection.cursor()
+        cursor.execute(u"select count(*) from TestNumbers")
+        count, = cursor.fetchone()
+        self.failUnlessEqual(count, 10)
+
+    def testPool(self):
+        """test that the pool is created and has the right attributes"""
+        pool = cx_Oracle.SessionPool(USERNAME, PASSWORD, TNSENTRY, 2, 8, 3)
+        self.failUnlessEqual(pool.username, USERNAME, "user name differs")
+        self.failUnlessEqual(pool.password, PASSWORD, "password differs")
+        self.failUnlessEqual(pool.tnsentry, TNSENTRY, "tnsentry differs")
+        self.failUnlessEqual(pool.max, 8, "max differs")
+        self.failUnlessEqual(pool.min, 2, "min differs")
+        self.failUnlessEqual(pool.increment, 3, "increment differs")
+        self.failUnlessEqual(pool.opened, 2, "opened differs")
+        self.failUnlessEqual(pool.busy, 0, "busy not 0 at start")
+        connection_1 = pool.acquire()
+        self.failUnlessEqual(pool.busy, 1, "busy not 1 after acquire")
+        self.failUnlessEqual(pool.opened, 2, "opened not unchanged (1)")
+        connection_2 = pool.acquire()
+        self.failUnlessEqual(pool.busy, 2, "busy not 2 after acquire")
+        self.failUnlessEqual(pool.opened, 2, "opened not unchanged (2)")
+        connection_3 = pool.acquire()
+        self.failUnlessEqual(pool.busy, 3, "busy not 3 after acquire")
+        self.failUnlessEqual(pool.opened, 5, "opened not changed (3)")
+        pool.release(connection_3)
+        self.failUnlessEqual(pool.busy, 2, "busy not 2 after release")
+        del connection_2
+        self.failUnlessEqual(pool.busy, 1, "busy not 1 after del")
+
+    def testProxyAuth(self):
+        """test that proxy authentication is possible"""
+        pool = cx_Oracle.SessionPool(USERNAME, PASSWORD, TNSENTRY, 2, 8, 3)
+        self.failUnlessEqual(pool.homogeneous, 1,
+                "homogeneous should be 1 by default")
+        self.failUnlessRaises(cx_Oracle.ProgrammingError, pool.acquire,
+                user = "proxyuser")
+        pool = cx_Oracle.SessionPool(USERNAME, PASSWORD, TNSENTRY, 2, 8, 3,
+                homogeneous = False)
+        self.failUnlessEqual(pool.homogeneous, 0,
+                "homogeneous should be 0 after setting it in the constructor")
+        user = u"%s_proxy" % USERNAME
+        connection = pool.acquire(user = user)
+        cursor = connection.cursor()
+        cursor.execute(u'select user from dual')
+        result, = cursor.fetchone()
+        self.assertEqual(result, user.upper())
+
+    def testRollbackOnDel(self):
+        "connection rolls back before being destroyed"
+        pool = cx_Oracle.SessionPool(USERNAME, PASSWORD, TNSENTRY, 1, 8, 3)
+        connection = pool.acquire()
+        cursor = connection.cursor()
+        cursor.execute(u"truncate table TestExecuteMany")
+        cursor.execute(u"insert into TestExecuteMany (IntCol) values (1)")
+        pool = cx_Oracle.SessionPool(USERNAME, PASSWORD, TNSENTRY, 1, 8, 3)
+        connection = pool.acquire()
+        cursor = connection.cursor()
+        cursor.execute(u"select count(*) from TestExecuteMany")
+        count, = cursor.fetchone()
+        self.failUnlessEqual(count, 0)
+
+    def testRollbackOnRelease(self):
+        "connection rolls back before released back to the pool"
+        pool = cx_Oracle.SessionPool(USERNAME, PASSWORD, TNSENTRY, 1, 8, 3)
+        connection = pool.acquire()
+        cursor = connection.cursor()
+        cursor.execute(u"truncate table TestExecuteMany")
+        cursor.execute(u"insert into TestExecuteMany (IntCol) values (1)")
+        pool.release(connection)
+        pool = cx_Oracle.SessionPool(USERNAME, PASSWORD, TNSENTRY, 1, 8, 3)
+        connection = pool.acquire()
+        cursor = connection.cursor()
+        cursor.execute(u"select count(*) from TestExecuteMany")
+        count, = cursor.fetchone()
+        self.failUnlessEqual(count, 0)
+
+    def testThreading(self):
+        """test session pool to database with multiple threads"""
+        self.pool = cx_Oracle.SessionPool(USERNAME, PASSWORD, TNSENTRY, 5, 20,
+                2, threaded = True)
+        threads = []
+        for i in range(20):
+            thread = threading.Thread(None, self.__ConnectAndDrop)
+            threads.append(thread)
+            thread.start()
+        for thread in threads:
+            thread.join()
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/test/uStringVar.py b/desktop/core/ext-py/cx_Oracle-5.1.2/test/uStringVar.py
new file mode 100644
index 0000000..23e74df
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/test/uStringVar.py
@@ -0,0 +1,266 @@
+"""Module for testing string variables."""
+
+class TestStringVar(BaseTestCase):
+
+    def setUp(self):
+        BaseTestCase.setUp(self)
+        self.rawData = []
+        self.dataByKey = {}
+        for i in range(1, 11):
+            stringCol = u"String %d" % i
+            fixedCharCol = (u"Fixed Char %d" % i).ljust(40)
+            rawCol = "Raw %d" % i
+            if i % 2:
+                nullableCol = u"Nullable %d" % i
+            else:
+                nullableCol = None
+            dataTuple = (i, stringCol, rawCol, fixedCharCol, nullableCol)
+            self.rawData.append(dataTuple)
+            self.dataByKey[i] = dataTuple
+
+    def testBindString(self):
+        "test binding in a string"
+        self.cursor.execute(u"""
+                select * from TestStrings
+                where StringCol = :p_Value""",
+                p_Value = u"String 5")
+        self.failUnlessEqual(self.cursor.fetchall(), [self.dataByKey[5]])
+
+    def testBindDifferentVar(self):
+        "test binding a different variable on second execution"
+        retval_1 = self.cursor.var(cx_Oracle.STRING, 30)
+        retval_2 = self.cursor.var(cx_Oracle.STRING, 30)
+        self.cursor.execute(u"begin :retval := 'Called'; end;",
+                retval = retval_1)
+        self.failUnlessEqual(retval_1.getvalue(), u"Called")
+        self.cursor.execute(u"begin :retval := 'Called'; end;",
+                retval = retval_2)
+        self.failUnlessEqual(retval_2.getvalue(), u"Called")
+
+    def testBindStringAfterNumber(self):
+        "test binding in a string after setting input sizes to a number"
+        self.cursor.setinputsizes(p_Value = cx_Oracle.NUMBER)
+        self.cursor.execute(u"""
+                select * from TestStrings
+                where StringCol = :p_Value""",
+                p_Value = u"String 6")
+        self.failUnlessEqual(self.cursor.fetchall(), [self.dataByKey[6]])
+
+    def testBindStringArrayBySizes(self):
+        "test binding in a string array (with setinputsizes)"
+        returnValue = self.cursor.var(cx_Oracle.NUMBER)
+        self.cursor.setinputsizes(p_Array = [cx_Oracle.STRING, 10])
+        array = [r[1] for r in self.rawData]
+        self.cursor.execute(u"""
+                begin
+                  :p_ReturnValue := pkg_TestStringArrays.TestInArrays(
+                      :p_IntegerValue, :p_Array);
+                end;""",
+                p_ReturnValue = returnValue,
+                p_IntegerValue = 6,
+                p_Array = array)
+        self.failUnlessEqual(returnValue.getvalue(), 87)
+
+    def testBindStringArrayByVar(self):
+        "test binding in a string array (with arrayvar)"
+        returnValue = self.cursor.var(cx_Oracle.NUMBER)
+        array = self.cursor.arrayvar(cx_Oracle.STRING, 10, 20)
+        array.setvalue(0, [r[1] for r in self.rawData])
+        self.cursor.execute(u"""
+                begin
+                  :p_ReturnValue := pkg_TestStringArrays.TestInArrays(
+                      :p_IntegerValue, :p_Array);
+                end;""",
+                p_ReturnValue = returnValue,
+                p_IntegerValue = 7,
+                p_Array = array)
+        self.failUnlessEqual(returnValue.getvalue(), 88)
+
+    def testBindInOutStringArrayByVar(self):
+        "test binding in/out a string array (with arrayvar)"
+        array = self.cursor.arrayvar(cx_Oracle.STRING, 10, 100)
+        originalData = [r[1] for r in self.rawData]
+        expectedData = [u"Converted element # %d originally had length %d" % \
+                (i, len(originalData[i - 1])) for i in range(1, 6)] + \
+                originalData[5:]
+        array.setvalue(0, originalData)
+        self.cursor.execute(u"""
+                begin
+                  pkg_TestStringArrays.TestInOutArrays(:p_NumElems, :p_Array);
+                end;""",
+                p_NumElems = 5,
+                p_Array = array)
+        self.failUnlessEqual(array.getvalue(), expectedData)
+
+    def testBindOutStringArrayByVar(self):
+        "test binding out a string array (with arrayvar)"
+        array = self.cursor.arrayvar(cx_Oracle.STRING, 6, 100)
+        expectedData = [u"Test out element # %d" % i for i in range(1, 7)]
+        self.cursor.execute(u"""
+                begin
+                  pkg_TestStringArrays.TestOutArrays(:p_NumElems, :p_Array);
+                end;""",
+                p_NumElems = 6,
+                p_Array = array)
+        self.failUnlessEqual(array.getvalue(), expectedData)
+
+    def testBindRaw(self):
+        "test binding in a raw"
+        self.cursor.setinputsizes(p_Value = cx_Oracle.BINARY)
+        self.cursor.execute(u"""
+                select * from TestStrings
+                where RawCol = :p_Value""",
+                p_Value = "Raw 4")
+        self.failUnlessEqual(self.cursor.fetchall(), [self.dataByKey[4]])
+
+    def testBindAndFetchRowid(self):
+        "test binding (and fetching) a rowid"
+        self.cursor.execute(u"""
+                select rowid
+                from TestStrings
+                where IntCol = 3""")
+        rowid, = self.cursor.fetchone()
+        self.cursor.execute(u"""
+                select *
+                from TestStrings
+                where rowid = :p_Value""",
+                p_Value = rowid)
+        self.failUnlessEqual(self.cursor.fetchall(), [self.dataByKey[3]])
+
+    def testBindNull(self):
+        "test binding in a null"
+        self.cursor.execute(u"""
+                select * from TestStrings
+                where StringCol = :p_Value""",
+                p_Value = None)
+        self.failUnlessEqual(self.cursor.fetchall(), [])
+
+    def testBindOutSetInputSizesByType(self):
+        "test binding out with set input sizes defined (by type)"
+        vars = self.cursor.setinputsizes(p_Value = cx_Oracle.STRING)
+        self.cursor.execute(u"""
+                begin
+                  :p_Value := 'TSI';
+                end;""")
+        self.failUnlessEqual(vars["p_Value"].getvalue(), u"TSI")
+
+    def testBindOutSetInputSizesByInteger(self):
+        "test binding out with set input sizes defined (by integer)"
+        vars = self.cursor.setinputsizes(p_Value = 30)
+        self.cursor.execute(u"""
+                begin
+                  :p_Value := 'TSI (I)';
+                end;""")
+        self.failUnlessEqual(vars["p_Value"].getvalue(), u"TSI (I)")
+
+    def testBindInOutSetInputSizesByType(self):
+        "test binding in/out with set input sizes defined (by type)"
+        vars = self.cursor.setinputsizes(p_Value = cx_Oracle.STRING)
+        self.cursor.execute(u"""
+                begin
+                  :p_Value := :p_Value || ' TSI';
+                end;""",
+                p_Value = u"InVal")
+        self.failUnlessEqual(vars["p_Value"].getvalue(), u"InVal TSI")
+
+    def testBindInOutSetInputSizesByInteger(self):
+        "test binding in/out with set input sizes defined (by integer)"
+        vars = self.cursor.setinputsizes(p_Value = 30)
+        self.cursor.execute(u"""
+                begin
+                  :p_Value := :p_Value || ' TSI (I)';
+                end;""",
+                p_Value = u"InVal")
+        self.failUnlessEqual(vars["p_Value"].getvalue(), u"InVal TSI (I)")
+
+    def testBindOutVar(self):
+        "test binding out with cursor.var() method"
+        var = self.cursor.var(cx_Oracle.STRING)
+        self.cursor.execute(u"""
+                begin
+                  :p_Value := 'TSI (VAR)';
+                end;""",
+                p_Value = var)
+        self.failUnlessEqual(var.getvalue(), u"TSI (VAR)")
+
+    def testBindInOutVarDirectSet(self):
+        "test binding in/out with cursor.var() method"
+        var = self.cursor.var(cx_Oracle.STRING)
+        var.setvalue(0, u"InVal")
+        self.cursor.execute(u"""
+                begin
+                  :p_Value := :p_Value || ' TSI (VAR)';
+                end;""",
+                p_Value = var)
+        self.failUnlessEqual(var.getvalue(), u"InVal TSI (VAR)")
+
+    def testBindLongString(self):
+        "test that binding a long string succeeds"
+        self.cursor.execute(u"""
+                declare
+                  t_Temp varchar2(10000);
+                begin
+                  t_Temp := :bigString;
+                end;""",
+                bigString = u"X" * 10000)
+
+    def testBindLongStringAfterSettingSize(self):
+        "test that setinputsizes() returns a long variable"
+        var = self.cursor.setinputsizes(test = 90000)["test"]
+        self.failUnlessEqual(type(var), cx_Oracle.LONG_STRING)
+        inString = u"1234567890" * 9000
+        var.setvalue(0, inString)
+        outString = var.getvalue()
+        self.failUnlessEqual(inString, outString,
+                "output does not match: in was %d, out was %d" % \
+                (len(inString), len(outString)))
+
+    def testStringMaximumReached(self):
+        "test that an error is raised when maximum string length exceeded"
+        var = self.cursor.setinputsizes(test = 100)["test"]
+        inString = u"1234567890" * 400
+        var.setvalue(0, inString)
+        outString = var.getvalue()
+        self.failUnlessEqual(inString, outString,
+                "output does not match: in was %d, out was %d" % \
+                (len(inString), len(outString)))
+        badStringSize = 4001
+        inString = u"X" * badStringSize
+        self.failUnlessRaises(ValueError, var.setvalue, 0, inString)
+
+    def testCursorDescription(self):
+        "test cursor description is accurate"
+        self.cursor.execute(u"select * from TestStrings")
+        self.failUnlessEqual(self.cursor.description,
+                [ (u'INTCOL', cx_Oracle.NUMBER, 10, 22, 9, 0, 0),
+                  (u'STRINGCOL', cx_Oracle.STRING, 20, 20, 0, 0, 0),
+                  (u'RAWCOL', cx_Oracle.BINARY, 30, 30, 0, 0, 0),
+                  (u'FIXEDCHARCOL', cx_Oracle.FIXED_CHAR, 40, 40, 0, 0, 0),
+                  (u'NULLABLECOL', cx_Oracle.STRING, 50, 50, 0, 0, 1) ])
+
+    def testFetchAll(self):
+        "test that fetching all of the data returns the correct results"
+        self.cursor.execute(u"select * From TestStrings order by IntCol")
+        self.failUnlessEqual(self.cursor.fetchall(), self.rawData)
+        self.failUnlessEqual(self.cursor.fetchall(), [])
+
+    def testFetchMany(self):
+        "test that fetching data in chunks returns the correct results"
+        self.cursor.execute(u"select * From TestStrings order by IntCol")
+        self.failUnlessEqual(self.cursor.fetchmany(3), self.rawData[0:3])
+        self.failUnlessEqual(self.cursor.fetchmany(2), self.rawData[3:5])
+        self.failUnlessEqual(self.cursor.fetchmany(4), self.rawData[5:9])
+        self.failUnlessEqual(self.cursor.fetchmany(3), self.rawData[9:])
+        self.failUnlessEqual(self.cursor.fetchmany(3), [])
+
+    def testFetchOne(self):
+        "test that fetching a single row returns the correct results"
+        self.cursor.execute(u"""
+                select *
+                from TestStrings
+                where IntCol in (3, 4)
+                order by IntCol""")
+        self.failUnlessEqual(self.cursor.fetchone(), self.dataByKey[3])
+        self.failUnlessEqual(self.cursor.fetchone(), self.dataByKey[4])
+        self.failUnlessEqual(self.cursor.fetchone(), None)
+
diff --git a/desktop/core/ext-py/cx_Oracle-5.1.2/test/uTimestampVar.py b/desktop/core/ext-py/cx_Oracle-5.1.2/test/uTimestampVar.py
new file mode 100644
index 0000000..47026a0
--- /dev/null
+++ b/desktop/core/ext-py/cx_Oracle-5.1.2/test/uTimestampVar.py
@@ -0,0 +1,130 @@
+"""Module for testing timestamp variables."""
+
+import time
+
+class TestTimestampVar(BaseTestCase):
+
+    def setUp(self):
+        BaseTestCase.setUp(self)
+        self.rawData = []
+        self.dataByKey = {}
+        for i in range(1, 11):
+            timeTuple = (2002, 12, 9, 0, 0, 0, 0, 0, -1)
+            timeInTicks = time.mktime(timeTuple) + i * 86400
+            dateValue = cx_Oracle.TimestampFromTicks(int(timeInTicks))
+            strValue = str(i * 50)
+            fsecond = int(strValue + "0" * (6 - len(strValue)))
+            dateCol = cx_Oracle.Timestamp(dateValue.year, dateValue.month,
+                    dateValue.day, dateValue.hour, dateValue.minute,
+                    i * 2, fsecond)
+            if i % 2:
+                timeInTicks = time.mktime(timeTuple) + i * 86400 + 86400
+                dateValue = cx_Oracle.TimestampFromTicks(int(timeInTicks))
+                strValue = str(i * 125)
+                fsecond = int(strValue + "0" * (6 - len(strValue)))
+                nullableCol = cx_Oracle.Timestamp(dateValue.year,
+                        dateValue.month, dateValue.day, dateValue.hour,
+                        dateValue.minute, i * 3, fsecond)
+            else:
+                nullableCol = None
+            tuple = (i, dateCol, nullableCol)
+            self.rawData.append(tuple)
+            self.dataByKey[i] = tuple
+
+    def testBindTimestamp(self):
+        "test binding in a timestamp"
+        self.cursor.setinputsizes(value = cx_Oracle.TIMESTAMP)
+        self.cursor.execute(u"""
+                select * from TestTimestamps
+                where TimestampCol = :value""",
+                value = cx_Oracle.Timestamp(2002, 12, 14, 0, 0, 10, 250000))
+        self.failUnlessEqual(self.cursor.fetchall(), [self.dataByKey[5]])
+
+    def testBindNull(self):
+        "test binding in a null"
+        self.cursor.setinputsizes(p_Value = cx_Oracle.TIMESTAMP)
+        self.cursor.execute(u"""
+                select * from TestTimestamps
+                where TimestampCol = :p_Value""",
+                p_Value = None)
+        self.failUnlessEqual(self.cursor.fetchall(), [])
+
+    def testBindOutSetInputSizes(self):
+        "test binding out with set input sizes defined"
+        vars = self.cursor.setinputsizes(p_Value = cx_Oracle.TIMESTAMP)
+        self.cursor.execute(u"""
+                begin
+                  :p_Value := to_timestamp('20021209', 'YYYYMMDD');
+                end;""")
+        self.failUnlessEqual(vars["p_Value"].getvalue(),
+               cx_Oracle.Timestamp(2002, 12, 9))
+
+    def testBindInOutSetInputSizes(self):
+        "test binding in/out with set input sizes defined"
+        vars = self.cursor.setinputsizes(p_Value = cx_Oracle.TIMESTAMP)
+        self.cursor.execute(u"""
+                begin
+                  :p_Value := :p_Value + 5.25;
+                end;""",
+                p_Value = cx_Oracle.Timestamp(2002, 12, 12, 10, 0, 0))
+        self.failUnlessEqual(vars["p_Value"].getvalue(),
+                cx_Oracle.Timestamp(2002, 12, 17, 16, 0, 0))
+
+    def testBindOutVar(self):
+        "test binding out with cursor.var() method"
+        var = self.cursor.var(cx_Oracle.TIMESTAMP)
+        self.cursor.execute(u"""
+                begin
+                  :p_Value := to_date('20021231 12:31:00',
+                      'YYYYMMDD HH24:MI:SS');
+                end;""",
+                p_Value = var)
+        self.failUnlessEqual(var.getvalue(),
+               cx_Oracle.Timestamp(2002, 12, 31, 12, 31, 0))
+
+    def testBindInOutVarDirectSet(self):
+        "test binding in/out with cursor.var() method"
+        var = self.cursor.var(cx_Oracle.TIMESTAMP)
+        var.setvalue(0, cx_Oracle.Timestamp(2002, 12, 9, 6, 0, 0))
+        self.cursor.execute(u"""
+                begin
+                  :p_Value := :p_Value + 5.25;
+                end;""",
+                p_Value = var)
+        self.failUnlessEqual(var.getvalue(),
+                cx_Oracle.Timestamp(2002, 12, 14, 12, 0, 0))
+
+    def testCursorDescription(self):
+        "test cursor description is accurate"
+        self.cursor.execute(u"select * from TestTimestamps")
+        self.failUnlessEqual(self.cursor.description,
+                [ ('INTCOL', cx_Oracle.NUMBER, 10, 22, 9, 0, 0),
+                  ('TIMESTAMPCOL', cx_Oracle.TIMESTAMP, -1, 11, 0, 0, 0),
+                  ('NULLABLECOL', cx_Oracle.TIMESTAMP, -1, 11, 0, 0, 1) ])
+
+    def testFetchAll(self):
+        "test that fetching all of the data returns the correct results"
+        self.cursor.execute(u"select * From TestTimestamps order by IntCol")
+        self.failUnlessEqual(self.cursor.fetchall(), self.rawData)
+        self.failUnlessEqual(self.cursor.fetchall(), [])
+
+    def testFetchMany(self):
+        "test that fetching data in chunks returns the correct results"
+        self.cursor.execute(u"select * From TestTimestamps order by IntCol")
+        self.failUnlessEqual(self.cursor.fetchmany(3), self.rawData[0:3])
+        self.failUnlessEqual(self.cursor.fetchmany(2), self.rawData[3:5])
+        self.failUnlessEqual(self.cursor.fetchmany(4), self.rawData[5:9])
+        self.failUnlessEqual(self.cursor.fetchmany(3), self.rawData[9:])
+        self.failUnlessEqual(self.cursor.fetchmany(3), [])
+
+    def testFetchOne(self):
+        "test that fetching a single row returns the correct results"
+        self.cursor.execute(u"""
+                select *
+                from TestTimestamps
+                where IntCol in (3, 4)
+                order by IntCol""")
+        self.failUnlessEqual(self.cursor.fetchone(), self.dataByKey[3])
+        self.failUnlessEqual(self.cursor.fetchone(), self.dataByKey[4])
+        self.failUnlessEqual(self.cursor.fetchone(), None)
+
diff --git a/ext/thirdparty/README.md b/ext/thirdparty/README.md
index 3007822..6dfe2f4 100644
--- a/ext/thirdparty/README.md
+++ b/ext/thirdparty/README.md
@@ -12,6 +12,7 @@ Checked-in third party dependencies
 |Y|CherryPy|3.1.2|BSD|http://www.cherrypy.org/|
 |Y|ConfigObj|4.6.0|BSD|http://www.voidspace.org.uk/python/configobj.html|
 |Y|ctypes|1.0.2|MIT|http://pypi.python.org/pypi/ctypes|
+|Y|cx_Oracle|5.1.2|Python|http://downloads.sourceforge.net/project/cx-oracle/5.1.2/cx_Oracle-5.1.2.tar.gz|
 |Y|Django|1.2.3|BSD|http://www.djangoproject.com/download/1.2.3/tarball/|
 |Y|django-auth-ldap|1.0.7|BSD|http://bitbucket.org/psagers/django-auth-ldap/|
 |Y|Django_cpserver|19739bea057d824d9cd6c10c4caec622e8e1c0b9|BSD|http://github.com/lincolnloop/django-cpserver/|
-- 
1.7.9.5

